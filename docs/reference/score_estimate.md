# Calculate scoring statistics from predictions.

This performs a range of continuous scoring metrics for each estimate
time-point using cumulative distribution functions for each estimate.
Point quality metrics are calculated for each estimate provided and
summarised. Summarisation is performed using bootstrap resampling to
generate confidence intervals for summary statistics, which are
presented as median +/1 95% CI.

## Usage

``` r
score_estimate(
  est,
  obs,
  lags = NULL,
  summarise_by = est %>% dplyr::groups(),
  bootstraps = 1000,
  raw_bootstraps = FALSE,
  seed = 100
)
```

## Arguments

- est:

  a dataframe of estimates of incidence, growth rate of reproduction
  number based off a simulation or data with known parameters. Each
  group in `est` is expected to contain multiple estimates and each
  group is scored separately. Estimates in `est` must be in the form of
  a column named `XXX.cdf` containing a cumulative distribution function
  for the estimate and `XXX.link` containing a link function
  specification (one if `identity`,`log` or `logit`). These are not
  generated by default by the `ggoutbreak` estimators but are triggered
  by setting the option: `options("ggoutbreak.keep_cdf"=TRUE)` before
  running the estimator. The CDFs generated will be analytical, if the
  estimator generates a parametrised output (or a mixture thereof),
  empirical if the estimator uses resampling, or inferred if the
  estimator produces quantiles only.

- obs:

  a dataframe of the ground truth, sharing the same grouping and columns
  as `est` with at least one column(s) named `XXX.obs` with `XXX` being
  e.g. `rt`,`growth` or `incidence` or any other column group predicted
  in `est` (i.e. if `obs` has a column `XXX.obs`, `est` must have one
  called `XXX.cdf`).

- lags:

  a data frame of estimate types and lags as output by
  [`quantify_lag()`](https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.md)
  if multiple models are included then the columns must match those in
  `obs`. It must have 2 columns, one called `estimate` with values
  matching `incidence`,`rt`,`growth`,`proportion`,`relative.growth`, and
  a `lag` column, with (whole) number of days.

- summarise_by:

  by default every group is treated separately. This can be overridden
  with a `dplyr` specification of the groupings we want to see in the
  final summarised output (e.g. if we want to differentiate performance
  on a particular type of scenario or timeframe). If this is exactly
  `FALSE` the function will return all the raw point estimates.

- bootstraps:

  the number of bootstrap replicates to draw for assessing metric
  confidence. If FALSE then no bootstrapping will be done and the
  metrics returned will have no confidence intervals.

- raw_bootstraps:

  (defaults to FALSE) return the summary metrics for each bootstrap
  rather than the quantiles of the summary metrics.

- seed:

  a random seed for reproducibility

## Value

a dataframe of scoring metrics, with one row per group. This includes
the following columns:

- `mean_quantile_bias` - the average of the universal residuals. Lower
  values are better.

- `mean_trans_bias` - the bias on the link function scale.

- link - the link function

- `mean_bias` - the bias on the natural scale (which may be interpreted
  as additive or multiplicative depending on the link)

- `pit_was` - an unadjusted probability integral transform histogram
  Wasserstein distance from the uniform (lower values are better).

- `unbiased_pit_was` - an PIT Wasserstein distance from the uniform,
  adjusted for estimator bias (lower values are better). This is a
  measure of calibration.

- `directed_pit_was` - a PIT Wasserstein distance from the uniform,
  directed away from the centre, adjusted for estimator bias (values
  closer to zero are better, positive values indicate overconfidence,
  and negative values excessively conservative estimates).

- `percent_iqr_coverage` - the percentage of estimators that include the
  true value in their IQR. For a perfectly calibrated estimate this
  should be 0.5. Lower values reflect overconfidence, higher values
  reflect excessively conservative estimates. This is a measure of
  calibration but is influenced by bias.

- `unbiased_percent_iqr_coverage` - the percentage of estimators that
  include the true value in their IQR once adjusted for bias. This
  should be 0.5. This is a measure of calibration, and tells you which
  direction (smaller numbers are over-confident, larger values
  excessively conservative).

- `mean_prediction_interval_width_50` - the prediction interval width is
  a measure of sharpness (smaller values are sharper). Sharper
  estimators are superior if they are unbiased and well calibrated.

- `mean_crps` - the mean value of the continuous rank probability score
  for each point estimate (lower values are better)

- `mean_unbiased_crps` - the mean value of the continuous rank
  probability score for each point estimate assessed after adjustment
  for bias (lower values are better)

- `threshold_misclassification_probability` - if a metric has a natural
  threshold like 1 for Rt then this measures how probable it is that the
  estimate will propose the epidemic is shrinking when it is growing and
  vice versa. Lower is better

other outputs are possible if `summarise_by` is false.

## Examples

``` r
data = example_poisson_rt_smooth()

pipeline = ~ .x %>% poisson_locfit_model(ip = .y, quick=TRUE)
lags = quantify_lag(pipeline, ip = example_ip())
#> Rt estimation using Locfit (approx and assuming independence)

withr::with_options(list("ggoutbreak.keep_cdf"=TRUE),{
   est = data %>% poisson_locfit_model(ip = example_ip(), quick=TRUE)
})
#> Rt estimation using Locfit (approx and assuming independence)
#> Estimates were assumed to be independent, but more that 1% of estimates
#> are at risk of Rt underestimation by more that 0.05 (absolute).
#> We advise re-running supplying a full variance-covariance matrix, or
#> a value to the `raw` parameter, or setting `quick=FALSE`.

if (interactive()) plot_rt(est)+sim_geom_function(data, colour="red")

obs = data %>% dplyr::mutate(rt.obs = rt, incidence.obs = rate)
score_estimate(est,obs,lags) %>% dplyr::glimpse()
#> estimates match true observations using columns: statistic,time
#> matching ground truth observations for: rt,incidence
#> Rows: 2
#> Columns: 58
#> Groups: link, statistic, .type [2]
#> $ link                                          <chr> "log", "log"
#> $ statistic                                     <chr> "infections", "infection…
#> $ .type                                         <chr> "incidence", "rt"
#> $ mean_crps.0.025                               <dbl> 1.93982524, 0.04065555
#> $ mean_crps.0.25                                <dbl> 2.19500375, 0.05145481
#> $ mean_crps.0.5                                 <dbl> 2.33869497, 0.05717235
#> $ mean_crps.0.75                                <dbl> 2.47816716, 0.06358048
#> $ mean_crps.0.975                               <dbl> 2.77987505, 0.07523793
#> $ threshold_misclassification_probability.0.025 <dbl> NA, 0.004833323
#> $ threshold_misclassification_probability.0.25  <dbl> NA, 0.007434785
#> $ threshold_misclassification_probability.0.5   <dbl> NA, 0.008856984
#> $ threshold_misclassification_probability.0.75  <dbl> NA, 0.01043123
#> $ threshold_misclassification_probability.0.975 <dbl> NA, 0.0140164
#> $ mean_trans_bias.0.025                         <dbl> -0.01616321, -0.12592279
#> $ mean_trans_bias.0.25                          <dbl> 0.004897355, -0.093588166
#> $ mean_trans_bias.0.5                           <dbl> 0.02153076, -0.07608119
#> $ mean_trans_bias.0.75                          <dbl> 0.04167561, -0.05894074
#> $ mean_trans_bias.0.975                         <dbl> 0.08976234, -0.03217674
#> $ mean_bias.0.025                               <dbl> 0.9884317, 0.9295702
#> $ mean_bias.0.25                                <dbl> 1.0242773, 0.9477855
#> $ mean_bias.0.5                                 <dbl> 1.2994351, 0.9581371
#> $ mean_bias.0.75                                <dbl> 1.5769584, 0.9673193
#> $ mean_bias.0.975                               <dbl> 1.9533930, 0.9829475
#> $ mean_quantile_bias.0.025                      <dbl> -0.05163924, -0.11443655
#> $ mean_quantile_bias.0.25                       <dbl> -0.0006678875, -0.073096…
#> $ mean_quantile_bias.0.5                        <dbl> 0.02647988, -0.05124280
#> $ mean_quantile_bias.0.75                       <dbl> 0.05283766, -0.03080356
#> $ mean_quantile_bias.0.975                      <dbl> 0.098590960, 0.008533926
#> $ mean_prediction_interval_width_50.0.025       <dbl> 5.6662792, 0.1179279
#> $ mean_prediction_interval_width_50.0.25        <dbl> 6.3409316, 0.1278832
#> $ mean_prediction_interval_width_50.0.5         <dbl> 6.6968921, 0.1328567
#> $ mean_prediction_interval_width_50.0.75        <dbl> 7.1032701, 0.1380066
#> $ mean_prediction_interval_width_50.0.975       <dbl> 7.8254487, 0.1466452
#> $ pit_was.0.025                                 <dbl> 0.03217994, 0.09103595
#> $ pit_was.0.25                                  <dbl> 0.04230504, 0.10333543
#> $ pit_was.0.5                                   <dbl> 0.04842707, 0.10959923
#> $ pit_was.0.75                                  <dbl> 0.05563772, 0.11509796
#> $ pit_was.0.975                                 <dbl> 0.06882274, 0.12641803
#> $ unbiased_pit_was.0.025                        <dbl> 0.2030397, 0.1095131
#> $ unbiased_pit_was.0.25                         <dbl> 0.2280281, 0.1283578
#> $ unbiased_pit_was.0.5                          <dbl> 0.2404459, 0.1380022
#> $ unbiased_pit_was.0.75                         <dbl> 0.2525317, 0.1472046
#> $ unbiased_pit_was.0.975                        <dbl> 0.2735984, 0.1658654
#> $ directed_pit_was.0.025                        <dbl> -0.08092513, -0.10676696
#> $ directed_pit_was.0.25                         <dbl> -0.06780535, -0.09011268
#> $ directed_pit_was.0.5                          <dbl> -0.06094499, -0.08224791
#> $ directed_pit_was.0.75                         <dbl> -0.05435920, -0.07347916
#> $ directed_pit_was.0.975                        <dbl> -0.04178462, -0.05609468
#> $ percent_iqr_coverage.0.025                    <dbl> 0.5714286, 0.7453416
#> $ percent_iqr_coverage.0.25                     <dbl> 0.6149068, 0.7888199
#> $ percent_iqr_coverage.0.5                      <dbl> 0.6397516, 0.8074534
#> $ percent_iqr_coverage.0.75                     <dbl> 0.6645963, 0.8322981
#> $ percent_iqr_coverage.0.975                    <dbl> 0.7142857, 0.8633540
#> $ unbiased_percent_iqr_coverage.0.025           <dbl> 0.3726708, 0.5155280
#> $ unbiased_percent_iqr_coverage.0.25            <dbl> 0.4223602, 0.5714286
#> $ unbiased_percent_iqr_coverage.0.5             <dbl> 0.4472050, 0.5962733
#> $ unbiased_percent_iqr_coverage.0.75            <dbl> 0.4782609, 0.6211180
#> $ unbiased_percent_iqr_coverage.0.975           <dbl> 0.5218944, 0.6708075
```
