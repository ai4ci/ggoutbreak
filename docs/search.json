[{"path":"https://ai4ci.github.io/ggoutbreak/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 ggoutbreak authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/covid-timeseries.html","id":"incidence-and-growth-rate-from-case-positive-counts","dir":"Articles","previous_headings":"","what":"Incidence and growth rate from case positive counts","title":"England COVID-19 cases","text":"method uses case positive count dataset bundled growth rates age stratified (age grouping class column). look age stratification different vignettes instance want aggregate England wide rate. purpose time_aggregate() performs simple summarisation. raw COVID-19 case count log1p scale total detected cases per day.  Major events timeseries can plotted axes. ’ve focussed first 2 years pandemic:  incidence model assumes case rates result Poisson process rate estimated time varying locally fitted polynomial degree defined deg parameter, using log link function, according methods Loader et al. (see utils::citation(\"locfit\")). fitting process local maximum likelihood estimation uses bandwidth defined account data points within window time point estimated. gradient fitted polynomial log scale, exponential growth rate. scale independent view rate growth epidemic. estimation methodology compared consensus estimates SPI-M-O UK government advisory group red, shifted forward time 21 days. SPI-M-O estimates made pandemic retrospective whereas ones can use information time point now may better represent timing changes.  state epidemic described incidence growth, phase plots allow us see different time points. case epidemic state 10 weeks leading Christmas 2021, 2022 2023:","code":"england_covid %>% dplyr::glimpse() #> Rows: 26,790 #> Columns: 5 #> Groups: class [19] #> $ date  <date> 2023-12-09, 2023-12-09, 2023-12-09, 2023-12-09, 2023-12-09, 202… #> $ class <fct> 00_04, 05_09, 10_14, 15_19, 20_24, 25_29, 30_34, 35_39, 40_44, 4… #> $ count <dbl> 24, 8, 8, 4, 21, 20, 29, 36, 41, 59, 53, 54, 56, 54, 67, 72, 56,… #> $ denom <dbl> 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771,… #> $ time  <time_prd> 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409,…  tmp = ggoutbreak::england_covid %>%   time_aggregate(count=sum(count)) fit = tmp %>%    poisson_locfit_model()   plot_incidence(fit,raw = tmp, colour=\"blue\",size=0.025)+   scale_y_log1p(n=7) plot_incidence(fit, raw = tmp,events = england_events, colour=\"blue\",size=0.025)+   scale_y_log1p(n=7) + ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\"))) plot_growth_rate(fit,events = england_events, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\")), ylim=c(-0.15,0.15))+   ggplot2::geom_errorbar(data=england_consensus_growth_rate,ggplot2::aes(x=date-21,ymin=low,ymax=high),colour=\"red\") plot_growth_phase(fit,     timepoints = as.Date(c(\"Xmas 2020\"=\"2020-12-25\",\"Xmas 2021\"=\"2021-12-25\",\"Xmas 2022\"=\"2022-12-25\")),     duration = 70,      interval = 7,     colour=\"blue\",     strip.position = \"top\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/covid-timeseries.html","id":"reproduction-number-estimation-from-growth-rates","dir":"Articles","previous_headings":"","what":"Reproduction number estimation from growth rates","title":"England COVID-19 cases","text":"growth rate unit “per day” example. can derive reproduction number. Using methods Wallinga Lipsitch estimate infectivity profile COVID-19. describes probability infectee infected x days infector, includes temporal dimension rendering reproduction number dimensionless quantity reflecting average number infectees resulting infector. ggoutbreak estimate infectivity profile based meta-analysis serial interval estimates COVID-19. infectivity profile bootstrapped set discrete probability distributions. truncated 14 days.  growth rate estimate methods uses 1000 bootstraps propagate uncertainty hence somewhat slow. use memoise cache result. effective RtR_t estimates compared consensus values SPI-M-O group (red):  EpiEstim RtR_t fits comparison data, infectivity profile much certain exhibit oscillation due weekly periodicity underlying time series. oscillation accentuated truncated infectivity profile using .","code":"ggoutbreak::plot_ip(ggoutbreak::covid_ip, alpha=0.1) # .cache = memoise::cache_filesystem(rappdirs::user_cache_dir(\"ggoutbreak\")) #  # cached_rt_from_growth_rate = memoise::memoise( #   ggoutbreak::rt_from_growth_rate, #   cache = .cache # )  rt_fit = fit %>% ggoutbreak::rt_from_growth_rate(ip = covid_ip)  plot_rt(rt_fit, events = england_events, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\")), ylim=c(0.6,1.6))+   ggplot2::geom_errorbar(data=england_consensus_rt,ggplot2::aes(x=date-21,ymin=low,ymax=high),colour=\"red\") rt_epi_fit = tmp %>% ggoutbreak::rt_epiestim(ip = covid_ip,window = 14)  plot_rt(rt_epi_fit, events = england_events, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\")), ylim=c(0.6,1.6))+   ggplot2::geom_errorbar(data=england_consensus_rt,ggplot2::aes(x=date-7,ymin=low,ymax=high),colour=\"red\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/covid-timeseries.html","id":"prevalence-and-growth-rate-from-test-positivity-rates","dir":"Articles","previous_headings":"","what":"Prevalence and growth rate from test positivity rates","title":"England COVID-19 cases","text":"Test availability consistent pandemic. early stages PCR tests difficult obtain case positive incidence estimates thought vast underestimate. certain parts pandemic targeted testing high risk groups occurred. Test positivity different view pandemic accounts biases introduces others . data must contain denom column case represents number tests conducted:  case gradient proportion logistic scale estimate growth rate. senses relative growth testing effort case produces answer similar incidence model.  similar growth rate estimates method can also theoretically used calculate estimates RtR_t. Growth-proportion phase diagrams can also compare different points times see elsewhere, different populations.","code":"england_covid_pcr_positivity %>% dplyr::glimpse() #> Rows: 1,413 #> Columns: 4 #> $ date  <date> 2023-12-12, 2023-12-11, 2023-12-10, 2023-12-09, 2023-12-08, 202… #> $ time  <time_prd> 1444, 1443, 1442, 1441, 1440, 1439, 1438, 1437, 1436, 1435,… #> $ count <dbl> 375, 509, 381, 350, 445, 399, 430, 457, 413, 295, 252, 293, 343,… #> $ denom <dbl> 1707, 5884, 5514, 6001, 7840, 8333, 8946, 10139, 9805, 6445, 638… fit2 = england_covid_pcr_positivity %>%   ggoutbreak::proportion_locfit_model()  plot_proportion(fit2, england_covid_pcr_positivity, events = england_events, size=0.25, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\"))) plot_growth_rate(fit2, events = england_events, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2022-01-01\")), ylim=c(-0.15,0.15))+   ggplot2::geom_errorbar(data=england_consensus_growth_rate,ggplot2::aes(x=date-21,ymin=low,ymax=high),colour=\"red\") plot_growth_phase(fit2,     timepoints = as.Date(c(\"Xmas 2020\"=\"2020-12-25\",\"Xmas 2021\"=\"2021-12-25\",\"Xmas 2022\"=\"2022-12-25\")),     duration = 70,      interval = 7,     colour=\"blue\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/covid-timeseries.html","id":"nhs-covid-app","dir":"Articles","previous_headings":"","what":"NHS COVID app","title":"England COVID-19 cases","text":"NHS COVID-19 app performed digital contact tracing. rate venue check-ins demonstrates levels high risk social contacts however became optional Aug 2021. Self isolation alerts peaked Aug / Sept 2021 Delta wave Dec 2021 / Jan 2022 Omicron wave. Periods rapid growth precede increases NHS app notifications. (N.B. data https://www.gov.uk/government/publications/nhs-covid-19-app-statistics)","code":"p1 = plot_incidence(fit,events = england_events, colour=\"blue\", date_breaks=\"3 months\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2023-07-01\")))+   ggplot2::facet_wrap(~\"Cases\")+   ggplot2::theme(axis.text.x.bottom = ggplot2::element_blank())+   scale_y_log1p()  p2 = plot_growth_rate(fit,events = england_events, colour=\"blue\", date_breaks=\"3 months\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2023-07-01\")), ylim=c(-0.15,0.15))+   ggplot2::geom_errorbar(data=england_consensus_growth_rate,ggplot2::aes(x=date-21,ymin=low,ymax=high),colour=\"red\")+   ggplot2::facet_wrap(~\"Growth rate\")+   ggplot2::theme(axis.text.x.bottom = ggplot2::element_blank(),axis.text.x.top = ggplot2::element_blank())  p3 = ggplot2::ggplot(ggoutbreak::england_nhs_app)+   geom_events(events=england_events,hide_labels = TRUE)+   ggplot2::geom_step(ggplot2::aes(x=date, y=alerts/mean(alerts, na.rm=TRUE),colour=\"alerts\"))+   ggplot2::geom_step(ggplot2::aes(x=date, y=visits/mean(visits, na.rm=TRUE),colour=\"venue visits\"))+   ggplot2::geom_rect(ggplot2::aes(xmin=date,xmax=dplyr::lead(date), ymin=0, ymax=alerts/mean(alerts, na.rm=TRUE),fill=\"alerts\"), linewidth=0, alpha=0.2)+   ggplot2::geom_rect(ggplot2::aes(xmin=date,xmax=dplyr::lead(date), ymin=0, ymax=visits/mean(visits, na.rm=TRUE),fill=\"venue visits\"), linewidth=0, alpha=0.2)+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2023-07-01\")))+   ggplot2::ylab(\"relative frequency\")+   ggplot2::xlab(NULL)+   ggplot2::facet_wrap(~\"NHS app\")+   ggplot2::scale_color_brewer(palette=\"Dark2\", name=NULL, aesthetics = c(\"fill\",\"colour\"))+   ggplot2::scale_x_date(date_breaks=\"3 months\",date_labels = \"%b %y\")+   ggplot2::theme(legend.position = \"bottom\")  p1+p2+p3+patchwork::plot_layout(ncol=1)"},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"simple-incidence-test-with-a-poisson-model","dir":"Articles","previous_headings":"Locfit models","what":"Simple incidence test with a poisson model","title":"Simulation tests for growth rate estimators","text":"incidence mode based absolute counts:  Estimated absolute growth rate versus simulation (red)","code":"data = sim_poisson_model() data %>% dplyr::glimpse() #> Rows: 105 #> Columns: 6 #> Groups: statistic [1] #> $ time      <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1… #> $ growth    <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, … #> $ imports   <dbl> 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… #> $ rate      <dbl> 100.0000, 110.5171, 122.1403, 134.9859, 149.1825, 164.8721, … #> $ count     <int> 91, 105, 134, 150, 132, 164, 176, 215, 204, 242, 273, 315, 3… #> $ statistic <chr> \"infections\", \"infections\", \"infections\", \"infections\", \"inf… tmp = data %>% poisson_locfit_model(window=7, deg = 2)  plot_incidence(tmp, data)+ggplot2::geom_line(   mapping=ggplot2::aes(x=as.Date(time),y=rate), data=data, colour=\"red\",inherit.aes = FALSE) plot_growth_rate(tmp)+   ggplot2::geom_line(mapping=ggplot2::aes(x=as.Date(time),y=growth), data=data, colour=\"red\",inherit.aes = FALSE) plot_growth_phase(tmp)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"multinomial-data","dir":"Articles","previous_headings":"Locfit models","what":"Multinomial data","title":"Simulation tests for growth rate estimators","text":"Multiple classes simulated 3 independent epidemics (‘variant1’, ‘variant2’ ‘variant3’) known growth rates initial sample size resulting 3 parallel time series. combined give overall epidemic proportional distribution ‘variant’ fraction whole. relative growth rate calculated based set parameters.","code":"data2 = sim_multinomial() %>% dplyr::group_by(class) %>% dplyr::glimpse() #> Rows: 315 #> Columns: 10 #> Groups: class [3] #> $ time            <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,… #> $ growth          <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,… #> $ imports         <dbl> 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… #> $ rate            <dbl> 100.0000, 110.5171, 122.1403, 134.9859, 149.1825, 164.… #> $ count           <int> 96, 108, 122, 150, 156, 157, 192, 182, 225, 262, 294, … #> $ statistic       <chr> \"infections\", \"infections\", \"infections\", \"infections\"… #> $ class           <chr> \"variant1\", \"variant1\", \"variant1\", \"variant1\", \"varia… #> $ proportion      <dbl> 0.3333333, 0.3382826, 0.3420088, 0.3445125, 0.3458146,… #> $ proportion.obs  <dbl> 0.3333333, 0.3375000, 0.3495702, 0.3440367, 0.3458980,… #> $ relative.growth <dbl> 0.025000000, 0.019385523, 0.013833622, 0.008404115, 0.…"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"poisson-model","dir":"Articles","previous_headings":"Locfit models > Multinomial data","what":"Poisson model","title":"Simulation tests for growth rate estimators","text":"Firstly fitting incidence model groupwise fashion:  absolute growth rates:","code":"tmp2 = data2 %>% poisson_locfit_model(window=7, deg = 1)  plot_incidence(tmp2, data2)+scale_y_log1p() plot_growth_rate(modelled = tmp2)+    ggplot2::geom_line(mapping=ggplot2::aes(x=as.Date(time),y=growth, colour=class), data=data2, inherit.aes = FALSE)+    ggplot2::facet_wrap(dplyr::vars(class), ncol=1)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"one-versus-others-binomial-model","dir":"Articles","previous_headings":"Locfit models > Multinomial data","what":"One versus others Binomial model","title":"Simulation tests for growth rate estimators","text":"looks proportions three variants growth rate relative : Firstly proportions:  secondly relative growth rate:","code":"# This will reinterpret total to be the total of positives across all variants data3 = data2 %>%    dplyr::group_by(time) %>%    dplyr::mutate(denom = sum(count)) %>%   dplyr::group_by(class) %>%   dplyr::glimpse() #> Rows: 315 #> Columns: 11 #> Groups: class [3] #> $ time            <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,… #> $ growth          <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,… #> $ imports         <dbl> 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… #> $ rate            <dbl> 100.0000, 110.5171, 122.1403, 134.9859, 149.1825, 164.… #> $ count           <int> 96, 108, 122, 150, 156, 157, 192, 182, 225, 262, 294, … #> $ statistic       <chr> \"infections\", \"infections\", \"infections\", \"infections\"… #> $ class           <chr> \"variant1\", \"variant1\", \"variant1\", \"variant1\", \"varia… #> $ proportion      <dbl> 0.3333333, 0.3382826, 0.3420088, 0.3445125, 0.3458146,… #> $ proportion.obs  <dbl> 0.3333333, 0.3375000, 0.3495702, 0.3440367, 0.3458980,… #> $ relative.growth <dbl> 0.025000000, 0.019385523, 0.013833622, 0.008404115, 0.… #> $ denom           <int> 288, 320, 349, 436, 451, 454, 557, 531, 662, 778, 884,… tmp3 = data3 %>% proportion_locfit_model(window=14, deg = 2)  plot_proportion(modelled = tmp3,raw = data3)+   ggplot2::facet_wrap(dplyr::vars(class), ncol=1) plot_growth_rate(modelled = tmp3)+    ggplot2::geom_line(mapping=ggplot2::aes(x=as.Date(time),y=relative.growth, colour=class), data=data2, inherit.aes = FALSE)+    ggplot2::facet_wrap(dplyr::vars(class), ncol=1) plot_growth_phase(tmp3)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"multinomial-model","dir":"Articles","previous_headings":"Locfit models > Multinomial data","what":"Multinomial model","title":"Simulation tests for growth rate estimators","text":"multinomial model gives us absolute proportions (growth rates)","code":"# we don't need to calculate the denominator as it is done automatically by the  # multinomial model  tmp4 = data2 %>% multinomial_nnet_model() #> # weights:  30 (18 variable) #> initial  value 355785.589685  #> iter  10 value 179725.259459 #> iter  20 value 176787.262245 #> final  value 174948.423688  #> converged plot_multinomial(tmp4) # plot_multinomial(tmp3, events = event_test,normalise = TRUE)"},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"poisson-model-1","dir":"Articles","previous_headings":"GLM models","what":"Poisson model","title":"Simulation tests for growth rate estimators","text":"Run poisson model input data using glm returns incidence derived growth rates point supported.","code":"tmp5 = data %>% poisson_glm_model(window=7) plot_incidence(tmp5,data)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/estimators-example.html","id":"binomial-model","dir":"Articles","previous_headings":"GLM models","what":"Binomial model","title":"Simulation tests for growth rate estimators","text":"Run binomial model input data using glm returns absolute proportions derived growth rates point supported.","code":"tmp6 = data3 %>% proportion_glm_model(window=14, deg = 2) plot_proportion(tmp6,data3)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Getting started with `ggoutbreak`","text":"Collection tools COVID-19 focus simplicity goal provide simple pipeline data visualisation https://github.com/ai4ci/ggoutbreak AI4CI r-universe Simulation Poisson (aggregate count) & branching process (line list) Time varying parametrisations Test harness estimators, including scoring metrics. Estimation Collection methods incidence, growth rate, reproduction number (wrappers existing tools) Poisson count binomial/multinomial proportion models Visualization","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"models","dir":"Articles","previous_headings":"Simulation","what":"Models:","title":"Getting started with `ggoutbreak`","text":"Poisson growth rate Poisson reproduction number Branching process model SEIR ODE","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"time-varying-parameters","dir":"Articles","previous_headings":"Simulation","what":"Time varying parameters:","title":"Getting started with `ggoutbreak`","text":"Rt / growth rate Importation Generation time Ascertainment Delay observation, e.g. symptoms, admissions, death Contact matrices Dispersion","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"scoring","dir":"Articles","previous_headings":"Simulation","what":"Scoring","title":"Getting started with `ggoutbreak`","text":"mean_quantile_bias - average universal residuals. Lower values better. mean_trans_bias - bias link function scale. link - link function mean_bias - bias natural scale (may interpreted additive multiplicative depending link) pit_was - unadjusted probability integral transform histogram Wasserstein distance uniform (lower values better). unbiased_pit_was - PIT Wasserstein distance uniform, adjusted estimator bias (lower values better). directed_pit_was - PIT Wasserstein distance uniform, directed away centre, adjusted estimator bias (values closer zero better, positive values indicate overconfidence, negative values excessively conservative estimates). percent_iqr_coverage - percentage estimators include true value IQR. perfectly calibrated estimate 0.5. Lower values reflect overconfidence, higher values reflect excessively conservative estimates. unbiased_percent_iqr_coverage - percentage estimators include true value IQR adjusted bias mean_crps - mean value continuous rank probability score point estimate (lower values better) mean_unbiased_crps - mean value continuous rank probability score point estimate assessed adjustment bias (lower values better)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"estimation-methods","dir":"Articles","previous_headings":"","what":"Estimation methods","title":"Getting started with `ggoutbreak`","text":"Rapid simple estimates multiple sub-groups Supports daily / weekly / monthly / yearly time series* Testing estimators simulations","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"infectivity-profile-estimation","dir":"Articles","previous_headings":"Estimation methods","what":"Infectivity profile estimation","title":"Getting started with `ggoutbreak`","text":"Estimation generation time serial interval published estimates (including uncertainty) Resampled raw interval data (bootstrapping uncertainty) posterior estimates fitted gamma distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"poisson-rate-models","dir":"Articles","previous_headings":"Estimation methods","what":"Poisson rate models","title":"Getting started with `ggoutbreak`","text":"Locfit GLM fitted time varying quasipoisson model. Estimates incidence growth rate Normalisation per capita population population baseline rate","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"binomial-proportion-models","dir":"Articles","previous_headings":"Estimation methods","what":"Binomial proportion models","title":"Getting started with `ggoutbreak`","text":"Locfit GLM fitted time varying quasibinomial model. Estimates proportion relative growth rate Normalisation population baseline risk","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"reimplementation-of-cori-method","dir":"Articles","previous_headings":"Estimation methods > RtR_t estimation methods:","what":"Reimplementation of Cori method","title":"Getting started with `ggoutbreak`","text":"Inputs raw incidence time series Reimplementation integrates estimates range time windows Handles missing data. Less lag uncertainty.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"wallinga-and-lipsitch-growth-rates-method","dir":"Articles","previous_headings":"Estimation methods > RtR_t estimation methods:","what":"Wallinga and Lipsitch growth rates method","title":"Getting started with `ggoutbreak`","text":"Inputs exponential growth rate time series estimate (assumed normally distributed) Uses MGF discrete SI distribution Monte-Carlo resampling propagation uncertainty Moderately slow","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/ggoutbreak.html","id":"r_t-from-modelled-incidence","dir":"Articles","previous_headings":"Estimation methods > RtR_t estimation methods:","what":"RtR_t from modelled incidence","title":"Getting started with `ggoutbreak`","text":"Inputs log-normally distributed incidence estimate. Propagates uncertainty infectivity profile incidence data Deterministic & tolerant missing values. Can use weekly count time series. Can deal negative values serial interval","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/incidence-trends.html","id":"incidence-poisson-rate-model","dir":"Articles","previous_headings":"","what":"Incidence Poisson rate model","title":"Population comparisons and incidence","text":"plot normalised incidence rates COVID-19 population size, shows initially rate COVID cases highest elderly. late 2020 pattern changed rates uniform across age groups. early 2021 vaccination took hold school testing rolled , younger age groups higher rates COVID positive tests, curious spike young age groups around November 2021. early 2022 pattern reversed elderly became age group highest rates, pattern persisted present. Transiently instantaneous rates per 1000 person years exceeded 1000 age groups, possible limited time periods, multiple episodes per year can observed.  use test positives proxy COVID incidence clearly potentially biased testing (particularly first wave testing limited hospital). reliable comparison situation test positive proportion, unfortunately testing rates published broken age. exponential growth rate already normalised population size. Comparisons growth rate populations gives idea tightly coupled . age groups epidemic growing shrinking sync apart possibly young. COVID detections age group particularly reliable though easy -interpret.  combination growth normalised incidence allows us compare epidemic state different time points, case Christmas day 2020, 2021 2022. shows data previous graphs.","code":"tmp = ggoutbreak::england_covid %>%    ggoutbreak::poisson_locfit_model(window=21) %>%    ggoutbreak::normalise_incidence(ggoutbreak::england_demographics, population_unit=1000, normalise_time=\"1 year\")  raw_pop = ggoutbreak::england_covid %>%    ggoutbreak::normalise_count(ggoutbreak::england_demographics, population_unit=1000, normalise_time=\"1 year\")  plot_incidence(tmp,raw = raw_pop, size=0.25)+scale_y_log1p(n=7)+   ggplot2::scale_colour_viridis_d(aesthetics = c(\"fill\",\"colour\")) plot_growth_rate(tmp)+   ggplot2::scale_fill_viridis_d(aesthetics = c(\"fill\",\"colour\"))+   ggplot2::coord_cartesian(ylim=c(-0.15,0.15)) plot_growth_phase(tmp,     timepoints = as.Date(c(\"Xmas 2020\"=\"2020-12-25\",\"Xmas 2021\"=\"2021-12-25\",\"Xmas 2022\"=\"2022-12-25\")),     duration = 70,      interval = 7 )+   ggplot2::scale_colour_viridis_d()"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/incidence-trends.html","id":"proportion-model","dir":"Articles","previous_headings":"","what":"Proportion model","title":"Population comparisons and incidence","text":"two possible proportions models interest . mentioned proportion positive tests age group give us clearer picture whether differences age groups differential testing, unfortunately available data set. second potential use distribution ages test positive age group. age distribution gives us information burden disease population also biased test prioritisation. multinomial proportion shows similar patterns normalised incidence plot :  age distribution test positives can normalised age distribution population. give us relative proportion age groups people testing positive versus expected population. conceptually relative risk age group given COVID status .e. P(age=80+|COVID+)P(age=80+)\\frac{P(age = 80+|COVID+)}{P(age = 80+)} point time given population quantity centred around 1 comparing growth rate gives us possibly clearer picture trajectory relative distribution COVID population. Xmas 2021 although majority cases young, relatively high growth elderly population meant catching , can see early 2022 elderly highest COVID positive rates. 2022 however, separation age groups established trajectories acting preserve separation.","code":"tmp2 = ggoutbreak::england_covid %>%    ggoutbreak::proportion_locfit_model(window=21)  p1 = plot_multinomial(tmp2,normalise = TRUE)+   ggplot2::scale_fill_viridis_d()  p2 = ggplot2::ggplot(england_demographics)+   ggplot2::geom_bar(ggplot2::aes(x=\"baseline\",y=population/sum(population)*100,fill=class), stat=\"identity\", position=\"stack\", colour=\"black\", linewidth=0.1)+   ggplot2::scale_fill_viridis_d(guide=\"none\")+   ggplot2::xlab(NULL)+   ggplot2::ylab(NULL)+   ggplot2::theme(axis.text.y = ggplot2::element_blank())+   ggplot2::coord_cartesian(expand=FALSE)  p1+p2+patchwork::plot_layout(nrow=1,widths = c(20,1),guides = \"collect\") tmp3 = tmp2 %>% infer_risk_ratio(england_demographics)  plot_growth_phase(tmp3,     timepoints = as.Date(c(\"Xmas 2020\"=\"2020-12-25\",\"Xmas 2021\"=\"2021-12-25\",\"Xmas 2022\"=\"2022-12-25\")),     duration = 70,      interval = 7 )+   ggplot2::scale_colour_viridis_d()"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/incidence-trends.html","id":"pre-test-probability","dir":"Articles","previous_headings":"Proportion model","what":"Pre test probability","title":"Population comparisons and incidence","text":"Using ONS COVID-19 infection survey can look population prevalence based random sampling (panel ). proportion people positive random sample population can compared proportion people testing positive people tested. ratio indication pre-test probability disease non-random sample group gives us idea selectively testing applied. testing done people symptoms example pre-test probability disease higher general population. shown panel B, also can interpreted biased sample tested symptoms . Likewise incidence cases per capita can compared prevalence. prevalence-like estimate can made incidence convolving incidence estimate delay distribution represents duration infection. Duration infection represented either sensitivity test detect infection function time infection, probability successful viral culture function time symptom onset. case ratio prevalence derived positive case counts, resulting symptomatic testing, prevalence measured directly random sample ONS survey connection ascertainment rate. actual value ascertainment rate calculated method depends heavily assumptions duration infection, hence prevalence derived case rates, absolute value derived ascertainment reliable, however relative change number still informative demonstrates case ascertainment fell abruptly omicron wave (panel C).","code":"p1 = ggoutbreak::plot_prevalence(     ggoutbreak::england_ons_infection_survey %>% dplyr::filter(geography == \"England\"),     events = ggoutbreak::england_events   )+   ggplot2::theme(     axis.title.x = ggplot2::element_blank(),      axis.text.x = ggplot2::element_blank(),      axis.text.x.bottom = ggplot2::element_blank()   )+   ggplot2::ylab(\"ONS prevalence (%)\")   p2 = ggoutbreak::england_covid_pcr_positivity %>%   proportion_locfit_model() %>%   dplyr::inner_join(ggoutbreak::england_ons_infection_survey %>%                        dplyr::filter(geography==\"England\") %>%                        dplyr::rename_with(.cols = tidyselect::starts_with(\"prevalence\"), .fn = ~stringr::str_replace(.x,\"prevalence\",\"ons\")), by=c(\"time\")   ) %>%   dplyr::transmute(date=date, pre_test_odds = proportion.0.5 / ons.0.5) %>%   ggplot2::ggplot(ggplot2::aes(x=date,y=pre_test_odds)) + ggplot2::geom_line() +   ggplot2::geom_hline(yintercept=1, colour=\"grey40\",linetype=\"dashed\") +   ggplot2::ylab(\"Pre-test odds ratio\") +   ggoutbreak::geom_events(events = ggoutbreak::england_events,hide_labels = TRUE)+   ggplot2::theme(     axis.title.x = ggplot2::element_blank(),      axis.text.x = ggplot2::element_blank(),      axis.text.x.bottom = ggplot2::element_blank(),      axis.text.x.top = ggplot2::element_blank()   ) england_pop = ggoutbreak::england_demographics %>% dplyr::ungroup() %>% dplyr::summarise(population = sum(population))  p3 = ggoutbreak::england_covid_pcr_positivity %>%    ggoutbreak::poisson_locfit_model() %>%   # N.B. `covid_viral_shedding` is technically from symptom onset not infection.   # We could argue that this is a good thing as case positivity is closer in time   # to symptom onset however this is forgetting about all the cases that would   # test positive if they had been tested. An alternative to this would have been    # to use `covid_test_sensitivity` which looks at probability of detection from    # time of infection but it is only in cases with proven infection so a biased    # prior.   ggoutbreak::infer_prevalence(pop = england_pop, ip = covid_viral_shedding) %>%   dplyr::inner_join(england_ons_infection_survey %>%                        dplyr::filter(geography==\"England\") %>%                        dplyr::rename_with(.cols = tidyselect::starts_with(\"prevalence\"), .fn = ~stringr::str_replace(.x,\"prevalence\",\"ons\")), by=c(\"time\")   ) %>%   dplyr::transmute(date=date, ascertainment = prevalence.0.5 / ons.0.5 * 100) %>%   ggplot2::ggplot(ggplot2::aes(x=date,y=ascertainment)) +    ggplot2::geom_line() +    ggplot2::ylab(\"Ascertainment rate (%)\") +   ggoutbreak::geom_events(events = ggoutbreak::england_events,hide_labels = TRUE)   p1+p2+p3+patchwork::plot_layout(ncol=1)+patchwork::plot_annotation(tag_levels=\"A\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/infectivity-profile-discretisation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Infectivity profile discretisation","text":"methods involved EpiEstim require infectivity profile discrete probability distribution probability transmission time zero zero. diseases shorter serial interval, constraints difficult resolve, discretisation infectivity profile distribution using offset 1 gamma distribution results unusual shape discrete distribution. Wallinga-Lipsitch framework estimating reproduction number growth rate constraints apply can compare EpiEstims discretisation approach one closer originally estimated continuous distribution, requires framework can handle non zero probability transmission day zero. comparison suggests discretisation may bias EpiEstims estimates reproduction number 20% growth rates high, even higher compared equilibrium point Rt=1R_t=1. Alternative strategies discretisation frameworks relax requirement probability infection zero time zero benefit investigation particularly diseases shorter serial interval.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/rt-from-incidence.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimating the reproduction number from modelled incidence","text":"estimated incidence disease ItI_t using poisson rate using maximum likelihood estimators, rate typically log-normally distributed parameters μ\\mu σ\\sigma. fitted model shown log1p scale, COVID-19 epidemic England:  appealing use modelled incidence estimate calculate estimate reproduction number, RtR_t. Incidence models can derived number ways, easily inspected error can made tolerant missing values outliers.","code":"raw = ggoutbreak::england_covid %>%   time_aggregate(count=sum(count))  fit = raw %>% poisson_locfit_model()  plot_incidence(fit,raw, colour=\"blue\",size=0.025,events = england_events)+   scale_y_log1p()+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2023-01-01\")))"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/rt-from-incidence.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Estimating the reproduction number from modelled incidence","text":"use modelled estimate incidence predict RtR_t need propagate uncertainty incidence RtR_t estimates. calculate RtR_t can use backwards-looking renewal equations incorporate infectivity profile disease (ω\\omega) number days infection (τ\\tau): ∼Lognormal(μt,σt)Rt=∑τωτIt−τ \\begin{align} I_t &\\sim Lognormal(\\mu_t,\\sigma_t) \\\\ R_t &= \\frac{I_t}{\\sum_{\\tau}{\\omega_{\\tau}I_{t-\\tau}}} \\end{align} giving us: Rt=Lognormal(μt,σt)∑τLognormal(μt−τ+log(ωτ),σt−τ) \\begin{align} R_t = \\frac{Lognormal(\\mu_t,\\sigma_t)}{\\sum_{\\tau}{   Lognormal( \\mu_{t-\\tau} + log(\\omega_{\\tau}) , \\sigma_{t-\\tau}) }} \\end{align} sum ii log normal distributions can approximated another log normal (Lo 2013) parameters μZ\\mu_Z σZ\\sigma_Z. S+=E[∑iXi]=∑iE[Xi]=∑ieμi+12σi2σZ2=1S+2∑,jcorijσiσjE[Xi]E[Xj]=1S+2∑,jcorijσiσjeμi+12σi2eμj+12σj2μZ=ln(S+)−12σZ2 \\begin{align}     S_+ &= \\operatorname{E}\\left[\\sum_i X_i \\right] = \\sum_i      \\operatorname{E}[X_i] =      \\sum_i e^{\\mu_i + \\frac{1}{2}\\sigma_i^2}     \\\\     \\sigma^2_{Z} &= \\frac{1}{S_+^2} \\, \\sum_{,j}       \\operatorname{cor}_{ij} \\sigma_i \\sigma_j \\operatorname{E}[X_i] \\operatorname{E}[X_j] =       \\frac{1}{S_+^2} \\, \\sum_{,j}       \\operatorname{cor}_{ij} \\sigma_i \\sigma_j e^{\\mu_i+\\frac{1}{2}\\sigma_i^2}        e^{\\mu_j+\\frac{1}{2}\\sigma_j^2}      \\\\     \\mu_Z &= \\ln\\left( S_+ \\right) - \\frac{1}{2}\\sigma_{Z}^2  \\end{align} sum term denominator renewal equations consists set correlated scaled log normal distributions scale correlation defined infectivity profile (ω\\omega). case corijcor_{ij} can equated infectivity profile (ω|−j|\\omega_{|-j|}) ≠ji \\neq j 1 =ji = j. μi\\mu_i μt−τ+ln(ωτ)\\mu_{t-\\tau} + ln(\\omega_{\\tau}). St=∑s=1|ω|ωseμt−s+12σt−s2σZ,t=∑,j=1|ω|(ω|−j|+(,j))ωiωj(σ(t−)eμ(t−)+12σ(t−)2)(σ(t−j)eμ(t−j)+12σ(t−j)2)St2μZ,t=log(St)−12σZ,t2 \\begin{align}     S_{t} &= \\sum_{s=1}^{|\\omega|} { \\omega_s e^{\\mu_{t-s} + \\frac{1}{2}\\sigma_{t-s}^2 }} \\\\     \\sigma_{Z,t} &= \\sqrt{       \\frac{         \\sum_{,j=1}^{|\\omega|} {         (\\omega_{|-j|}+(,j)) \\omega_i \\omega_j (\\sigma_{(t-)} e^{\\mu_{(t-)}+\\frac{1}{2}\\sigma_{(t-)}^2}) (\\sigma_{(t-j)} e^{\\mu_{(t-j)}+\\frac{1}{2}\\sigma_{(t-j)}^2})          }       }{S_{t}^2}     }   \\\\     \\mu_{Z,t} &= \\log\\left( S_{t} \\right) - \\frac{1}{2}\\sigma_{Z,t}^2  \\end{align} μ\\mu central estimate case counts log scale, standard deviation can also large. numerical stability issues dealing terms involving e(μ+σ2)e^{(\\mu+\\sigma^2)}, however keeping everything log space using optimised log-sum-exp functions can made computationally tractable. log(St)=log(∑s=1|ω|eμt−s+12σt−s2+log(ωs))log(Tt,τ)=log(ωτ)+log(σ(t−τ))+μ(t−τ)+12σ(t−τ)2)log(cori,j)=log(ω|−j|+(=j))log(σZ,t2)=log(∑,j=1|ω|elog(cori,j)+log(Tt,)+log(Tt,j))−2log(St)μZ,t=log(St)−12σZ,t2 \\begin{align}     \\log(S_{t}) &= \\log(\\sum_{s=1}^{|\\omega|} {  e^{\\mu_{t-s} + \\frac{1}{2}\\sigma_{t-s}^2 + \\log(\\omega_s) }}) \\\\     \\log(T_{t,\\tau}) &= \\log(\\omega_{\\tau}) + \\log(\\sigma_{(t-{\\tau})}) + \\mu_{(t-{\\tau})} + \\frac{1}{2}\\sigma_{(t-{\\tau})}^2) \\\\     \\log(cor_{,j}) &= \\log(\\omega_{|-j|}+(=j)) \\\\     \\log(\\sigma_{Z,t}^2) &= \\log(         \\sum_{,j=1}^{|\\omega|} {           e^{             \\log(cor_{,j}) + \\log(T_{t,}) + \\log(T_{t,j})           }         }) - 2 \\log(S_{t}) \\\\     \\mu_{Z,t} &= \\log( S_{t} ) - \\frac{1}{2}\\sigma_{Z,t}^2  \\end{align} N.B. assume individual estimates incidence uncorrelated simplifies : log(σZ,t2)=log(∑τ=1|ω|e2log(Tt,τ))−2log(St) \\begin{align} \\log(\\sigma_{Z,t}^2) &= \\log(         \\sum_{\\tau=1}^{|\\omega|} {           e^{             2 \\log(T_{t,\\tau})           }         }) - 2 \\log(S_{t}) \\end{align} Empirically huge amount difference estimates two forms. infectivity profile ω\\omega spread large period correlation matrix O(ω)2O(\\omega)^2 may predicate simpler order 1 formulation. μZ,t\\mu_{Z,t} σZ,t\\sigma_{Z,t} left final derivation RtR_t, giving us distributional form RtR_t incorporating uncertainty modelled incidence estimates: Rt=Lognormal(μt,σt)Lognormal(μZ,t,σZ,t)μRt=μt−μZ,tσRt=σt2+σz,t2Rt=Lognormal(μRt,σRt) \\begin{align} R_t &= \\frac{Lognormal(\\mu_t,\\sigma_t)} {Lognormal( \\mu_{Z,t}, \\sigma_{Z,t})} \\\\ \\mu_{R_t} &= \\mu_t - \\mu_{Z,t} \\\\ \\sigma_{R_t} &= \\sqrt{\\sigma_t^2+\\sigma_{z,t}^2} \\\\ R_t &= Lognormal(\\mu_{R_t}, \\sigma_{R_t}) \\end{align} conditioned single known infectivity profile (ω\\omega). reality also uncertainty infectivity profile, however assume particular distributional form . can use set empirical estimates infectivity profile (Ω\\Omega) calculate multiple distributional estimates reproduction number (Rt,ωR_{t,\\omega}) combine mixture distribution. much can say mixture distribution, depend nature various empirical infectivity profile distributions. However, can use general properties mixture distributions generate estimates mean variance reproduction number including uncertainty arising multiple infection profile estimates (Rt*R_t^*): E[Rt|ω]=e(μRt,ω−12σRt,ω2)V[Rt|ω]=[e(σRt,ω2)−1][e2μRt,ω+σRt,ω2]E[Rt*]=1|Ω|∑ω∈ΩE[Rt|ω]V[Rt*]=1|Ω|(∑ω∈ΩV[Rt|ω]+E[Rt|ω]2)−E[Rt*]2 \\begin{align} E[R_t|\\omega] &= e^{(\\mu_{R_t,\\omega} - \\frac{1}{2}\\sigma_{R_t,\\omega}^2)} \\\\ V[R_t|\\omega] &= \\big[   e^{(\\sigma_{R_t,\\omega}^2)} - 1 \\big] \\big[   e^{2 \\mu_{R_t,\\omega} + \\sigma_{R_t,\\omega}^2} \\big] \\\\ E[R_t^*] &= \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} E[{R_t|\\omega}] \\\\ V[R_t^*] &= \\frac{1}{|\\Omega|} \\bigg(\\sum_{\\omega \\\\Omega}{V[R_t|\\omega]+E[R_t|\\omega]^2}\\bigg) - E[R_t^*]^2 \\\\ \\end{align} cumulative distribution function mixture simply arithmetic mean component cumulative distribution functions (conditioned infectivity profile). Φ\\Phi cumulative distribution function standard normal distribution: FRt*(x)=1|Ω|∑ω∈ΩFRt(x|ω)P(Rt*≤x)=1|Ω|∑ω∈ΩP(Rt,ω≤x)P(Rt*≤x)=1|Ω|∑ω∈ΩΦ(ln(x)−μRt,ωσRt,ω) \\begin{align} F_{R_t^*}(x) &= \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega}F_{R_t}(x|\\omega) \\\\ P(R_t^* \\le x) &= \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} P(R_{t,\\omega} \\le x) \\\\ P(R_t^* \\le x) &= \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} \\Phi\\bigg(\\frac{ln(x) - \\mu_{R_t,\\omega}}{\\sigma_{R_t,\\omega}}\\bigg) \\end{align} cumulative density function mixture distribution strictly increasing function specific solutions median 95% confidence intervals can calculated numerically solving following equations: 1|Ω|∑ω∈ΩΦ(ln(q0.025)−μRt,ωσRt,ω)−0.025=01|Ω|∑ω∈ΩΦ(ln(q0.5)−μRt,ωσRt,ω)−0.5=01|Ω|∑ω∈ΩΦ(ln(q0.975)−μRt,ωσRt,ω)−0.975=0 \\begin{align} \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} \\Phi\\bigg(\\frac{ln(q_{0.025}) - \\mu_{R_t,\\omega}}{\\sigma_{R_t,\\omega}}\\bigg) - 0.025 &= 0 \\\\ \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} \\Phi\\bigg(\\frac{ln(q_{0.5}) - \\mu_{R_t,\\omega}}{\\sigma_{R_t,\\omega}}\\bigg) - 0.5 &= 0 \\\\ \\frac{1}{|\\Omega|}\\sum_{\\omega \\\\Omega} \\Phi\\bigg(\\frac{ln(q_{0.975}) - \\mu_{R_t,\\omega}}{\\sigma_{R_t,\\omega}}\\bigg) - 0.975 &= 0 \\end{align} Numerical solutions moderately expensive perform. reasonable approximation can expected matching moments log normal distribution mean E[Rt*]E[R_t^*] variance V[Rt*]V[R_t^*] mixture. gives us final lightweight closed form estimator reproduction number given set infectivity profiles, Rt,Ω¯\\overline{R_{t,\\Omega}}, : μt|Ω=log(E[Rt*]2E[Rt*]2+V[Rt*])σt|Ω=log(1+V[Rt*]E[Rt*]2)Rt|Ω¯∼Lognormal(μt|Ω,σt|Ω) \\begin{align} \\mu_{t|\\Omega} &= log\\bigg(\\frac{E[R_t^*]^2}{\\sqrt{E[R_t^*]^2 + V[R_t^*]}}\\bigg)         \\\\ \\sigma_{t|\\Omega} &= \\sqrt{log\\bigg(1 + \\frac{V[R_t^*]}{E[R_t^*]^2}\\bigg)}\\\\ \\overline{R_{t|\\Omega}} &\\sim Lognormal(\\mu_{t|\\Omega},\\sigma_{t|\\Omega}) \\end{align}","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/rt-from-incidence.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Estimating the reproduction number from modelled incidence","text":"method implemented using following R function, designed numerical stability speed. Generating RtR_t estimates given modelled incidence typically occurring matter seconds:","code":"print(ggoutbreak:::.internal_r_t_estim) #> function (mu, sigma, omega, mu_t, sigma_t, cor = FALSE, approx = TRUE)  #> { #>     omega_m = as.matrix(omega) #>     omega_m = apply(omega_m, MARGIN = 2, rev) #>     tmp = apply(omega_m, MARGIN = 2, function(omega) { #>         log_S_t = .logsumexp(mu_t + sigma_t^2/2 + log(omega)) #>         log_T_t_tau = mu_t + sigma_t^2/2 + log(omega) + log(sigma_t) #>         if (cor) { #>             n = length(omega) #>             idx = 0:(n^2 - 1) #>             i = idx%/%n #>             j = idx%%n #>             log_cor_ij = c(0, log(omega))[abs(i - j) + 1] #>             log_var_Zt_ij = log_cor_ij + log_T_t_tau[i + 1] +  #>                 log_T_t_tau[j + 1] #>         } #>         else { #>             log_var_Zt_ij = 2 * log_T_t_tau #>         } #>         log_var_Zt = .logsumexp(log_var_Zt_ij) - 2 * log_S_t #>         var_Zt = exp(log_var_Zt) #>         mu_Zt = log_S_t - var_Zt/2 #>         mu_Rt = mu - mu_Zt #>         var_Rt = sigma^2 + var_Zt #>         return(c(mu_Rt, var_Rt)) #>     }) #>     mu_Rt = tmp[1, ] #>     var_Rt = tmp[2, ] #>     sigma_Rt = sqrt(var_Rt) #>     means = exp(mu_Rt + var_Rt/2) #>     vars = (exp(var_Rt) - 1) * exp(2 * mu_Rt + var_Rt) #>     mean_star = mean(means) #>     var_star = mean(vars + means^2) - mean_star^2 #>     out = tibble::tibble(rt.fit = log(mean_star) - log(var_star/mean_star^2 +  #>         1)/2, rt.se.fit = sqrt(log(1 + var_star/mean_star^2))) #>     if (approx) { #>         out = out %>% .result_from_fit(type = \"rt\", qfn = function(p) stats::qlnorm(p,  #>             .$rt.fit, .$rt.se.fit)) %>% .keep_cdf(type = \"rt\",  #>             meanlog = .$rt.fit, sdlog = .$rt.se.fit, link = \"log\") #>     } #>     else { #>         out = out %>% .result_from_fit(type = \"rt\", qfn = function(p) { #>             .qmixlnorm(p, meanlogs = mu_Rt, sdlogs = sigma_Rt,  #>                 method = \"exact\") #>         }) %>% .keep_cdf(type = \"rt\", meanlog = list(mu_Rt),  #>             sdlog = list(sigma_Rt), link = \"log\") #>     } #>     return(out) #> } #> <bytecode: 0x6168637b5968> #> <environment: namespace:ggoutbreak>"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/rt-from-incidence.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Estimating the reproduction number from modelled incidence","text":"Testing incidence model shown , comparing results SPI-M-O consensus RtR_t estimates gives us following time-series England. formally evaluated elsewhere qualitatively good fit. took seconds calculate reproduction number single time series 1410 time points , opens possibility performing RtR_t estimates fine grained geographical demographic subgroups.","code":"system.time({   rt_fit = fit %>% ggoutbreak::rt_from_incidence(ip = covid_ip, approx = TRUE) }) #>    user  system elapsed  #>   3.796   0.000   3.797  plot_rt(rt_fit, events = england_events, colour=\"blue\")+   ggplot2::coord_cartesian(xlim=as.Date(c(\"2020-01-01\",\"2023-01-01\")), ylim=c(0.6,1.6))+   ggplot2::geom_errorbar(data=england_consensus_rt,ggplot2::aes(x=date-14,ymin=low,ymax=high),colour=\"red\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/rt-from-incidence.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Estimating the reproduction number from modelled incidence","text":"present methodology deriving RtR_t modelled estimates incidence propagating uncertainty. demonstrate produces satisfactory qualitative results COVID-19 data. method relatively quick, fully deterministic, can used top statistical models estimating incidence use logarithmic link functions.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/sampling-serial-interval.html","id":"alternative-resampling","dir":"Articles","previous_headings":"","what":"Alternative resampling","title":"Sampling the infectivity profile from published serial interval estimates","text":"mean SD gamma distribution modelled EpiEstim independent truncated normally distributed quantities, assumed know mean, sd, lower upper bounds distribution. assumption breaks SD gamma distributions close mean, correlation SD mean. alternative assumption mean SD infectivity profile gamma distributions correlated log-normal distributed quantities. case see results MCMC fitting seem correlated log scale feasible normally distributed.  Let us also assume rather knowledge mean, sd, etc, know median 95% credible intervals distribution mean SD, commonly reported literature. time also assume know degree correlation. re-sampling process produces closer set distributions EpiEstim approach, assume can estimate correlation mean SD.  distributions better fit derived original data sampling strategy EpiEstim produce resampled distributions incompatible discretisation strategy EpiEstim mean < 1. samples excluded allow used Cori method. make difference?  EpiEstim’s default resampling strategy example results slightly less skewed discretised infectivity profile distribution either original data derived (raw mcmc) log-normally resampled correlation (corr log normal). result can examined looking EpiEstim estimates reproduction number using different infectivity profiles. simulate artificial incidence timeseries set growth rates use EpiEstim produce reproduction number estimates synthetic timeseries using either data-derived infectivity profiles (raw mcmc), EpiEstim resampled infectivity profiles (epiestim), correlated log-normal resampled infectivity profiles (corr log normal):  Compared reproduction number estimates mcmc originals, epiestim re-sampling using correlated log-normals similar. produce correlated log-normals assuming knowledge correlation mean SD, usually specified published data.","code":"# They are a correlated approximately lognormal distributed quantity ggplot2::ggplot(gammas,ggplot2::aes(x=lmean,y=lsd))+ggplot2::geom_point(alpha=0.1)+ggplot2::geom_rug(alpha=0.02) correlation = stats::cor(gammas$mean, gammas$sd) correlation ## [1] 0.7326295 # However typically we will be provided with quantiles of mean and SD # We can log transform quantiles and estimate a normal distribution # on the log scale. quantiles = gammas %>%    dplyr::select(mean, sd) %>%    dplyr::reframe(dplyr::across(tidyselect::everything(), ~ stats::quantile(p=c(0.025,0.5,0.975),.x))) %>% dplyr::mutate(p=c(0.025,0.5,0.975)) quantiles %>% dplyr::glimpse() ## Rows: 3 ## Columns: 3 ## $ mean <dbl> 0.9295801, 1.4852901, 2.3556312 ## $ sd   <dbl> 0.8905979, 1.4079267, 2.7878889 ## $ p    <dbl> 0.025, 0.500, 0.975 # We can log transform quantiles and estimate a normal distribution # on the log scale. quantiles = quantiles %>% dplyr::mutate(lmean = log(mean), lsd = log(sd), z = stats::qnorm(p))  # this linear model fits a (log)normal distribution to provided quantiles. # lm coefficients - intercept is mean and z gradient is sd. lmMean = stats::lm(formula = lmean~z, quantiles)$coeff lmSd = stats::lm(formula = lsd~z, quantiles)$coeff  # means here is mean of mu=log(mean) and mean of sigma=log(sd) means2 = c(lmMean[1],lmSd[1]) names(means2) = c(\"lmean\",\"lsd\")  # sds here is sd of mu=log(mean) and sd of sigma=log(sd) sds2 = c(lmMean[2],lmSd[2]) names(sds2) = c(\"lmean\",\"lsd\")  .cor2cov = function(correlation, sds) {   corMatrix = matrix(c(1,correlation,correlation,1),nrow = 2)   covMatrix2 = diag(sds) %*% corMatrix %*% diag(sds)   colnames(covMatrix2) = names(sds)   rownames(covMatrix2) = names(sds)   return(covMatrix2) }  covMatrix2 = .cor2cov(correlation, sds2)  simulated2 = MASS::mvrnorm(n=5000, mu=means2, Sigma = covMatrix2) %>% as.data.frame() simulated2 = simulated2 %>% dplyr::mutate(mean = exp(lmean), sd = exp(lsd), shape = (mean^2)/(sd^2), rate = mean/(sd^2)) comparison2 = dplyr::bind_rows(     simulated2 %>% dplyr::mutate(source=\"corr log normal\"),     gammas %>% dplyr::mutate(source = \"raw mcmc\")   ) %>% dplyr::mutate(source = factor(source,labels = c(\"raw mcmc\",\"corr log normal\")))  p1 = ggplot2::ggplot(comparison2)+   ggplot2::geom_point(mapping=ggplot2::aes(x=mean,y=sd,colour=source), alpha = 0.1)+   ggplot2::geom_abline()  p2 = ggplot2::ggplot(comparison2)+   ggplot2::geom_point(mapping=ggplot2::aes(x=shape,y=rate,colour=source),alpha=0.1)  p1+p2+patchwork::plot_annotation(tag_levels = \"A\") comparison = dplyr::bind_rows(     epiestim_si_samples %>% dplyr::mutate(source=\"epiestim\"),     simulated2 %>% dplyr::mutate(source=\"corr log normal\"),     gammas %>% dplyr::mutate(source = \"raw mcmc\")   )  original_disc = comparison %>%   dplyr::filter(mean > 1) %>%   dplyr::group_by(source) %>%   dplyr::transmute(     coll = dplyr::row_number(),     disc = purrr::map2(mean,sd, ~ tibble::tibble(                          x=0:50,                          p = EpiEstim::discr_si(0:50, .x, .y))),     disc_type = \"discr_si\" ) %>% tidyr::unnest(disc)   tmp = original_disc %>% dplyr::mutate(source=factor(source, levels = c(\"raw mcmc\",\"epiestim\",\"corr log normal\")))  sources = length(levels(tmp$source))  tmp_summ = tmp %>% dplyr::group_by(source,x) %>% dplyr::summarise(p = mean(p)) ## `summarise()` has grouped output by 'source'. You can override using the ## `.groups` argument. tmp_mean = tmp %>% dplyr::group_by(source,coll) %>%    dplyr::summarise(mean = sum(x*p)) %>%    dplyr::summarise(sd = stats::sd(mean),mean = mean(mean), parameter=\"mean\", disc_type=\"epiestim\") %>%   dplyr::bind_rows(     gammas %>% dplyr::summarise(sd = stats::sd(mean),mean=mean(mean), parameter=\"mean\",source=\"raw\",disc_type=\"none\" )   ) ## `summarise()` has grouped output by 'source'. You can override using the ## `.groups` argument. ggplot2::ggplot(tmp)+   ggplot2::geom_segment(mapping=ggplot2::aes(x=x+as.numeric(source)/sources-1/sources,xend=x+as.numeric(source)/sources,y=p, colour=source), alpha=0.01)+   ggplot2::geom_segment(data = tmp_summ, mapping=ggplot2::aes(x=x+as.numeric(source)/sources-1/sources,xend=x+as.numeric(source)/sources,y=p), colour=\"black\")+   ggplot2::xlab(\"time\")+   ggplot2::coord_cartesian(xlim=c(0,max_x+1))+   ggplot2::guides(colour = ggplot2::guide_legend(override.aes = list(alpha = 1))) tmp_mean ## # A tibble: 4 × 5 ##   source             sd  mean parameter disc_type ##   <chr>           <dbl> <dbl> <chr>     <chr>     ## 1 raw mcmc        0.348  1.56 mean      epiestim  ## 2 epiestim        0.323  1.58 mean      epiestim  ## 3 corr log normal 0.348  1.54 mean      epiestim  ## 4 raw             0.368  1.53 mean      none r = c(0.4,0.2,0.1,0.05,0,-0.05,-0.1)  # select a shorter list of samples tmp2 = tmp %>% dplyr::group_by(source) %>% dplyr::reframe(   si_matrix = list(matrix(as.vector(p),nrow=51)[,1:250]),   r = list(r) ) %>% tidyr::unnest(r)  # tmp2$si_matrix[[1]][1:10,1:10]  cached_estimate_R = memoise::memoise(EpiEstim::estimate_R)  compare_R = tmp2 %>% dplyr::mutate(R = purrr::map2(si_matrix, r, ~ {   ts = tibble::tibble(         t = 0:50       ) %>% dplyr::mutate(         I = 100*exp(.y*t)       )   return(cached_estimate_R(ts,        method=\"si_from_sample\", si_sample = .x,       config = EpiEstim::make_config(t_start=2, t_end = 50))$R)   }) ) ## Warning: There were 21 warnings in `dplyr::mutate()`. ## The first warning was: ## ℹ In argument: `R = purrr::map2(...)`. ## Caused by warning: ## ! Unknown or uninitialised column: `dates`. ## ℹ Run `dplyr::last_dplyr_warnings()` to see the 20 remaining warnings. ggplot2::ggplot(compare_R %>% tidyr::unnest(R))+   ggplot2::geom_point(ggplot2::aes(x=as.factor(r), colour=source, y=`Median(R)`), position=ggplot2::position_dodge(width=0.8))+   ggplot2::geom_errorbar(ggplot2::aes(x=as.factor(r), colour=source, ymin=`Quantile.0.025(R)`, ymax=`Quantile.0.975(R)`), position=ggplot2::position_dodge(width=0.8), width=0.2)+   ggplot2::xlab(\"Growth rate (day⁻¹)\")+   ggplot2::ylab(\"Reproduction number\")+   ggplot2::geom_hline(yintercept=1)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/sampling-serial-interval.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Sampling the infectivity profile from published serial interval estimates","text":"assumption made EpiEstim uncertainty infectivity profile distributions, can specified mean, SD, upper lower limit truncated normal distributions turn define mean SD gamma distribution. gamma distribution discretised using PDF gamma distribution offset 1 day. requires lower bound mean 1 day. Changing assumptions instead specifying parameters gamma distribution pair correlated log normally distributed quantities gives qualitatively better fit original distribution. , however, affect reproduction number estimation, assumes knowledge correlation mean SD gamma distribution. find evidence benefit changing resampling procedure used EpiEstim, care must taken ensure resampling algorithm given correct parameters. Published serial interval estimates often given median 95% credible intervals distribution mean SD parameters EpiEstim expects. reproduction number estimation using EpiEstim subject constraint infectivity time zero zero. Coupled discretisation another potential source bias can investigated using different reproduction number framework.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/sampling-serial-interval.html","id":"addendum","dir":"Articles","previous_headings":"","what":"Addendum","title":"Sampling the infectivity profile from published serial interval estimates","text":"possible left truncation inherent EpiEstim discretisation RtR_t estimation hiding effect repeated analysis. time make infectivity profiles posterior samples resampled summarised parameters EpiEstim using correlated log-normal method described using different discretisation framework, estimate RtR_t using method require probability infection time 0 zero. result less - although possibly argue case EpiEstim re-sampling procedure resulted uncertainty higher growth rates, analysis using correlated log-normal resampling make huge improvement.","code":"comparison2 = dplyr::bind_rows(   do.call(make_posterior_ip, gammas %>% dplyr::select(shape,rate)) %>% dplyr::mutate(source=\"raw mcmc\"),   do.call(make_posterior_ip, simulated2 %>% dplyr::select(shape,rate)) %>% dplyr::mutate(source=\"corr log normal\"),   do.call(make_posterior_ip, epiestim_si_samples %>% dplyr::select(shape,rate)) %>% dplyr::mutate(source=\"epiestim\") ) %>% tidyr::nest(ip = -source)  tmp3 = tibble::tibble(r = r) %>%   dplyr::mutate(     data = purrr::map(r, ~ {       tibble::tibble(         time = 0:30,         count = stats::rpois(0:30, 100*exp(.x*0:30))       )}     )) %>%   dplyr::cross_join(comparison2) %>%   dplyr::mutate(fit = purrr::map2(data,ip, ~       .x %>%          poisson_locfit_model() %>%         rt_from_incidence(ip = .y)     )   )  tmp4 = tmp3 %>% dplyr::select(-ip) %>% tidyr::unnest(fit) %>% dplyr::filter(time>10) %>%    dplyr::group_by(source,r) %>%   dplyr::summarise(     rt.0.025 = mean(rt.0.025),     rt.0.5 = mean(rt.0.5),     rt.0.975 = mean(rt.0.975)   ) ## `summarise()` has grouped output by 'source'. You can override using the ## `.groups` argument. ggplot2::ggplot(tmp4)+   ggplot2::geom_point(ggplot2::aes(x=as.factor(r), colour=source, y=rt.0.5), position=ggplot2::position_dodge(width=0.8))+   ggplot2::geom_errorbar(ggplot2::aes(x=as.factor(r), colour=source, ymin=rt.0.025, ymax=rt.0.975), position=ggplot2::position_dodge(width=0.8), width=0.2)+   ggplot2::xlab(\"Growth rate (day⁻¹)\")+   ggplot2::ylab(\"Reproduction number\")+   ggplot2::geom_hline(yintercept=1)"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Simulations and test harnesses","text":"Testing inference RtR_t growth rate estimates needs ground truth, missing real outbreaks infection events truly observed. Testing accuracy estimates RtR_t example needs one simulations outbreaks known parametrisation. ggoutbreak contains functions generate synthetic datasets exhibit complexities observed COVID-19 pandemic. two levels simulations work, aggregate counts case line list simulations. ggoutbreak includes set simulations can used generate test data known parameters. can used validate output model parameter estimates, calculated simulated data gold standard values parameters. Simulations aggregate level generating count data, individual level generating line lists. parameters implemented far follows: Importation rate Reproduction number Growth rate Infectivity profile (generation time time delay infectee infection time infector infection) Case ascertainment rate Probability symptoms given infection Time delay symptom onset time infection Probability hospital admission given infection Time delay hospital admission time infection Probability death given infection Time delay death time infection Probability testing given infection (given symptoms) Time delay test sampling time infection (symptoms) Time delay test result time test sampling Depending model may specified different ways. Different delays rates observation can added ad-hoc simulations can stratified different classes. simulations can propagated using equivalent contact matrix.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"specifying-time-varying-parameters","dir":"Articles","previous_headings":"","what":"Specifying time varying parameters","title":"Simulations and test harnesses","text":"simulation framework highly configurable, key part specifying parameters vary time, random non random day day variation. simulation parameters must given time varying function, parameters often available. ggoutbreak includes various ways generating functions, simulation configuration options expect function identified fn_... prefix, example fn_p_symptomatic. Functions evaluated context simulation data frame, built. always time count column, may columns . evaluation happens internally use .ts_evaluate function demonstrate results. static value can supplied purrr style lambda. time varying function can supplied purrr style lambda first parameter time column demo dataframe alternative syntax uses anonymous function named parameters. time column always shortened t. format can used key variables allow time varying, class specific parameter returned don’t know columns available providing empty otherwise incorrect function results valid parameter names displayed error message:","code":"demo = tibble::tibble(   time = 0:9,   class = rep(c(\"one\",\"two\"),5),   flag = c(rep(TRUE,5),rep(FALSE,5)) ) .ts_evaluate( ~ 0.5, demo ) #> [1] 0.5 .ts_evaluate( ~ ifelse(.x < 5, 2, 0.5), demo ) #>  [1] 2.0 2.0 2.0 2.0 2.0 0.5 0.5 0.5 0.5 0.5 .ts_evaluate( \\(t, class) dplyr::case_when(   class == \"one\" ~ \"variant 1 R_t value\",   class == \"two\" ~ \"variant 2 R_t value\" ), demo ) #>  [1] \"variant 1 R_t value\" \"variant 2 R_t value\" \"variant 1 R_t value\" #>  [4] \"variant 2 R_t value\" \"variant 1 R_t value\" \"variant 2 R_t value\" #>  [7] \"variant 1 R_t value\" \"variant 2 R_t value\" \"variant 1 R_t value\" #> [10] \"variant 2 R_t value\" try(.ts_evaluate( \\() {} , demo )) #> Error : Function must define at least one parameter, available values are: t, class, flag"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"step-and-linear-functions","dir":"Articles","previous_headings":"Specifying time varying parameters","what":"Step and linear functions","title":"Simulations and test harnesses","text":"common need set number fixed levels, fixed knots function interpolate . step function might used parametrise RtR_t event lock-example. make simple simulation functions take changes dataframe defines time point new value , either reproduction number growth rate time point. can used parametrisation reproduction number.  cfg_linear_fn produces similar effect less abrupt changes RtR_t changes occurring value knot correct.","code":"changes = tibble::tibble(   t = c(0,20,40,60,80),    growth = c(0.1,0,-0.1,0,0.1) )  fn = cfg_step_fn(changes) ggplot2::ggplot()+ggplot2::geom_function(fun = fn, xlim = c(0,100))+ggplot2::ylab(\"growth rate\") changes = tibble::tibble(   t = c(0,10,20,30,40,50,60,70,80),    R = c(1,1.5,1.75,1.25,0.9,0.7,0.8,0.95,1) )  fn = cfg_linear_fn(changes) ggplot2::ggplot()+   ggplot2::geom_function(fun = fn, xlim = c(0,100))+ggplot2::ylab(\"reproduction number\")+   ggplot2::geom_hline(yintercept=1,linetype=\"dashed\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"random-functions","dir":"Articles","previous_headings":"Specifying time varying parameters","what":"Random functions","title":"Simulations and test harnesses","text":"applications (e.g. ascertainment, importation) might useful value includes random noise, expected value average. easiest purrr style lambda. convenience ggoutbreak includes RNGs parametrised mean dispersion parameter. functions can combined logic make time dependent random number, case first 5 random gammas drawn distribution mean 1 SD 1 last 5 mean 6 SD 1: Although time dependence likely scenario, simulation component can used control gamma beta distributed quantities. allows configuring variant specific hospitalisation rates, delays example.","code":"# A random normally distributed value with mean 5 and SD 1 # `.x` here will be interpreted as time as the first parameter, and in this # case is only used to size the returned random gaussian. .ts_evaluate(~ stats::rnorm(.x,5,1), demo) #>  [1] 3.599956 5.255317 2.562736 4.994429 5.621553 6.148412 3.178182 4.752675 #>  [9] 4.755800 4.717295 # A random Bernoulli parametrised by probability. .ts_evaluate(~ rbern(.x, p = 0.5), demo) #>  [1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  # A beta distributed quantity parametrised by probability and dispersion (1-high to 0-none) .ts_evaluate(~ rbeta2(.x, prob = 0.7, kappa = 0.1), demo) #>  [1] 0.7506903 0.7129819 0.7013073 0.6861331 0.7230630 0.6881060 0.6908378 #>  [8] 0.7337567 0.7024199 0.7236393  # A log normal parametrised by mean and SD on the true scale .ts_evaluate(~ rlnorm2(.x, mean = 5, sd =1), demo) #>  [1] 4.887440 4.162386 3.633908 5.900688 5.077301 5.145320 6.762271 5.012906 #>  [9] 4.774506 3.358685  # A gamma parametrised by mean and SD on the true scale .ts_evaluate(~ rgamma2(.x, mean = 5, sd =1), demo) #>  [1] 4.627468 5.050369 4.614360 4.287724 6.389703 4.144172 8.007341 4.946172 #>  [9] 5.488590 5.017705 # A random number from a gamma distribution parametrised by mean and SD on the true scale # where the mean is a time varying value. Again here `.x` is the time and it is # being used to define the number of returned value sand the mean of these values .ts_evaluate(~ rgamma2(.x, mean = ifelse(.x < 5,1,6), sd =1), demo) #>  [1] 0.9002344 0.1013501 0.5136526 0.5211211 0.9643644 3.8738828 5.9171433 #>  [8] 6.6902884 6.2615691 6.0851481 hospitalisation_prob_fn = cfg_beta_prob_rng(   probability_fn = \\(variant) ifelse(variant==\"alpha\", 0.2, 0.02),   kappa_fn = ~ 0.1 )   demo = tibble::tibble(   t = 1:200,   variant = c(rep(\"wildtype\",100),rep(\"alpha\", 100)) ) %>% dplyr::mutate(   value = .ts_evaluate(hospitalisation_prob_fn, .) )  ggplot2::ggplot(demo, ggplot2::aes(x=variant,y=value))+ggplot2::geom_point(position = \"jitter\")+   ggplot2::ylab(\"probability hospitalisation\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"delay-distributions-and-delay-rngs","dir":"Articles","previous_headings":"Specifying time varying parameters","what":"Delay distributions and delay RNGs","title":"Simulations and test harnesses","text":"key parameter generation interval infectivity profile defines delay infection infector infectee transmission chain. delays infection symptoms, infection admission also need parametrised. done using empirical probability distribution described vignette (referred ‘IP distributions’). general IP distributions either used convolution summary count data, simulate effect delay aggregate measure, random sampling generate delay individual line list. couple ways constructing simulation:  IP distributions used directly convolution aggregate simulations. line list simulations want random sample apply individuals. gamma based IP distributions rgamma rgamma2 functions used directly. empirical distributions can generate random numbers  IP delay distributions may change time, change result characteristics simulation. difficult demo outside simulation, give examples later. principle though time varying function selecting one 2 IP delays might look like :  time varying delays individual based models things little simpler. create RNG mean every individual simulation.  approaches can applied delay distribution, time infection time hospitalisation, can made vary variables simulation variant class potentially patient age.","code":"gamma_ip = make_gamma_ip(median_of_mean = 5, median_of_sd = 1) emp_ip = make_empirical_ip(omega = c(0,0,0,1,1,2,3,3,2,1,0,0))  p1=gamma_ip %>% plot_ip() + ggplot2::facet_wrap(~\"gamma\") p2=emp_ip %>% plot_ip() + ggplot2::facet_wrap(~\"empirical\") p1+p2+patchwork::plot_layout(nrow=1)#,axes = \"collect\") emp_sample_fn = cfg_ip_sampler_rng(emp_ip)  tmp = tibble::tibble(   serial_interval = emp_sample_fn(2000) )  p3 = p2 %above% ggplot2::geom_histogram(data=tmp,mapping=ggplot2::aes(x=serial_interval, y=ggplot2::after_stat(density)),       breaks = c(0,seq(0.5,12)),fill=\"grey80\",colour=\"grey40\") p3 # We start by defining a time varying function for the mean of a gamma delay_mean_fn = cfg_linear_fn(tibble::tribble(   ~t , ~delay,   0, 3, # 3 day delays initially,   4, 3, # Until day 4. Between day 4 and 10 delays improving   10, 1 # by day 10 delays steady at 1 day ))  # We wrap this in a a function to calculate a IP for each time point delay_fn = function(t) purrr::map( delay_mean_fn(t), function(mean) {   make_gamma_ip(median_of_mean = mean, median_of_sd = sqrt(mean)) })  # Within the simulation this delay function will be evaluated for each day # here we do it manually  times = 0:14 delay_t = delay_fn(t=times)  # this is a list of IP distributions. tibble::tibble(ip = delay_t, t=times) %>% tidyr::unnest(ip) %>% dplyr::glimpse() %>%   ggplot2::ggplot()+   ggplot2::geom_rect(ggplot2::aes(xmin=t,xmax=t+1,ymin=a0,ymax=a1,fill = probability))+   ggplot2::xlab(\"time\")+ggplot2::ylab(\"delay\") #> Rows: 158 #> Columns: 6 #> $ tau         <int> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5… #> $ a0          <dbl> 0.0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.… #> $ a1          <dbl> 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11… #> $ probability <dbl> 0.0143876780, 0.1767654915, 0.2650337147, 0.2229659170, 0.… #> $ boot        <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… #> $ t           <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1… delay_mean_fn = cfg_linear_fn(tibble::tribble(   ~t , ~delay,   0, 3, # 3 day delays initially,   4, 3, # Until day 4. Between day 4 and 10 delays improving   10, 1 # by day 10 delays steady at 1 day ))  delay_rng = function(t) { rgamma2(t, delay_mean_fn(t)) }  times = rep(0:14,1000) delay = delay_rng(t=times)  tibble::tibble(delay = delay, t=times) %>%   ggplot2::ggplot()+ggplot2::geom_boxplot(ggplot2::aes(x=as.factor(t),y=delay),outliers = FALSE)+   ggplot2::xlab(\"time\")+ggplot2::ylab(\"delay\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"periodic-functions","dir":"Articles","previous_headings":"Specifying time varying parameters","what":"Periodic functions","title":"Simulations and test harnesses","text":"periodic function obviously useful generate seasonal forcing:  important uses periodic functions simulate patterns within week variation. often seen testing data result delays tested, test processing weekend. model two variants weekly periodicity use gamma distribution delay. One can used represent delay distribution convolution count based simulations another random sampling individual based simulations. demonstrate simulation later.","code":"# A simple to interpret and easy to make integrate to 0, so that growth remains # bounded.  growth_rate_fn = \\(t) dplyr::case_when(   t %% 365 < 40 ~ 0.1,   t %% 365 < 80 ~ -0.1,   TRUE ~ 0) ggplot2::ggplot()+ggplot2::geom_function(fun = growth_rate_fn, xlim = c(0,365*2))+ggplot2::ylab(\"growth rate\") gamma_means = c(1,1,1,1,4,3,2) delay_fn = cfg_weekly_ip_fn(mean=gamma_means)  # delay_fn can be used as the parameter for a delay distribution convolution  # format_ip takes a probability based delay distribution and gives us a summary # the mean, sd, etc. .ts_evaluate(delay_fn, tibble::tibble(t=1:7)) %>%    purrr::map_chr(format_ip) #> [1] \"mean: 1.06; sd: 1.01\" \"mean: 1.06; sd: 1.01\" \"mean: 1.06; sd: 1.01\" #> [4] \"mean: 1.06; sd: 1.01\" \"mean: 4; sd: 2.04\"    \"mean: 3; sd: 1.77\"    #> [7] \"mean: 2.02; sd: 1.44\" # for line list functions a RNG with weekly periodicity generates samples  # of the interval that is consistent with the parameters passed to  # `cfg_weekly_gamma_rng` delay_rng = cfg_weekly_gamma_rng(mean=gamma_means)  tibble::tibble(t=rep(1:7,100)) %>%   dplyr::mutate(sample = .ts_evaluate(delay_rng, .)) %>%   dplyr::group_by(t) %>%   dplyr::summarise(     mean = mean(sample),     sd = stats::sd(sample)   ) %>%   dplyr::mutate(     expected_mean = gamma_means,     expected_sd = sqrt(gamma_means)   ) #> # A tibble: 7 × 5 #>       t  mean    sd expected_mean expected_sd #>   <int> <dbl> <dbl>         <dbl>       <dbl> #> 1     1 1.07  1.01              1        1    #> 2     2 0.973 0.926             1        1    #> 3     3 0.845 0.767             1        1    #> 4     4 0.842 0.823             1        1    #> 5     5 4.02  1.81              4        2    #> 6     6 3.13  1.87              3        1.73 #> 7     7 2.07  1.43              2        1.41"},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"count-based-simulations","dir":"Articles","previous_headings":"Simulation cookbook","what":"Count based simulations","title":"Simulations and test harnesses","text":"Count based models typically based around poisson process expected number cases per day expressed function imports growth, either terms exponential growth rate, combination reproduction number infectivity profile (generation time).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"basic-growth-rate-possion-model-with-ascertainment-noise-","dir":"Articles","previous_headings":"Simulation cookbook > Count based simulations","what":"Basic growth rate possion model with ascertainment noise.","title":"Simulations and test harnesses","text":"Daily count simulations based around defined incidence rates, can expressed terms time dependent growth rate time dependent importation rate. incidence time series can generated using poisson negative binomial distribution. can also define simulation terms time dependent reproduction number, time dependent infectivity profile, time dependent importation rate.  produces summary statistics . growth rate infectivity profile, can use methods Wallinga Lipsitch infer theoretical value RtR_t, giving us ground truth validate RtR_t estimates.  Simulated noise can introduced scaling incidence rate random ascertainment rate, can vary time. randomness factor (kappa - measure dispersion) calibrated range 0 (none) 1 (maximum).  example select time varying delay distribution, reflecting test processing delays, due setting testing public holiday. can applied time-varying convolution filter summary case count simulations simulate effect changing delay distributions aggregate case counts. example dynamic delays test processing can result slow catch anomalies.","code":"withr::with_options(list('day_zero'=Sys.Date()),{    # define a growth rate time series   changes = tibble::tibble(     t = c(0,15,40,60,80),      growth = c(0.1,0.01,-0.075,0,0.05)   )      sim = sim_poisson_model(     changes = changes,     max_time = 120,     time_unit = \"1 day\"   )      p1 = plot_changes(sim, \"parametrised growth rate\", date_breaks = \"2 weeks\")    p2 = ggoutbreak::plot_counts(sim, events = attr(sim,\"events\"), date_breaks = \"2 weeks\")   p1+p2+patchwork::plot_annotation(tag_levels = \"A\")+plot_layout(ncol=1,axes = \"collect\")  }) # COVID-19 generation time estimates from Ganyani et al 2020. ip = make_gamma_ip(5.2, 3.78, 6.78, 1.72, 0.91, 3.93, epiestim_sampler=FALSE, epiestim_compat=FALSE)  fn_Rt = changes %>%    dplyr::transmute(     t,     R_t = wallinga_lipsitch(growth, y = ip$probability, a0 = ip$a0, a1 = ip$a1)) %>%   cfg_step_fn()  plot_changes(sim, \"parametrised reproduction number\", fn=fn_Rt, date_breaks = \"2 weeks\") sim2 = dplyr::bind_rows(lapply(c(0,0.25,0.5,1), function(k)      sim %>%      sim_apply_ascertainment(       fn_asc = ~ rbeta2(.x, prob = 0.7, kappa = k)     ) %>%     dplyr::mutate(ascertainment_noise = k)    )) %>%   dplyr::group_by(ascertainment_noise)  ggoutbreak::plot_counts(sim2, events = attr(sim,\"events\"), date_breaks = \"2 weeks\")+   ggplot2::facet_wrap(~sprintf(\"randomness: %1.2f\",ascertainment_noise),ncol=2) # Noise introduced by random day to day ascertainment variation: ip_mean_fn = cfg_linear_fn(tibble::tribble(   ~t , ~delay,   0, 3, # 3 day avg delays initially   10, 1, # by day 10 delays decreased to 1   25, 1, # remain steady until day 25   26, 3, # public holiday on day 26    27, 3, # and day 27   28, 1 # returning to normal on day 28 ))  p_detection_fn = cfg_linear_fn(tibble::tribble(   ~t , ~p,   0, 0.1, # initial low probability of detection   10, 0.7,   90, 0.7,   120,0.3 ))  delay_detection_fn = ~ make_gamma_ip(median_of_mean = ip_mean_fn(.x))  sim3 = sim %>% sim_convolution(   p_fn = p_detection_fn,   delay_fn = delay_detection_fn,   output = \"detected\" ) %>% sim_delayed_observation(   input = \"detected\",   delay_fn = ~ make_gamma_ip(7,median_of_sd = 10) )  p1=plot_changes(sim3,name = \"delays (days)\", fn = ip_mean_fn)+ggplot2::ylim(0,NA) p2=plot_changes(sim3,name = \"detection\", fn = p_detection_fn)+ggplot2::ylim(0,1) p3=plot_counts(sim3,events = attr(sim3,\"events\"),mapping=ggplot2::aes(colour=statistic))+ggplot2::geom_line()  p1+p2+p3+patchwork::plot_layout(ncol=1,heights=c(1,1,2),axes = \"collect\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"seasonal-outbreak-using-a-reproduction-number","dir":"Articles","previous_headings":"Simulation cookbook > Count based simulations","what":"Seasonal outbreak using a reproduction number","title":"Simulations and test harnesses","text":"can simulate seasonal outbreak providing periodic growth rate RtR_t parameter simple poisson model. example also simulated default set delays keying infection event, generate delayed set symptom observations, test samples, results, hospitalisations death time series.","code":"seasonal_rt_fn = \\(t) dplyr::case_when(   t %% 365 < 20 ~ 2.5,   t %% 365 < 60 ~ 0.6,   TRUE ~ 1 )  seasonal_imports = \\(t) ifelse(   t %% 365 < 5, 5, 0  )   seasonal_sim = sim_poisson_Rt_model(     max_time = 365*3,     fn_Rt = seasonal_rt_fn,     fn_imports = seasonal_imports,     fn_ip = ~ make_gamma_ip(6)   )  #profvis::profvis( system.time({   seasonal_sim = seasonal_sim %>% sim_apply_delay() }) #>    user  system elapsed  #>  16.332   0.000  16.334 #)  p1=plot_changes(         seasonal_sim,          name = \"Rt\",          fn = seasonal_rt_fn,          max_y = 3)  p2=plot_counts(         seasonal_sim,          events = attr(seasonal_sim,\"events\"),         mapping=ggplot2::aes(colour=statistic),size=0.25)+       ggplot2::geom_line()+       ggplot2::facet_wrap(~ statistic,ncol=1,scales = \"free_y\")  p1+p2+patchwork::plot_layout(ncol=1,axes = \"collect\",heights=c(1,10))"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"line-list-simulations","dir":"Articles","previous_headings":"","what":"Line list simulations","title":"Simulations and test harnesses","text":"want investigate estimates delays serial interval, rates case fatality rate, necessary simulate individuals interaction. use branching process model parametrised directly RtR_t. time varying RtR_t defines expected number onward infections individual sampled using poisson negative binomial distribution. infectee given time infection depending specified infectivity profile, times events symptom onset, hospitalisation, death, test sampling, test results can assigned, following known event probabilities delay distributions. Summary counts events indexed time event, demonstrate well known biases, right truncation. simulation directly parametrised theoretical RtR_t value; summary network edges gives us realised case reproduction number specific individual simulation, force infection gives us instantaneous reproduction number estimate individual simulation. parametrised infectivity profile can use methods Wallinga Lipsitch solve theoretical growth rate.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"basic-outbreak-with-delays-and-censoring","dir":"Articles","previous_headings":"Line list simulations","what":"Basic outbreak with delays and censoring","title":"Simulations and test harnesses","text":"minimal outbreak simulation using branching process model takes time varying function reproduction number time varying function number imported cases. generates set infection events specified time period (staring day 0).  set infections can add observations, based probability observation delay observation. time varying functions, can example vary result day week. example add “sequencing” column set describes sample taken genomic sequencing. sampling delayed slightly infections arising weekend. additional date can summarise time points daily counts infections, case “sequencing” samples, shows periodicity result extended delay weekend. However common also sort delay reporting results test. case added longish delay getting results back. aggregating sample date therefore right censoring effect positive sample counts.","code":"# A simple outbreak linelist = sim_branching_process(    fn_Rt = ~ ifelse(.x < 40, 1.5, 0.95),    max_time = 120,    seed = 100,    fn_imports = ~ ifelse(.x<10,8,0) )  plot_cases(linelist, events = attr(linelist,\"events\"))+ggplot2::coord_cartesian() linelist2 = linelist %>% sim_delay(   p_fn = ~ 0.6,    delay_fn = cfg_weekly_gamma_rng(c(3,3,3,3,3,3.5,3.5), sd=1),   output = \"sequencing\" )  # The delay function results in additional columns prefixed by \"sequencing\" # of reach individual. linelist2 %>% dplyr::glimpse() #> Rows: 19,097 #> Columns: 8 #> $ time                <time_prd> 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, … #> $ id                  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,… #> $ generation_interval <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ infector            <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ generation          <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ sequencing          <lgl> TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALS… #> $ sequencing_delay    <dbl> 2.850568, NA, NA, NA, NA, 2.270486, 3.736456, NA, … #> $ sequencing_time     <time_prd> 2.850568, NA, NA, NA, NA, 2.270486, 3.736456,… summary = linelist2 %>% sim_summarise_linelist(     censoring = list(       \"sequencing\" = ~ rgamma2(.x, mean = 14)     )   )  # plot the counts for comparison. p1=plot_changes(summary,\"Rt\",max_y = 2.0, case = TRUE) p2=plot_counts(summary,events = attr(summary,\"events\"), mapping=ggplot2::aes(colour=statistic),size=0.5)+ggplot2::geom_line() patchwork::wrap_plots(p1,p2,ncol=1,axes=\"collect\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"variant-introduction-alpha-example","dir":"Articles","previous_headings":"Line list simulations","what":"Variant introduction: Alpha example","title":"Simulations and test harnesses","text":"infectivity profile changing dynamically simulation alters relationship reproduction number growth rate. line list models infectivity profile potentially vary individual individual depending variant infected , can cause rapid growth variant. hard differentiate higher reproduction number shorter generation time, especially short term. However decreased generation time lead steeper flatter curve compared increased RtR_t, tend take gradually, trajectory original variant, curve away quickly higher exponential rate kicks .","code":"variant_imports_df = tibble::tribble(   ~time, ~variant, ~count,   0:4, \"wild-type\", 5,   20:24, \"alpha\", 5 )  # The fist scenario is a two variant outbreak with one variant with a shorter # generation time.  variant_ip_fn = cfg_gamma_ip_fn(     mean_fn = \\(variant) dplyr::case_when(       # Two infectivity profiles one for each variant.       variant==\"wild-type\" ~ 8,       variant==\"alpha\" ~ 5) # variant 2 has a shorter generation time )   scenario1 = sim_branching_process(   max_time = 120,   fn_Rt = ~ 1.15, # Both variants have the same fixed R_t   fn_ip = variant_ip_fn,   imports_df = variant_imports_df,   seed=101 )   # The second scenario involves two variants one with a slight reproduction  # number advantage. Both have the same (longer) generation time  variant_Rt_fn = \\(t,variant) dplyr::case_when(   variant==\"wild-type\" ~ 1.15,   variant==\"alpha\" ~ 1.3 )  scenario2 = sim_branching_process(   max_time = 120,   fn_Rt = variant_Rt_fn,    fn_ip = ~ make_gamma_ip(8), # Both variants have the same fixed ip with mean 8   imports_df = variant_imports_df,   seed=100 )  comparison = dplyr::bind_rows(   scenario1 %>% sim_summarise_linelist(variant) %>% dplyr::mutate(scenario = \"1 - Shorter GT\"),   scenario2 %>% sim_summarise_linelist(variant) %>% dplyr::mutate(scenario = \"2 - Rt advantage\") )  p1=plot_changes(comparison,\"Rt\", max_y = 2.5,mapping = ggplot2::aes(colour=variant))+ggplot2::facet_wrap(~scenario) p2=plot_counts(comparison %>% dplyr::group_by(scenario,variant), mapping = ggplot2::aes(colour=variant))+ggplot2::facet_wrap(~scenario)  patchwork::wrap_plots(p1,p2,ncol=1,axes=\"collect\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"two-variants-delta-outbreak","dir":"Articles","previous_headings":"Line list simulations","what":"Two variants: Delta outbreak","title":"Simulations and test harnesses","text":"pandemic Delta started spreading whilst Alpha declining. due generation time, change overall direction epidemic . must associated transmissible nature.","code":"variant_imports_df = tibble::tribble(   ~time, ~variant, ~count,   -20:-1, \"alpha\", 300,   15:19, \"delta\", 5 )  variant_Rt_fn = \\(t,variant) dplyr::case_when(   t < 0 ~ 0,   variant==\"alpha\" ~ 0.8,   variant==\"delta\" ~ 1.3 )  scenario = sim_branching_process(   max_time = 120,   fn_Rt = variant_Rt_fn,    fn_ip = ~ make_gamma_ip(8), # Both variants have the same fixed ip with mean 8   imports_df = variant_imports_df,   seed=100 )  summary1 =  scenario %>% sim_summarise_linelist(variant) %>% dplyr::filter(time >= 0)  summary2 =  scenario %>% sim_summarise_linelist() %>% dplyr::filter(time >= 0)  p1=plot_counts(summary1, mapping=ggplot2::aes(colour=variant)) p2=plot_counts(summary2)  p3=ggplot2::ggplot(summary1, ggplot2::aes(x=as.Date(time), colour=variant))+     ggplot2::geom_point(ggplot2::aes(y=rt.inst))+     ggplot2::geom_line(ggplot2::aes(y=rt.weighted))+     ggplot2::coord_cartesian(ylim=c(0,3.5))+     ggplot2::xlab(NULL)  p4=ggplot2::ggplot(summary2, ggplot2::aes(x=as.Date(time)))+     ggplot2::geom_point(ggplot2::aes(y=rt.inst))+     ggplot2::geom_line(ggplot2::aes(y=rt.weighted))+     ggplot2::coord_cartesian(ylim=c(0,3.5))+     ggplot2::xlab(NULL)  patchwork::wrap_plots(p1,p2,p3,p4,ncol=2,axes=\"collect\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"over-dispersion","dir":"Articles","previous_headings":"Line list simulations","what":"Over-dispersion","title":"Simulations and test harnesses","text":"branching process model, infected individual daily probability infecting someone based current reproduction number infectivity profile. sampled using either poisson negative binomial distribution depending dispersion parameter (kappa==1 poisson distributed, anything larger negative binomial). can made time dependent, can simulate changes response , example, shutting social venues. -dispersed outbreaks higher chance becoming extinct early stage reproduction number, realistic. likely scenario subset population high super-spreading potential.","code":"kappa = c(1,1.5,2,3,4)  comparison = dplyr::bind_rows(lapply(kappa, function(k) {      sim_branching_process(     max_time = 80,     fn_Rt = ~ 2, # Both variants have the same fixed R_t     fn_ip = ~ make_gamma_ip(8),     fn_import = ~ ifelse(.x<10,4,0),     fn_kappa = ~ k,     seed=101   ) %>%      sim_summarise_linelist() %>%     dplyr::mutate(scenario = sprintf(\"Dispersion: %1.2f\",k))    }))  plot_counts(comparison %>% dplyr::group_by(class=scenario))+scale_y_log1p()"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"age-stratification-contact-matrices","dir":"Articles","previous_headings":"Line list simulations","what":"Age stratification & contact matrices","title":"Simulations and test harnesses","text":"can specify metadata branching process model. example variant, transmitted infectee. can define probabilistic mapping metadata classes can simulate stratified populations age. define function reacts metadata assigns infectee class. also need define initial metadata imported cases.","code":"# This simulation is seeded in the younger age groups: strat_imports_df = tibble::tribble(   ~time, ~age_cat, ~count,   0:4, \"child\", 5,   0:4, \"adolescent\", 5 ) %>% dplyr::mutate(age_cat = factor(age_cat,levels = c(\"child\",\"adolescent\",\"adult\",\"elderly\")))  # The next generation function in this form is similar to a  # next generation matrix however it does not include R_t components:  strat_fn_list_next_gen = list(   \"age_cat\" = ~ dplyr::case_when(     .x == \"child\" ~ rcategorical(.x, prob = c(\"child\"=0.4,\"adolescent\"=0.2,\"adult\"=0.4,\"elderly\"=0)),     .x == \"adolescent\" ~ rcategorical(.x, prob = c(\"child\"=0.2,\"adolescent\"=0.4,\"adult\"=0.3,\"elderly\"=0.1)),     .x == \"adult\" ~ rcategorical(.x, prob = c(\"child\"=0.1,\"adolescent\"=0.1,\"adult\"=0.4,\"elderly\"=0.4)),     .x == \"elderly\" ~ rcategorical(.x, prob = c(\"child\"=0,\"adolescent\"=0.2,\"adult\"=0.3,\"elderly\"=0.5)),   ) )  strat_fn_Rt = \\(age_cat) dplyr::case_when(   age_cat == \"child\" ~ 1.2,   age_cat == \"adolescent\" ~ 1.2,   age_cat == \"adult\" ~ 1.2,   age_cat == \"elderly\" ~ 2, )  strat_bpm = sim_branching_process(     max_time = 80,     fn_Rt = strat_fn_Rt,     fn_ip = ~ make_gamma_ip(8),     imports_df = strat_imports_df,     fn_list_next_gen = strat_fn_list_next_gen,     seed=101   ) %>% dplyr::mutate(age_cat = factor(age_cat,levels = c(\"child\",\"adolescent\",\"adult\",\"elderly\")))  plot_cases(strat_bpm,mapping = ggplot2::aes(fill=age_cat),individual=TRUE)+ggplot2::coord_cartesian()"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/simulation-test-models.html","id":"future-steps","dir":"Articles","previous_headings":"","what":"Future steps","title":"Simulations and test harnesses","text":"","code":"#TODO: defaults in function that line up with sim_apply_delay_convolution #' # move this to vignette examples #' tmp2 = tmp %>% sim_apply_delay( #'   fn_p_symptomatic = ~ 0.8, #'   fn_symptom_delay = ~ stats::rgamma(.x, shape = 3), #'   fn_p_tested = \\(symptomatic,...) ifelse(symptomatic, 0.8, 0.1), #'   fn_sample_delay = ~ stats::rgamma(.x, shape = 2), #'   fn_result_delay = \\(sample_time,...) dplyr::case_when( #'       floor(sample_time) %% 7 %in% c(0,1,2,3,4) ~ stats::rgamma(sample_time, shape=2), # Sun, Mon to Thurs #'       floor(sample_time) %% 7 == 5 ~ stats::rgamma(sample_time, shape=4), # Fri #'       floor(sample_time) %% 7 == 6 ~ stats::rgamma(sample_time, shape=3), # Sat #'   ) #' ) #'  #'  #'  #' # Delay distribution example: #' tmp3 = sim_branching_process( #'   changes = tibble::tibble(t = c(0,20,40,60,80,110), R_t = c(1.8,1.5,0.9,1.5,0.8,1.2)), #'   kappa = 1, #'   max_time = 120, #'   seed = 100, #'   summarise = FALSE #'  ) %>% sim_apply_delay( #'   fn_p_symptomatic = ~ 0.8, #'   fn_symptom_delay = ~ stats::rgamma(.x, shape = 3), #'   fn_p_symptomatic = ~ 0.8, #'   fn_symptom_delay = ~ stats::rgamma(.x, shape = 3), #'   fn_p_tested = \\(symptomatic,...) ifelse(symptomatic, 0.8, 0.1), #'   fn_sample_delay = \\(symptomatic, symptom_time, ...) dplyr::case_when( #'       !symptomatic ~ stats::runif(symptomatic, max = 14), #'       TRUE ~ cfg_weekly_gamma_rng(c(1,1,1,1,3,2,2))(symptom_time) #'   ), #'   fn_result_delay = \\(sample_time,...) cfg_weekly_gamma_rng(c(1,1,1,1,3,2,2))(sample_time) #'  ) #' #' tmp4 = tmp3 %>% sim_summarise_linelist() #' #' ggplot2::ggplot(tmp4 %>% dplyr::filter(!is.na(count)), ggplot2::aes(x=time, colour=statistic))+ #'   ggplot2::geom_line(ggplot2::aes(y=count))+ #'   ggplot2::facet_wrap(~statistic,ncol=1) #' } #' #' #' tmp2 = sim_branching_process( #'   changes = tibble::tibble(t = c(0,20,40,60,80,110), R = c(1.8,1.5,0.9,1.5,0.8,1.2)), #'   kappa = 1, #'   max_time = 120, #'   seed = 100 #' ) %>% sim_summarise_linelist() #' #' ggplot2::ggplot(tmp2, ggplot2::aes(x=time))+ #'   ggplot2::geom_point(ggplot2::aes(y=count))+ #'   ggplot2::geom_line(ggplot2::aes(y=original)) #' # ggplot2::ggplot(tmp2, ggplot2::aes(x=time))+ #    ggplot2::geom_step(ggplot2::aes(y=rt.weighted), colour=\"black\")+ #    ggplot2::geom_point(ggplot2::aes(y=rt.inst, colour=\"Instantaneous\"))+ #    ggplot2::geom_point(ggplot2::aes(y=rt.case, colour=\"Case\"))+ #    ggplot2::coord_cartesian(ylim=c(0,3))"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-periods.html","id":"line-lists-vs--time-series","dir":"Articles","previous_headings":"","what":"Line lists vs. time series","title":"Data wrangling and working with `ggoutbreak`","text":"Infectious disease data usually either comes set observations individual infection time stamp (.e. line list) count events (e.g. positive tests, hospitalisations, deaths) happening within specific period (day, week, month etc.) time series. count data may also denominator known. testing number tests performed, number patients risk hospitalisation. data types may also class associated observation, defining subgroup infections interest. variant virus, age group, example. may make sense compare different subgroups . case denominator may total counts among groups per unit time. Additionally may information size population subgroup. ggoutbreak assumes part input data form set time series counts, unique set times, usually complete. create datasets like line lists ggoutbreak provides infrastructure dealing time series:","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-periods.html","id":"time-periods","dir":"Articles","previous_headings":"","what":"Time periods","title":"Data wrangling and working with `ggoutbreak`","text":"weekly case rate represents time slice seven days start finish date. Dates continuous quantity, cut_dates() can used classify continuous dates periods equal duration, start date: Performing calculations using interval censored dates awkward. numeric version dates useful can keep track start date time series intrinsic duration, numeric. purpose time_period class: time_period defaults using date beginning COVID-19 pandemic origin calculating duration unit based data (case weekly). usual set S3 methods available formatting, printing, labelling, casting time_periods dates POSIXct classes: weekly time series can recast different frequency, start date: original dates recoverable: date_seq() can used make sure set periodic times complete: time_periods can also used monthly yearly data data regular. approximately handles irregular date periods generally OK use ggoutbreak. functions like date_seq may work anticipated irregular dates, conversions weeks months example potentially risky. Two time series can aligned make comparable:","code":"random_dates = Sys.Date()+sample.int(21,50,replace = TRUE) cut_date( random_dates, unit = \"1 week\", anchor = \"start\", dfmt = \"%d %b\") #> 01 Aug — 07 Aug 01 Aug — 07 Aug 25 Jul — 31 Jul 25 Jul — 31 Jul 08 Aug — 14 Aug  #>    \"2025-08-01\"    \"2025-08-01\"    \"2025-07-25\"    \"2025-07-25\"    \"2025-08-08\"  #> 08 Aug — 14 Aug 25 Jul — 31 Jul 25 Jul — 31 Jul 01 Aug — 07 Aug 25 Jul — 31 Jul  #>    \"2025-08-08\"    \"2025-07-25\"    \"2025-07-25\"    \"2025-08-01\"    \"2025-07-25\"  #> 25 Jul — 31 Jul 08 Aug — 14 Aug 01 Aug — 07 Aug 25 Jul — 31 Jul 01 Aug — 07 Aug  #>    \"2025-07-25\"    \"2025-08-08\"    \"2025-08-01\"    \"2025-07-25\"    \"2025-08-01\"  #> 01 Aug — 07 Aug 25 Jul — 31 Jul 08 Aug — 14 Aug 01 Aug — 07 Aug 25 Jul — 31 Jul  #>    \"2025-08-01\"    \"2025-07-25\"    \"2025-08-08\"    \"2025-08-01\"    \"2025-07-25\"  #> 25 Jul — 31 Jul 25 Jul — 31 Jul 08 Aug — 14 Aug 25 Jul — 31 Jul 25 Jul — 31 Jul  #>    \"2025-07-25\"    \"2025-07-25\"    \"2025-08-08\"    \"2025-07-25\"    \"2025-07-25\"  #> 01 Aug — 07 Aug 25 Jul — 31 Jul 08 Aug — 14 Aug 25 Jul — 31 Jul 01 Aug — 07 Aug  #>    \"2025-08-01\"    \"2025-07-25\"    \"2025-08-08\"    \"2025-07-25\"    \"2025-08-01\"  #> 01 Aug — 07 Aug 08 Aug — 14 Aug 25 Jul — 31 Jul 08 Aug — 14 Aug 08 Aug — 14 Aug  #>    \"2025-08-01\"    \"2025-08-08\"    \"2025-07-25\"    \"2025-08-08\"    \"2025-08-08\"  #> 25 Jul — 31 Jul 25 Jul — 31 Jul 25 Jul — 31 Jul 08 Aug — 14 Aug 01 Aug — 07 Aug  #>    \"2025-07-25\"    \"2025-07-25\"    \"2025-07-25\"    \"2025-08-08\"    \"2025-08-01\"  #> 25 Jul — 31 Jul 08 Aug — 14 Aug 08 Aug — 14 Aug 25 Jul — 31 Jul 01 Aug — 07 Aug  #>    \"2025-07-25\"    \"2025-08-08\"    \"2025-08-08\"    \"2025-07-25\"    \"2025-08-01\"  #> 25 Jul — 31 Jul 01 Aug — 07 Aug 08 Aug — 14 Aug 08 Aug — 14 Aug 01 Aug — 07 Aug  #>    \"2025-07-25\"    \"2025-08-01\"    \"2025-08-08\"    \"2025-08-08\"    \"2025-08-01\" dates = seq(as.Date(\"2020-01-01\"),by=7,length.out = 5) tmp = as.time_period(dates) tmp #> time unit: week, origin: 2019-12-29 (a Sunday) #> [1] 0.4285714 1.4285714 2.4285714 3.4285714 4.4285714 suppressWarnings(labels(tmp)) #> 01/Jan — 08/Jan #> 08/Jan — 15/Jan #> 15/Jan — 22/Jan #> 22/Jan — 29/Jan #> 29/Jan — 05/Feb tmp2 = as.time_period(tmp, unit = \"2 days\", start_date = \"2020-01-01\") tmp2 #> time unit: 2 days, origin: 2020-01-01 (a Wednesday) #> [1]  0.0  3.5  7.0 10.5 14.0 as.Date(tmp2) #> [1] \"2020-01-01\" \"2020-01-08\" \"2020-01-15\" \"2020-01-22\" \"2020-01-29\" tmp3 = as.time_period(Sys.Date()+c(0:2,4:5)*7,anchor = \"start\") as.Date(date_seq(tmp3)) #> [1] \"2025-07-24\" \"2025-07-31\" \"2025-08-07\" \"2025-08-14\" \"2025-08-21\" #> [6] \"2025-08-28\" orig_dates = Sys.Date()+1:10*7  # a 2 daily time series based on weekly dates t1 = as.time_period(orig_dates, unit = \"2 days\", start_date = \"2021-01-01\") t1 #> time unit: 2 days, origin: 2021-01-01 (a Friday) #>  [1] 836.0 839.5 843.0 846.5 850.0 853.5 857.0 860.5 864.0 867.5  # a weekly with different start date t2 = as.time_period(orig_dates, unit = \"1 week\", start_date = \"2022-01-01\") t2 #> time unit: week, origin: 2022-01-01 (a Saturday) #>  [1] 186.7143 187.7143 188.7143 189.7143 190.7143 191.7143 192.7143 193.7143 #>  [9] 194.7143 195.7143  # rebase t1 into the same format as t2 # as t1 and t2 based on the same original dates converting t2 onto the same # peridicty as t1 results in an identical set of times t3 = as.time_period(t1,t2) t3 #> time unit: week, origin: 2022-01-01 (a Saturday) #>  [1] 186.7143 187.7143 188.7143 189.7143 190.7143 191.7143 192.7143 193.7143 #>  [9] 194.7143 195.7143"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-periods.html","id":"times-in-ggoutbreak-and-conversion-of-line-lists","dir":"Articles","previous_headings":"","what":"Times in ggoutbreak and conversion of line-lists","title":"Data wrangling and working with `ggoutbreak`","text":"ggoutbreak uses time_period class internally extensively. Casting dates time_periods generally needs done using ggoutbreak. functions ggoutbreak operate time series data expect unique (usually complete) set data periodic time. help prepare line-list data time series time_summarise() function. minimal line-list date column nothing else. line-list contains class column interpreted complete record possible options can calculate denominator. case positive negative results test: specific example subsequent analysis ggoutbreak may focus positive subgroup , comparison positive negative test results trivial. another example class may test results, major subdivision e.g. variant disease. case comparison different groups may much relevant. use class major sub-group convenience. Additional grouping class columns also possible multi-faceted comparisons, grouping preserved included automatically denominator, may need manually calculated:","code":"random_dates = Sys.Date()+sample.int(21,50,replace = TRUE) linelist = tibble::tibble(date = random_dates) linelist %>% time_summarise(unit=\"1 week\") %>% dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ time  <time_prd> 0, 1, 2 #> $ count <int> 27, 17, 6 random_dates = Sys.Date()+sample.int(21,200,replace = TRUE) linelist2 = tibble::tibble(   date = random_dates,   class = stats::rbinom(200, 1, 0.04) %>% ifelse(\"positive\",\"negative\") ) linelist2 %>% time_summarise(unit=\"1 week\") %>% dplyr::glimpse() #> Rows: 6 #> Columns: 4 #> Groups: class [2] #> $ class <chr> \"negative\", \"negative\", \"negative\", \"positive\", \"positive\", \"pos… #> $ time  <time_prd> 0, 1, 2, 0, 1, 2 #> $ count <int> 52, 66, 73, 4, 2, 3 #> $ denom <int> 56, 68, 76, 56, 68, 76 random_dates = Sys.Date()+sample.int(21,200,replace = TRUE) variant = apply(stats::rmultinom(200, 1, c(0.1,0.3,0.6)), MARGIN = 2, function(x) which(x==1))  linelist3 = tibble::tibble(   date = random_dates,   class = c(\"variant1\",\"variant2\",\"variant3\")[variant],   gender = ifelse(stats::rbinom(200,1,0.5),\"male\",\"female\") )    count_by_gender = linelist3 %>%    dplyr::group_by(gender) %>%    time_summarise(unit=\"1 week\") %>%    dplyr::arrange(time, gender, class) %>%   dplyr::glimpse() #> Rows: 18 #> Columns: 5 #> Groups: gender, class [6] #> $ gender <chr> \"female\", \"female\", \"female\", \"male\", \"male\", \"male\", \"female\",… #> $ class  <chr> \"variant1\", \"variant2\", \"variant3\", \"variant1\", \"variant2\", \"va… #> $ time   <time_prd> 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2 #> $ count  <int> 5, 12, 17, 2, 5, 26, 4, 8, 24, 1, 8, 25, 3, 10, 25, 7, 6, 12 #> $ denom  <int> 34, 34, 34, 33, 33, 33, 36, 36, 36, 34, 34, 34, 38, 38, 38…"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-periods.html","id":"aggregating-time-series-datasets-","dir":"Articles","previous_headings":"","what":"Aggregating time series datasets.","title":"Data wrangling and working with `ggoutbreak`","text":"case time series additional grouping present, removing level grouping whilst retaining time made easier time_aggregate(). case wish sum count denom gender, retaining class grouping. default time_aggregate sum count, denom population columns behaviour can specified passing dplyr::summarise style directives function.","code":"count_by_gender %>%    dplyr::group_by(class,gender) %>%    time_aggregate() %>%   dplyr::glimpse() #> Rows: 9 #> Columns: 4 #> Groups: class [3] #> $ class <chr> \"variant1\", \"variant1\", \"variant1\", \"variant2\", \"variant2\", \"var… #> $ time  <time_prd> 0, 1, 2, 0, 1, 2, 0, 1, 2 #> $ count <int> 7, 5, 10, 17, 16, 16, 43, 49, 37 #> $ denom <int> 67, 70, 63, 67, 70, 63, 67, 70, 63"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-units.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Estimating the reproduction number from weekly data","text":"common epidemic data aggregated weekly, monthly even yearly case counts, example result batching reporting processes. ggoutbreak set infrastructure allow case counts used estimate reproduction number, regardless periodicity.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/articles/time-units.html","id":"simulation-with-weekly-data","dir":"Articles","previous_headings":"","what":"Simulation with weekly data","title":"Estimating the reproduction number from weekly data","text":"construct simple count model based time-varying growth rate specified exponential growth case counts per week. time_unit defined 1 week, typically determined data. ggoutbreak generally make informed guess periodicity data construct time_period column dates, stated. case simulation generates outbreak course one year maximum number weekly cases around 250, resulting initial import 30 infectious cases week 0.  can go ahead model case rate exponential growth rate using poisson model plot , parametrised growth rate red. case time unit rates per week. Although time unit per week, model output creating estimate per day (controlled frequency parameter ), allow smooth plot.  want estimate reproduction number, methods need estimates daily incidence cases, input renewal equation. rescale temporal dimension model (using rescale_model()) replot . plot daily case rate estimated peak just 30 (= 250/7 approx). growth rate also rescaled account fact exponential growth rate per day compounded per week figures .  can easily use incidence estimates generation time distribution estimate reproduction number time-series. compare use different method (Wallinga-Lipsitch 2007) convert growth rate parametrisation direct equivalent reproduction number. see good agreement, uncertainty associated RtR_t estimates derived weekly count data appropriately large, include uncertainty generation time.","code":"changes = tibble::tribble(   ~t,    ~r,   0,      0,   5,     0.2,   10,     0.1,   20,     0,   25,     -0.1,   35,     -0.05,   45,     0.1 )    sim = sim_poisson_model(   changes = changes,   max_time = 52,   time_unit = \"1 week\",   fn_imports = ~ ifelse(.x == 0, 30, 0),   seed=100 )  events = attr(sim,\"events\")  plot_cases(sim, events = events, colour=\"grey60\") # Estimate weekly incidence and weekly exponential growth rate incidence = sim %>% ggoutbreak::poisson_locfit_model(frequency = \"1 day\",deg = 2, window=5)  p1 = plot_incidence(incidence, events=events, raw = sim) p2 = plot_growth_rate(incidence,events = events)+ggplot2::coord_cartesian(ylim=c(-0.05*7,+0.05*7))+   # The simulation data includes the parametrised growth rate:   ggplot2::geom_line(data = sim, mapping = ggplot2::aes(x=as.Date(time), y=growth), colour=\"red\") p1+p2+patchwork::plot_layout(ncol=1,axes=\"collect\")+patchwork::plot_annotation(tag_levels = \"A\") # Rescale weekly to daily incidence estimates incidence2 = incidence %>% rescale_model(time_unit = \"1 day\")  p1 = plot_incidence(incidence2, events=events, raw = sim) p2 = plot_growth_rate(incidence2,events = events)+ggplot2::coord_cartesian(ylim=c(-0.05,+0.05))  p1+p2+patchwork::plot_layout(ncol=1,axes = \"collect\")+patchwork::plot_annotation(tag_level=\"A\") # Convert weekly growth rate input to simulation to a reproduction number # and ensure time scales align. changes2 = changes %>% dplyr::transmute(   t = t*7,   R = wallinga_lipsitch(r/7, ganyani_ip_2) ) rt_for_date = \\(t) cfg_step_fn(changes2)(as.time_period(t, unit=\"1 day\"))  # Calculate the reproduction number from daily incidence estimates rt_estim = incidence2 %>% rt_from_incidence(ip = ganyani_ip_2,approx = TRUE)  plot_rt(rt_estim,events = events)+   ggplot2::geom_function(fun=rt_for_date,colour=\"red\",n=nrow(rt_estim))"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/variant-proportions.html","id":"covid-19-proportions-in-england","dir":"Articles","previous_headings":"","what":"COVID-19 proportions in England","title":"Multinomial proportions models for genomic variants","text":"Sanger Centre & COGUK performed large amount sequencing COVID-19 pandemic, identify emerging genomic variants. scaled second half 2021 continued beginning 2023. Lineages assigned using Pango lineage system important ones given nicknames . Sanger variants data discontinued, still available download. code download, process data sets determine full lineage data-raw/variants.R file, output bundled data set . many caveats data terms bias regarded definitive: data must class column defining main categorisation data (case main Pango variant). time column time_period derived date (weekly). necessary column count column integer counts class. data must grouped class. Multiple models can fitted simultaneously data grouped columns.","code":"# tidy copy of the sanger weekly variants count data aggregated to England level ggoutbreak::england_variants %>% dplyr::glimpse() #> Rows: 479 #> Columns: 6 #> Groups: class [10] #> $ date      <date> 2020-09-05, 2020-09-05, 2020-09-12, 2020-09-12, 2020-09-19,… #> $ time      <time_prd> 0, 0, 7, 7, 14, 14, 21, 21, 28, 28, 35, 35, 42, 42, 49,… #> $ class     <fct> Other, Alpha (B.1.1.7), Other, Alpha (B.1.1.7), Other, Alpha… #> $ who_class <fct> Other, Alpha, Other, Alpha, Other, Alpha, Other, Alpha, Othe… #> $ count     <dbl> 1182, 371, 1439, 588, 837, 429, 1685, 1157, 1208, 823, 1501,… #> $ denom     <dbl> 1553, 1553, 2027, 2027, 1266, 1266, 2842, 2842, 2031, 2031, …"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/variant-proportions.html","id":"multinomial-proportions-model-","dir":"Articles","previous_headings":"","what":"Multinomial proportions model.","title":"Multinomial proportions models for genomic variants","text":"Genomic testing happened subset cases. testing effort varied significantly time. proportion variant time can estimated multinomial model.","code":"probs = england_variants %>%    multinomial_nnet_model(window = 28) #> # weights:  40 (27 variable) #> initial  value 3583520.087982  #> iter  10 value 1562162.620103 #> iter  20 value 1380207.974678 #> iter  30 value 959088.555894 #> iter  40 value 742507.401941 #> iter  50 value 731767.878774 #> iter  60 value 729647.595794 #> iter  70 value 726795.599521 #> iter  80 value 716309.104988 #> iter  90 value 709310.965531 #> iter 100 value 707285.575109 #> final  value 707285.575109  #> stopped after 100 iterations  plot_multinomial(probs)+   ggplot2::scale_fill_viridis_d(option=\"cividis\")"},{"path":"https://ai4ci.github.io/ggoutbreak/articles/variant-proportions.html","id":"binomial-proportions-model","dir":"Articles","previous_headings":"","what":"Binomial proportions model","title":"Multinomial proportions models for genomic variants","text":"binomial (one versus others) proportions different multinomial probabilities calculated , come confidence intervals, however median values necessarily sum 1.  rate change proportion individual variant versus others logistic scale can used work exponential growth rate one variant relative others. relative growth rate taken together estimates variants given time centred around zero. one variant growth advantage, definition others growth disadvantage despite potentially causing larger disease burden potentially increasing numbers growing epidemic.  binomial relative growth rate per day growth advantage existing variants. dependency unit time controlled time_period configuration. data provided time_period defined daily basis despite data provided weekly. Doubling time make strict sense describing relative growth rates shown . variant advantage terms reproduction number needs additional information infectivity profile (aka generation time distribution) result much complex.","code":"probs2 = england_variants %>% proportion_locfit_model(window = 14)  plot_proportion(probs2)+   ggplot2::scale_colour_viridis_d(option=\"cividis\",aesthetics = c(\"colour\",\"fill\")) plot_growth_rate(probs2) +   ggplot2::scale_fill_viridis_d(option=\"cividis\",aesthetics = c(\"colour\",\"fill\"))"},{"path":"https://ai4ci.github.io/ggoutbreak/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robert Challen. Author, maintainer, copyright holder.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2025). ggoutbreak: Estimate Incidence, Proportions Exponential Growth Rates. R package version 0.4.6, https://ai4ci.github.io/ggoutbreak/.","code":"@Manual{,   title = {ggoutbreak: Estimate Incidence, Proportions and Exponential Growth Rates},   author = {Robert Challen},   year = {2025},   note = {R package version 0.4.6},   url = {https://ai4ci.github.io/ggoutbreak/}, }"},{"path":"https://ai4ci.github.io/ggoutbreak/index.html","id":"ggoutbreak-","dir":"","previous_headings":"","what":"Estimate Incidence, Proportions and Exponential Growth Rates","title":"Estimate Incidence, Proportions and Exponential Growth Rates","text":"Simple statistical models visualisations calculating incidence, proportion, exponential growth rate, reproduction number infectious disease case time series. tool kit largely developed COVID-19 pandemic.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Incidence, Proportions and Exponential Growth Rates","text":"ggoutbreak hosted AI4CI r-universe. Installation follows: can install development version ggoutbreak GitHub :","code":"options(repos = c(   \"ai4ci\" = 'https://ai4ci.r-universe.dev/',   CRAN = 'https://cloud.r-project.org'))  # Download and install ggoutbreak in R install.packages(\"ggoutbreak\") # install.packages(\"devtools\") devtools::install_github(\"ai4ci/ggoutbreak\")"},{"path":"https://ai4ci.github.io/ggoutbreak/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"Estimate Incidence, Proportions and Exponential Growth Rates","text":"authors gratefully acknowledge support UK Research Innovation AI programme Engineering Physical Sciences Research Council EPSRC grant EP/Y028392/1.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.Date.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert time period to dates — as.Date.time_period","title":"Convert time period to dates — as.Date.time_period","text":"Convert time period dates","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.Date.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert time period to dates — as.Date.time_period","text":"","code":"# S3 method for class 'time_period' as.Date(x, ...)  # S3 method for class 'time_period' as.POSIXct(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.Date.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert time period to dates — as.Date.time_period","text":"x time_period ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.Date.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert time period to dates — as.Date.time_period","text":"vector dates representing start input time_period entries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.Date.time_period.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Convert time period to dates — as.Date.time_period","text":".POSIXct(time_period): Convert vector POSIXct","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a time period class — as.time_period","title":"Convert to a time period class — as.time_period","text":"Time periods just zero based numeric representation dates time unit baked . allows variable length periods (e.g. days weeks), fractional days represented consistent(ish) way","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a time period class — as.time_period","text":"","code":"as.time_period(x, unit = NULL, start_date = NULL, anchor = NULL, ...)  # S3 method for class 'time_period' c(..., recursive = F)  # S3 method for class 'time_period' x[...]  # S3 method for class 'time_period' x[...] <- value  # S3 method for class 'time_period' x[[...]]  # S3 method for class 'time_period' x[[...]] <- value  # S3 method for class 'time_period' seq(from, to = from, ...)  is.time_period(x)  # S3 method for class 'time_period' print(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a time period class — as.time_period","text":"x vector numbers (may integer real) time_period unit length one unit time. either integer number days, specification \"1 week\", another time_period. x time_period, unit different x return new time_period using new units. start_date zero time date something can coerced date. x input already time_period different start_date recalibrated use new start date. anchor relevant x vector dates start_date specified, date, \"start\" \"end\" weekday name e.g. \"mon\". vector dates x find reference date time-series. NULL start_date also NULL fall back getOption(\"day_zero\",\"2019-12-29\") ... used subtype implementations recursive concatenate recursively value value , starting (maximal) end values     sequence.  length 1 unless just supplied     unnamed argument.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to a time period class — as.time_period","text":"time_period class, consisting vector numbers, attributes time period start_date","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Convert to a time period class — as.time_period","text":"c(time_period): Combine time_period [: Subset time_period `[`(time_period) <- value: Assign values subset time_period [[: Get value time_period `[[`(time_period) <- value: Assign value time_period seq(time_period): Create sequence using time_periods .time_period(): Check time_period print(time_period): Print time_period","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/as.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to a time period class — as.time_period","text":"","code":"# 100 weeks from 2020-01-01  tmp = as.time_period(0:100, 7, \"2020-01-01\") as.Date(tmp) #>   [1] \"2020-01-01\" \"2020-01-08\" \"2020-01-15\" \"2020-01-22\" \"2020-01-29\" #>   [6] \"2020-02-05\" \"2020-02-12\" \"2020-02-19\" \"2020-02-26\" \"2020-03-04\" #>  [11] \"2020-03-11\" \"2020-03-18\" \"2020-03-25\" \"2020-04-01\" \"2020-04-08\" #>  [16] \"2020-04-15\" \"2020-04-22\" \"2020-04-29\" \"2020-05-06\" \"2020-05-13\" #>  [21] \"2020-05-20\" \"2020-05-27\" \"2020-06-03\" \"2020-06-10\" \"2020-06-17\" #>  [26] \"2020-06-24\" \"2020-07-01\" \"2020-07-08\" \"2020-07-15\" \"2020-07-22\" #>  [31] \"2020-07-29\" \"2020-08-05\" \"2020-08-12\" \"2020-08-19\" \"2020-08-26\" #>  [36] \"2020-09-02\" \"2020-09-09\" \"2020-09-16\" \"2020-09-23\" \"2020-09-30\" #>  [41] \"2020-10-07\" \"2020-10-14\" \"2020-10-21\" \"2020-10-28\" \"2020-11-04\" #>  [46] \"2020-11-11\" \"2020-11-18\" \"2020-11-25\" \"2020-12-02\" \"2020-12-09\" #>  [51] \"2020-12-16\" \"2020-12-23\" \"2020-12-30\" \"2021-01-06\" \"2021-01-13\" #>  [56] \"2021-01-20\" \"2021-01-27\" \"2021-02-03\" \"2021-02-10\" \"2021-02-17\" #>  [61] \"2021-02-24\" \"2021-03-03\" \"2021-03-10\" \"2021-03-17\" \"2021-03-24\" #>  [66] \"2021-03-31\" \"2021-04-07\" \"2021-04-14\" \"2021-04-21\" \"2021-04-28\" #>  [71] \"2021-05-05\" \"2021-05-12\" \"2021-05-19\" \"2021-05-26\" \"2021-06-02\" #>  [76] \"2021-06-09\" \"2021-06-16\" \"2021-06-23\" \"2021-06-30\" \"2021-07-07\" #>  [81] \"2021-07-14\" \"2021-07-21\" \"2021-07-28\" \"2021-08-04\" \"2021-08-11\" #>  [86] \"2021-08-18\" \"2021-08-25\" \"2021-09-01\" \"2021-09-08\" \"2021-09-15\" #>  [91] \"2021-09-22\" \"2021-09-29\" \"2021-10-06\" \"2021-10-13\" \"2021-10-20\" #>  [96] \"2021-10-27\" \"2021-11-03\" \"2021-11-10\" \"2021-11-17\" \"2021-11-24\" #> [101] \"2021-12-01\"  range(tmp) #> time unit: week, origin: 2020-01-01 (a Wednesday) #> [1]   0 100 min(tmp) #> time unit: week, origin: 2020-01-01 (a Wednesday) #> [1] 0 tmp2 = as.integer(as.Date(tmp)) # testthat::expect_true(all(na.omit(tmp2-lag(tmp2)) == 7))  tmp2 = as.time_period(0:23, 1/24, \"2020-01-01\") as.POSIXct(tmp2) #>  [1] \"2020-01-01 00:00:00 GMT\" \"2020-01-01 01:00:00 GMT\" #>  [3] \"2020-01-01 02:00:00 GMT\" \"2020-01-01 03:00:00 GMT\" #>  [5] \"2020-01-01 04:00:00 GMT\" \"2020-01-01 05:00:00 GMT\" #>  [7] \"2020-01-01 06:00:00 GMT\" \"2020-01-01 07:00:00 GMT\" #>  [9] \"2020-01-01 08:00:00 GMT\" \"2020-01-01 09:00:00 GMT\" #> [11] \"2020-01-01 10:00:00 GMT\" \"2020-01-01 11:00:00 GMT\" #> [13] \"2020-01-01 12:00:00 GMT\" \"2020-01-01 13:00:00 GMT\" #> [15] \"2020-01-01 14:00:00 GMT\" \"2020-01-01 15:00:00 GMT\" #> [17] \"2020-01-01 16:00:00 GMT\" \"2020-01-01 17:00:00 GMT\" #> [19] \"2020-01-01 18:00:00 GMT\" \"2020-01-01 19:00:00 GMT\" #> [21] \"2020-01-01 20:00:00 GMT\" \"2020-01-01 21:00:00 GMT\" #> [23] \"2020-01-01 22:00:00 GMT\" \"2020-01-01 23:00:00 GMT\"  # convert timeseries to new \"unit\" tmp = as.time_period(0:100, 7, \"2020-01-01\") tmp2 = as.time_period(tmp,1) testthat::expect_equal(as.numeric(tmp2), 0:100*7)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/breaks_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"A scales breaks generator for log1p scales — breaks_log1p","title":"A scales breaks generator for log1p scales — breaks_log1p","text":"scales breaks generator log1p scales","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/breaks_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A scales breaks generator for log1p scales — breaks_log1p","text":"","code":"breaks_log1p(n = 5, base = 10)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/breaks_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A scales breaks generator for log1p scales — breaks_log1p","text":"n number breaks base base breaks","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/breaks_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A scales breaks generator for log1p scales — breaks_log1p","text":"function ggplot scale breaks","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/breaks_log1p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A scales breaks generator for log1p scales — breaks_log1p","text":"","code":"ggplot2::ggplot(ggplot2::diamonds, ggplot2::aes(x=price))+   ggplot2::geom_density()+   ggplot2::scale_x_continuous(trans=\"log1p\", breaks=breaks_log1p())"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_beta_prob_rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","title":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","text":"Generate random probability based features simulation","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_beta_prob_rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","text":"","code":"cfg_beta_prob_rng(probability_fn = ~0.8, kappa_fn = ~0.1)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_beta_prob_rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","text":"probability_fn function gives time-varying mean beta distribution, function called minimally .x `t“ time time period. variables may present. kappa_fn function gives time-varying dispersion beta distribution. function called minimally .x t time period .y mean mean. variables may present.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_beta_prob_rng.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","text":"time dependent function inputs time (time_period) returns probability day defined probability_fn kappa_fn","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_beta_prob_rng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a random probability based on features of the simulation — cfg_beta_prob_rng","text":"","code":"fn = cfg_beta_prob_rng(~ ifelse(.x<=5,0.1,0.9)) fn(1:10) #>  [1] 0.09994303 0.10665743 0.11315549 0.08053910 0.09749180 0.90247668 #>  [7] 0.90286478 0.90559741 0.89325780 0.91719053"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_gamma_ip_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","title":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","text":"Get IP generating function time varying mean SD gamma function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_gamma_ip_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","text":"","code":"cfg_gamma_ip_fn(mean_fn = ~2, sd_fn = function(mean) sqrt(mean))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_gamma_ip_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","text":"mean_fn function gives time-varying mean gamma distribution, function called minimally .x t time time period. variables may present. sd_fn function gives time-varying mean gamma distribution. function called minimally .x t time period .y mean mean. variables may present.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_gamma_ip_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","text":"time dependent function inputs time (time_period) returns ip delay distribution day defined mean_fn sd_fn","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_gamma_ip_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a IP generating function from time varying mean and SD of a gamma function — cfg_gamma_ip_fn","text":"","code":"fn = cfg_gamma_ip_fn(mean_fn = \\(t) ifelse(t < 5, 4, 2)) # a gamma function that changes mean at time 5 fn(4) #> [[1]] #> # A tibble: 15 × 5 #> # Groups:   boot [1] #>      tau    a0    a1 probability  boot #>    <int> <dbl> <dbl>       <dbl> <int> #>  1     0   0     0.5    0.00175      1 #>  2     1   0.5   1.5    0.0639       1 #>  3     2   1.5   2.5    0.177        1 #>  4     3   2.5   3.5    0.221        1 #>  5     4   3.5   4.5    0.194        1 #>  6     5   4.5   5.5    0.141        1 #>  7     6   5.5   6.5    0.0898       1 #>  8     7   6.5   7.5    0.0527       1 #>  9     8   7.5   8.5    0.0290       1 #> 10     9   8.5   9.5    0.0152       1 #> 11    10   9.5  10.5    0.00771      1 #> 12    11  10.5  11.5    0.00378      1 #> 13    12  11.5  12.5    0.00181      1 #> 14    13  12.5  13.5    0.000848     1 #> 15    14  13.5  14.5    0.000707     1 #>  fn(7) #> [[1]] #> # A tibble: 11 × 5 #> # Groups:   boot [1] #>      tau    a0    a1 probability  boot #>    <int> <dbl> <dbl>       <dbl> <int> #>  1     0   0     0.5    0.0902       1 #>  2     1   0.5   1.5    0.352        1 #>  3     2   1.5   2.5    0.271        1 #>  4     3   2.5   3.5    0.151        1 #>  5     4   3.5   4.5    0.0748       1 #>  6     5   4.5   5.5    0.0345       1 #>  7     6   5.5   6.5    0.0153       1 #>  8     7   6.5   7.5    0.00657      1 #>  9     8   7.5   8.5    0.00277      1 #> 10     9   8.5   9.5    0.00115      1 #> 11    10   9.5  10.5    0.000786     1 #>"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_ip_sampler_rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","title":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","text":"used random sampling infectivity profile times infection, example. nothing stop putting delay distribution negative times strange things may happen simulation.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_ip_sampler_rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","text":"","code":"cfg_ip_sampler_rng(ip = i_empirical_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_ip_sampler_rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","text":"ip long format empirical distribution - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_ip_sampler_rng.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","text":"function accepts n parameter produces random samples ip distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_ip_sampler_rng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Randomly sample from an empirical distribution — cfg_ip_sampler_rng","text":"","code":"tmp = cfg_ip_sampler_rng(ganyani_ip_2)(10000)  # This discretised ganyani distribution is based on these figures: # mean: 5.2 (3.78-6.78) and sd: 1.72 (0.91-3.93) format_ip(ganyani_ip_2) #> [1] \"PDF: mean: 5.12 [4.02 — 6.76]; sd: 1.91 [1.01 — 3.26]; 100 bootstraps\"  mean(tmp) # Should be about 5.2 #> [1] 5.185636 stats::sd(tmp) # Should be about 1.72 #> [1] 2.165106"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_linear_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear function from dataframe — cfg_linear_fn","title":"Linear function from dataframe — cfg_linear_fn","text":"Linear function dataframe","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_linear_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear function from dataframe — cfg_linear_fn","text":"","code":"cfg_linear_fn(changes, ..., col_name = setdiff(colnames(changes), \"t\"))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_linear_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear function from dataframe — cfg_linear_fn","text":"changes dataframe t <col_name> columns define change points piecewise linear function. ... used col_name value column (optional 2 columns)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_linear_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear function from dataframe — cfg_linear_fn","text":"function inputs vector t returns linearly interpolated value <col_name>","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_step_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Step function from dataframe — cfg_step_fn","title":"Step function from dataframe — cfg_step_fn","text":"Step function dataframe","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_step_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Step function from dataframe — cfg_step_fn","text":"","code":"cfg_step_fn(changes, ..., col_name = setdiff(colnames(changes), \"t\"))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_step_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Step function from dataframe — cfg_step_fn","text":"changes dataframe t <col_name> columns define cut points step function. ... used col_name value column (optional 2 columns)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_step_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Step function from dataframe — cfg_step_fn","text":"function inputs vector t returns next smallest corresponding value <col_name> (first one)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_transition_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a multinomial transition matrix — cfg_transition_fn","title":"Sample from a multinomial transition matrix — cfg_transition_fn","text":"particularly designed use within fn_list_next_gen parameter sim_branching_process() allow age group contract matrices applied example (assuming categorical age).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_transition_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a multinomial transition matrix — cfg_transition_fn","text":"","code":"cfg_transition_fn(transition)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_transition_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a multinomial transition matrix — cfg_transition_fn","text":"transition transition matrix long format dataframe. matrix columns add 1, column names input class. row names output class. data frame format must input, output, probability columns.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_transition_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a multinomial transition matrix — cfg_transition_fn","text":"function given input return samples output class according probability distributions.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_transition_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a multinomial transition matrix — cfg_transition_fn","text":"","code":"age = rep(c(\"child\",\"adult\",\"elderly\"),100)  fn = cfg_transition_fn(tibble::tribble(   ~input, ~output, ~probability,   \"child\", \"child\", 0.5,   \"child\", \"adult\", 0.5,   \"adult\", \"child\", 0.5,   \"adult\", \"adult\", 0.3,   \"adult\", \"elderly\", 0.2,   \"elderly\",\"elderly\", 0.5,   \"elderly\",\"adult\", 0.5, ))  table(fn(age),age) #>          age #>           adult child elderly #>   adult      33    37      63 #>   child      48    63       0 #>   elderly    19     0      37"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_gamma_rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","title":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","text":"function returns random number generator gamma distribution weekly period configurable degree additional variability around weekly pattern. suited delays things like testing may depend day week.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_gamma_rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","text":"","code":"cfg_weekly_gamma_rng(   mean = c(1, 1, 1, 1, 4, 3, 2),   sd = sqrt(mean),   week_starts = weekdays(as.Date(\"2024-10-14\")) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_gamma_rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","text":"mean mean amount delay day week sd SD delay week_starts locale description first day week (default \"Monday\").","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_gamma_rng.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","text":"random number generator taking t time parameter returning duration time t depending day week.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_gamma_rng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weekly delay function with day of week effect — cfg_weekly_gamma_rng","text":"","code":"fn = cfg_weekly_gamma_rng(c(1,1,1,1,4,3,2)) matrix(fn(1:42),ncol=7,byrow=TRUE) #>            [,1]       [,2]      [,3]      [,4]     [,5]      [,6]      [,7] #> [1,] 1.08641963 2.09363044 0.2827077 3.9103619 4.090520 4.1242490 0.6676881 #> [2,] 0.17190983 2.22731570 0.8543931 0.6416130 2.004907 4.9447003 0.2756717 #> [3,] 0.03525481 1.32168469 0.8802695 0.1804067 3.579907 2.6150785 1.8755162 #> [4,] 0.76201598 1.15368866 0.3358088 0.5335274 4.209224 0.1806683 2.7408895 #> [5,] 2.51079346 0.01570596 0.6861532 0.4205036 3.112784 3.0111679 2.5005236 #> [6,] 1.48069895 0.24784653 0.4771234 1.1611859 3.676883 6.6165491 1.2530488"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_ip_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Weekly convolution distribution function — cfg_weekly_ip_fn","title":"Weekly convolution distribution function — cfg_weekly_ip_fn","text":"Weekly convolution distribution function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_ip_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weekly convolution distribution function — cfg_weekly_ip_fn","text":"","code":"cfg_weekly_ip_fn(   mean = c(1, 1, 1, 1, 4, 3, 2),   sd = sqrt(mean),   week_starts = weekdays(as.Date(\"2024-10-14\")) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_ip_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weekly convolution distribution function — cfg_weekly_ip_fn","text":"mean means gamma distributed delay function weekday sd sds gamma distributed delay function weekday week_starts locale description first day week (default \"Monday\").","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_ip_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weekly convolution distribution function — cfg_weekly_ip_fn","text":"time dependent function inputs time (time_period) generates IP delay distribution day varying day week","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_ip_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weekly convolution distribution function — cfg_weekly_ip_fn","text":"","code":"cat(sapply(cfg_weekly_ip_fn()(1:7),format_ip),sep = \"\\n\") #> mean: 1.06; sd: 1.01 #> mean: 1.06; sd: 1.01 #> mean: 1.06; sd: 1.01 #> mean: 1.06; sd: 1.01 #> mean: 4; sd: 2.04 #> mean: 3; sd: 1.77 #> mean: 2.02; sd: 1.44"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_proportion_rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Random probability function with day of week effect — cfg_weekly_proportion_rng","title":"Random probability function with day of week effect — cfg_weekly_proportion_rng","text":"function returns random probability generator weekly period configurable degree additional variability around weekly pattern. suited probabilities things like testing may depend day week.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_proportion_rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random probability function with day of week effect — cfg_weekly_proportion_rng","text":"","code":"cfg_weekly_proportion_rng(   prob = c(0.8, 0.8, 0.8, 0.8, 0.8, 0.5, 0.5),   kappa = 0.1,   week_starts = weekdays(as.Date(\"2024-10-14\")) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_proportion_rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random probability function with day of week effect — cfg_weekly_proportion_rng","text":"prob rates e.g. ascertainment day week. kappa dispersion parameter 0 1. O dispersion. 1 maximum week_starts locale description first day week (default \"Monday\").","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_proportion_rng.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random probability function with day of week effect — cfg_weekly_proportion_rng","text":"random number generator function taking t time parameter returning probability ascertainment time, depending day week etc.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cfg_weekly_proportion_rng.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random probability function with day of week effect — cfg_weekly_proportion_rng","text":"","code":"fn = cfg_weekly_proportion_rng(c(0.9,0.9,0.9,0.9,0.9,0.1,0.1)) matrix(fn(1:42),ncol=7,byrow=TRUE) #>           [,1]      [,2]      [,3]      [,4]      [,5]       [,6]       [,7] #> [1,] 0.8996348 0.9002606 0.8832253 0.8804737 0.9161453 0.08531543 0.09138843 #> [2,] 0.8754847 0.8821821 0.9032120 0.8945146 0.9068591 0.08772913 0.10607827 #> [3,] 0.9142746 0.8991226 0.8999506 0.8903531 0.8927611 0.09617796 0.10898652 #> [4,] 0.9126971 0.8906152 0.9050802 0.8884533 0.9052898 0.09780647 0.10047323 #> [5,] 0.9008940 0.9016618 0.8891548 0.8886515 0.8926083 0.09433257 0.10610750 #> [6,] 0.9014417 0.9031397 0.8910388 0.8780175 0.9045683 0.11981683 0.09081438"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"A COVID-19 infectivity profile based on an empirical resampling approach — covid_ip","title":"A COVID-19 infectivity profile based on an empirical resampling approach — covid_ip","text":"infectivity profile derived meta-analysis serial intervals.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A COVID-19 infectivity profile based on an empirical resampling approach — covid_ip","text":"","code":"data(covid_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_ip.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A COVID-19 infectivity profile based on an empirical resampling approach — covid_ip","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time time (double) - end time period (days) Must grouped : boot (exactly). dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 1400 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_test_sensitivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Test sensitivity of PCR tests — covid_test_sensitivity","title":"Test sensitivity of PCR tests — covid_test_sensitivity","text":"probability detecting COVID using PCR given time since infection, based Binny et al 2023.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_test_sensitivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test sensitivity of PCR tests — covid_test_sensitivity","text":"","code":"data(covid_test_sensitivity)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_test_sensitivity.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Test sensitivity of PCR tests — covid_test_sensitivity","text":"dataframe containing following columns: tau (numeric) - time column probability (numeric) - probability column boot (integer) - boot column Must grouped : boot (groupings allowed). 5100 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_test_sensitivity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test sensitivity of PCR tests — covid_test_sensitivity","text":"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9384503/","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_viral_shedding.html","id":null,"dir":"Reference","previous_headings":"","what":"The COVID-19 viral shedding duration — covid_viral_shedding","title":"The COVID-19 viral shedding duration — covid_viral_shedding","text":"COVID-19 viral shedding duration","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_viral_shedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The COVID-19 viral shedding duration — covid_viral_shedding","text":"","code":"data(covid_viral_shedding)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_viral_shedding.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The COVID-19 viral shedding duration — covid_viral_shedding","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 2600 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/covid_viral_shedding.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The COVID-19 viral shedding duration — covid_viral_shedding","text":"https://www.nature.com/articles/s41467-020-20568-4 Von Kampen et al.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cut_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Places a set of dates within a regular time series — cut_date","title":"Places a set of dates within a regular time series — cut_date","text":"counterpart date_seq_dates(). Take original set data place within regular time series periodicity time series may expressed numbers days, weeks, months quarters, years, periods defined anchoring date, day week reference start end input dates. can either return periods dates factors (e.g. plotting) time_period analysis relies numeric representation date duration anchor.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cut_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Places a set of dates within a regular time series — cut_date","text":"","code":"cut_date(   dates,   unit,   anchor = \"start\",   output = c(\"date\", \"factor\", \"time_period\"),   dfmt = \"%d/%b/%y\",   ifmt = \"{start} — {end}\",   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cut_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Places a set of dates within a regular time series — cut_date","text":"dates set dates unit period e.g. \"1 week\" anchor one date, \"start\" \"end\" weekday name e.g. \"mon\" always one start time periods cutting output return result either \"date\" (default), ordered \"factor\" date ranges label, \"time_period\". result named labels referring dfmt strptime format dates labels ifmt sprintf format period label containing %s exactly twice. ... ignored","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cut_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Places a set of dates within a regular time series — cut_date","text":"set dates, times factor level, representing start period date falls , period defined duration anchor","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/cut_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Places a set of dates within a regular time series — cut_date","text":"","code":"dates = as.Date(c(\"2020-01-01\",\"2020-02-01\",\"2020-01-15\",\"2020-02-03\",NA)) fs = ggoutbreak::date_seq(dates, \"2 days\") dates - cut_date(dates, \"2 days\") #> Time differences in days #> 01/Jan/20 — 02/Jan/20 31/Jan/20 — 01/Feb/20 15/Jan/20 — 16/Jan/20  #>                     0                     1                     0  #> 02/Feb/20 — 03/Feb/20               Unknown  #>                     1                    NA  cut_date(dates,unit=\"2 days\", output=\"time_period\") #> time unit: 2 days, origin: 2020-01-01 (a Wednesday) #> [1]  0 15  7 16 NA  # A weekly set of dates: dates2 = Sys.Date() + floor(stats::runif(50,max=10))*7  # in this specific situation the final date is not truncated because the # input data is seen as an exact match for the whole output period. cut_date(dates2, \"1 week\", \"sun\", output=\"factor\") #>  [1] 21/Sep/25 — 27/Sep/25 07/Sep/25 — 13/Sep/25 27/Jul/25 — 02/Aug/25 #>  [4] 03/Aug/25 — 09/Aug/25 17/Aug/25 — 23/Aug/25 21/Sep/25 — 27/Sep/25 #>  [7] 10/Aug/25 — 16/Aug/25 17/Aug/25 — 23/Aug/25 27/Jul/25 — 02/Aug/25 #> [10] 31/Aug/25 — 06/Sep/25 14/Sep/25 — 20/Sep/25 14/Sep/25 — 20/Sep/25 #> [13] 17/Aug/25 — 23/Aug/25 31/Aug/25 — 06/Sep/25 07/Sep/25 — 13/Sep/25 #> [16] 24/Aug/25 — 30/Aug/25 14/Sep/25 — 20/Sep/25 21/Sep/25 — 27/Sep/25 #> [19] 27/Jul/25 — 02/Aug/25 10/Aug/25 — 16/Aug/25 27/Jul/25 — 02/Aug/25 #> [22] 10/Aug/25 — 16/Aug/25 31/Aug/25 — 06/Sep/25 31/Aug/25 — 06/Sep/25 #> [25] 14/Sep/25 — 20/Sep/25 10/Aug/25 — 16/Aug/25 07/Sep/25 — 13/Sep/25 #> [28] 20/Jul/25 — 26/Jul/25 14/Sep/25 — 20/Sep/25 03/Aug/25 — 09/Aug/25 #> [31] 07/Sep/25 — 13/Sep/25 10/Aug/25 — 16/Aug/25 31/Aug/25 — 06/Sep/25 #> [34] 27/Jul/25 — 02/Aug/25 07/Sep/25 — 13/Sep/25 24/Aug/25 — 30/Aug/25 #> [37] 24/Aug/25 — 30/Aug/25 07/Sep/25 — 13/Sep/25 10/Aug/25 — 16/Aug/25 #> [40] 14/Sep/25 — 20/Sep/25 20/Jul/25 — 26/Jul/25 27/Jul/25 — 02/Aug/25 #> [43] 20/Jul/25 — 26/Jul/25 10/Aug/25 — 16/Aug/25 21/Sep/25 — 27/Sep/25 #> [46] 21/Sep/25 — 27/Sep/25 27/Jul/25 — 02/Aug/25 24/Aug/25 — 30/Aug/25 #> [49] 27/Jul/25 — 02/Aug/25 24/Aug/25 — 30/Aug/25 #> 11 Levels: 20/Jul/25 — 26/Jul/25 < ... < 28/Sep/25 — 04/Oct/25 cut_date(dates2, dfmt = \"%d/%b\", output=\"factor\", unit = \"2 weeks\", anchor=\"sun\") #>  [1] 14/Sep — 27/Sep 31/Aug — 13/Sep 20/Jul — 02/Aug 03/Aug — 16/Aug #>  [5] 17/Aug — 30/Aug 14/Sep — 27/Sep 03/Aug — 16/Aug 17/Aug — 30/Aug #>  [9] 20/Jul — 02/Aug 31/Aug — 13/Sep 14/Sep — 27/Sep 14/Sep — 27/Sep #> [13] 17/Aug — 30/Aug 31/Aug — 13/Sep 31/Aug — 13/Sep 17/Aug — 30/Aug #> [17] 14/Sep — 27/Sep 14/Sep — 27/Sep 20/Jul — 02/Aug 03/Aug — 16/Aug #> [21] 20/Jul — 02/Aug 03/Aug — 16/Aug 31/Aug — 13/Sep 31/Aug — 13/Sep #> [25] 14/Sep — 27/Sep 03/Aug — 16/Aug 31/Aug — 13/Sep 20/Jul — 02/Aug #> [29] 14/Sep — 27/Sep 03/Aug — 16/Aug 31/Aug — 13/Sep 03/Aug — 16/Aug #> [33] 31/Aug — 13/Sep 20/Jul — 02/Aug 31/Aug — 13/Sep 17/Aug — 30/Aug #> [37] 17/Aug — 30/Aug 31/Aug — 13/Sep 03/Aug — 16/Aug 14/Sep — 27/Sep #> [41] 20/Jul — 02/Aug 20/Jul — 02/Aug 20/Jul — 02/Aug 03/Aug — 16/Aug #> [45] 14/Sep — 27/Sep 14/Sep — 27/Sep 20/Jul — 02/Aug 17/Aug — 30/Aug #> [49] 20/Jul — 02/Aug 17/Aug — 30/Aug #> 6 Levels: 20/Jul — 02/Aug < 03/Aug — 16/Aug < ... < 28/Sep — 11/Oct"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.Date.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a date vector to the full range of possible dates — date_seq.Date","title":"Expand a date vector to the full range of possible dates — date_seq.Date","text":"Derive vector observation dates, complete ordered sequence periods regular time series, length periods specified, number days, weeks, years etcetera. E.g. can convert random set dates ordered complete list 1 week intervals (2 month intervals) spanning range dates. interesting problems regarding put breaks within month week. Often either based specific date (e.g. yearly periods starting 2020-01-01) day week (e.g. 2 weekly periods staring Sunday) maybe relative input time series (weekly ending last date data). also problem consider data may incomplete starting end periods, may comparable periods, may need exclude result.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.Date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a date vector to the full range of possible dates — date_seq.Date","text":"","code":"# S3 method for class 'Date' date_seq(x, period = .day_interval(x), anchor = \"start\", complete = FALSE, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.Date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a date vector to the full range of possible dates — date_seq.Date","text":"x vector dates, possibly including NA values period gap observations number days natural language definition period \"1 week\", '2 weeks', '1 month', etcetera. given derived dates. anchor defines day appears sequence (extend far). Given either date, \"start\", \"end\" day week, e.g. \"mon\". complete truncate incomplete start end periods ... ignored","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.Date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a date vector to the full range of possible dates — date_seq.Date","text":"vector dates regular periods minimum maximum dates, boundaries defined anchor.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.Date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a date vector to the full range of possible dates — date_seq.Date","text":"","code":"date_seq(as.Date(c(\"2020-01-01\",\"2020-02-01\",\"2020-01-15\",\"2020-02-01\",NA)), \"2 days\") #>  [1] \"2020-01-01\" \"2020-01-03\" \"2020-01-05\" \"2020-01-07\" \"2020-01-09\" #>  [6] \"2020-01-11\" \"2020-01-13\" \"2020-01-15\" \"2020-01-17\" \"2020-01-19\" #> [11] \"2020-01-21\" \"2020-01-23\" \"2020-01-25\" \"2020-01-27\" \"2020-01-29\" #> [16] \"2020-01-31\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the full sequence of values in a vector — date_seq","title":"Create the full sequence of values in a vector — date_seq","text":"useful want fill missing values observed . example, date_seq(c(1, 2, 4, 6), 1) return 1:6.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the full sequence of values in a vector — date_seq","text":"","code":"date_seq(x, period, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the full sequence of values in a vector — date_seq","text":"x numeric date vector period Gap observation. existing data checked ensure actually periodicity. ... subtype methods","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the full sequence of values in a vector — date_seq","text":"vector type input","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the full sequence of values in a vector — date_seq","text":"","code":"date_seq(c(1, 2, 4, 5, 10), 1) #>  [1]  1  2  3  4  5  6  7  8  9 10"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the full sequence of values in a vector — date_seq.numeric","title":"Create the full sequence of values in a vector — date_seq.numeric","text":"useful want fill missing values observed . example, date_seq(c(1, 2, 4, 6), 1) return 1:6.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the full sequence of values in a vector — date_seq.numeric","text":"","code":"# S3 method for class 'numeric' date_seq(x, period = 1, tol = 1e-06, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the full sequence of values in a vector — date_seq.numeric","text":"x numeric date vector period Gap observation. existing data checked ensure actually periodicity. tol Numerical tolerance checking periodicity. ... subtype methods","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the full sequence of values in a vector — date_seq.numeric","text":"vector type input","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the full sequence of values in a vector — date_seq.numeric","text":"","code":"date_seq(c(1, 2, 4, 5, 10), 1) #>  [1]  1  2  3  4  5  6  7  8  9 10"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a time_period vector to the full range of possible times — date_seq.time_period","title":"Expand a time_period vector to the full range of possible times — date_seq.time_period","text":"Derive vector observation time_periods, complete ordered sequence periods regular time series, length periods specified, number days, weeks, years etc. E.g. can convert random set times ordered complete list 1 week intervals (2 month intervals) spanning range dates. interesting problems regarding put breaks within month week. Often either based specific date (e.g. yearly periods starting 2020-01-01) day week (e.g. 2 weekly periods staring sunday) maybe relative input time series (weekly ending last date data). also problem consider data may incomplete starting end periods, may comparable periods, may need exclude result.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a time_period vector to the full range of possible times — date_seq.time_period","text":"","code":"# S3 method for class 'time_period' date_seq(x, period = attributes(x)$unit, complete = FALSE, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a time_period vector to the full range of possible times — date_seq.time_period","text":"x time period vector period gap observations number days natural language definition period \"1 week\", '2 weeks', '1 month', etc. given derived dates. complete truncate incomplete start end periods ... ignored","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a time_period vector to the full range of possible times — date_seq.time_period","text":"vector time_periods regular periods minimum maximum dates, boundaries defined anchor.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_seq.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a time_period vector to the full range of possible times — date_seq.time_period","text":"","code":"tmp = as.time_period(c(0,10,100), 7, \"2020-01-01\") date_seq(tmp, \"7 days\") #> time unit: week, origin: 2020-01-01 (a Wednesday) #>  [1]   0  10  20  30  40  50  60  70  80  90 100 date_seq(tmp, \"1 day\") #> time unit: week, origin: 2020-01-01 (a Wednesday) #>   [1]  0.1428571  0.2857143  0.4285714  0.5714286  0.7142857  0.8571429 #>   [7]  1.0000000  1.1428571  1.2857143  1.4285714  1.5714286  1.7142857 #>  [13]  1.8571429  2.0000000  2.1428571  2.2857143  2.4285714  2.5714286 #>  [19]  2.7142857  2.8571429  3.0000000  3.1428571  3.2857143  3.4285714 #>  [25]  3.5714286  3.7142857  3.8571429  4.0000000  4.1428571  4.2857143 #>  [31]  4.4285714  4.5714286  4.7142857  4.8571429  5.0000000  5.1428571 #>  [37]  5.2857143  5.4285714  5.5714286  5.7142857  5.8571429  6.0000000 #>  [43]  6.1428571  6.2857143  6.4285714  6.5714286  6.7142857  6.8571429 #>  [49]  7.0000000  7.1428571  7.2857143  7.4285714  7.5714286  7.7142857 #>  [55]  7.8571429  8.0000000  8.1428571  8.2857143  8.4285714  8.5714286 #>  [61]  8.7142857  8.8571429  9.0000000  9.1428571  9.2857143  9.4285714 #>  [67]  9.5714286  9.7142857  9.8571429 10.0000000 10.1428571 10.2857143 #>  [73] 10.4285714 10.5714286 10.7142857 10.8571429 11.0000000 11.1428571 #>  [79] 11.2857143 11.4285714 11.5714286 11.7142857 11.8571429 12.0000000 #>  [85] 12.1428571 12.2857143 12.4285714 12.5714286 12.7142857 12.8571429 #>  [91] 13.0000000 13.1428571 13.2857143 13.4285714 13.5714286 13.7142857 #>  [97] 13.8571429 14.0000000 14.1428571 14.2857143 14.4285714 14.5714286 #> [103] 14.7142857 14.8571429 15.0000000 15.1428571 15.2857143 15.4285714 #> [109] 15.5714286 15.7142857 15.8571429 16.0000000 16.1428571 16.2857143 #> [115] 16.4285714 16.5714286 16.7142857 16.8571429 17.0000000 17.1428571 #> [121] 17.2857143 17.4285714 17.5714286 17.7142857 17.8571429 18.0000000 #> [127] 18.1428571 18.2857143 18.4285714 18.5714286 18.7142857 18.8571429 #> [133] 19.0000000 19.1428571 19.2857143 19.4285714 19.5714286 19.7142857 #> [139] 19.8571429 20.0000000 20.1428571 20.2857143 20.4285714 20.5714286 #> [145] 20.7142857 20.8571429 21.0000000 21.1428571 21.2857143 21.4285714 #> [151] 21.5714286 21.7142857 21.8571429 22.0000000 22.1428571 22.2857143 #> [157] 22.4285714 22.5714286 22.7142857 22.8571429 23.0000000 23.1428571 #> [163] 23.2857143 23.4285714 23.5714286 23.7142857 23.8571429 24.0000000 #> [169] 24.1428571 24.2857143 24.4285714 24.5714286 24.7142857 24.8571429 #> [175] 25.0000000 25.1428571 25.2857143 25.4285714 25.5714286 25.7142857 #> [181] 25.8571429 26.0000000 26.1428571 26.2857143 26.4285714 26.5714286 #> [187] 26.7142857 26.8571429 27.0000000 27.1428571 27.2857143 27.4285714 #> [193] 27.5714286 27.7142857 27.8571429 28.0000000 28.1428571 28.2857143 #> [199] 28.4285714 28.5714286 28.7142857 28.8571429 29.0000000 29.1428571 #> [205] 29.2857143 29.4285714 29.5714286 29.7142857 29.8571429 30.0000000 #> [211] 30.1428571 30.2857143 30.4285714 30.5714286 30.7142857 30.8571429 #> [217] 31.0000000 31.1428571 31.2857143 31.4285714 31.5714286 31.7142857 #> [223] 31.8571429 32.0000000 32.1428571 32.2857143 32.4285714 32.5714286 #> [229] 32.7142857 32.8571429 33.0000000 33.1428571 33.2857143 33.4285714 #> [235] 33.5714286 33.7142857 33.8571429 34.0000000 34.1428571 34.2857143 #> [241] 34.4285714 34.5714286 34.7142857 34.8571429 35.0000000 35.1428571 #> [247] 35.2857143 35.4285714 35.5714286 35.7142857 35.8571429 36.0000000 #> [253] 36.1428571 36.2857143 36.4285714 36.5714286 36.7142857 36.8571429 #> [259] 37.0000000 37.1428571 37.2857143 37.4285714 37.5714286 37.7142857 #> [265] 37.8571429 38.0000000 38.1428571 38.2857143 38.4285714 38.5714286 #> [271] 38.7142857 38.8571429 39.0000000 39.1428571 39.2857143 39.4285714 #> [277] 39.5714286 39.7142857 39.8571429 40.0000000 40.1428571 40.2857143 #> [283] 40.4285714 40.5714286 40.7142857 40.8571429 41.0000000 41.1428571 #> [289] 41.2857143 41.4285714 41.5714286 41.7142857 41.8571429 42.0000000 #> [295] 42.1428571 42.2857143 42.4285714 42.5714286 42.7142857 42.8571429 #> [301] 43.0000000 43.1428571 43.2857143 43.4285714 43.5714286 43.7142857 #> [307] 43.8571429 44.0000000 44.1428571 44.2857143 44.4285714 44.5714286 #> [313] 44.7142857 44.8571429 45.0000000 45.1428571 45.2857143 45.4285714 #> [319] 45.5714286 45.7142857 45.8571429 46.0000000 46.1428571 46.2857143 #> [325] 46.4285714 46.5714286 46.7142857 46.8571429 47.0000000 47.1428571 #> [331] 47.2857143 47.4285714 47.5714286 47.7142857 47.8571429 48.0000000 #> [337] 48.1428571 48.2857143 48.4285714 48.5714286 48.7142857 48.8571429 #> [343] 49.0000000 49.1428571 49.2857143 49.4285714 49.5714286 49.7142857 #> [349] 49.8571429 50.0000000 50.1428571 50.2857143 50.4285714 50.5714286 #> [355] 50.7142857 50.8571429 51.0000000 51.1428571 51.2857143 51.4285714 #> [361] 51.5714286 51.7142857 51.8571429 52.0000000 52.1428571 52.2857143 #> [367] 52.4285714 52.5714286 52.7142857 52.8571429 53.0000000 53.1428571 #> [373] 53.2857143 53.4285714 53.5714286 53.7142857 53.8571429 54.0000000 #> [379] 54.1428571 54.2857143 54.4285714 54.5714286 54.7142857 54.8571429 #> [385] 55.0000000 55.1428571 55.2857143 55.4285714 55.5714286 55.7142857 #> [391] 55.8571429 56.0000000 56.1428571 56.2857143 56.4285714 56.5714286 #> [397] 56.7142857 56.8571429 57.0000000 57.1428571 57.2857143 57.4285714 #> [403] 57.5714286 57.7142857 57.8571429 58.0000000 58.1428571 58.2857143 #> [409] 58.4285714 58.5714286 58.7142857 58.8571429 59.0000000 59.1428571 #> [415] 59.2857143 59.4285714 59.5714286 59.7142857 59.8571429 60.0000000 #> [421] 60.1428571 60.2857143 60.4285714 60.5714286 60.7142857 60.8571429 #> [427] 61.0000000 61.1428571 61.2857143 61.4285714 61.5714286 61.7142857 #> [433] 61.8571429 62.0000000 62.1428571 62.2857143 62.4285714 62.5714286 #> [439] 62.7142857 62.8571429 63.0000000 63.1428571 63.2857143 63.4285714 #> [445] 63.5714286 63.7142857 63.8571429 64.0000000 64.1428571 64.2857143 #> [451] 64.4285714 64.5714286 64.7142857 64.8571429 65.0000000 65.1428571 #> [457] 65.2857143 65.4285714 65.5714286 65.7142857 65.8571429 66.0000000 #> [463] 66.1428571 66.2857143 66.4285714 66.5714286 66.7142857 66.8571429 #> [469] 67.0000000 67.1428571 67.2857143 67.4285714 67.5714286 67.7142857 #> [475] 67.8571429 68.0000000 68.1428571 68.2857143 68.4285714 68.5714286 #> [481] 68.7142857 68.8571429 69.0000000 69.1428571 69.2857143 69.4285714 #> [487] 69.5714286 69.7142857 69.8571429 70.0000000 70.1428571 70.2857143 #> [493] 70.4285714 70.5714286 70.7142857 70.8571429 71.0000000 71.1428571 #> [499] 71.2857143 71.4285714 71.5714286 71.7142857 71.8571429 72.0000000 #> [505] 72.1428571 72.2857143 72.4285714 72.5714286 72.7142857 72.8571429 #> [511] 73.0000000 73.1428571 73.2857143 73.4285714 73.5714286 73.7142857 #> [517] 73.8571429 74.0000000 74.1428571 74.2857143 74.4285714 74.5714286 #> [523] 74.7142857 74.8571429 75.0000000 75.1428571 75.2857143 75.4285714 #> [529] 75.5714286 75.7142857 75.8571429 76.0000000 76.1428571 76.2857143 #> [535] 76.4285714 76.5714286 76.7142857 76.8571429 77.0000000 77.1428571 #> [541] 77.2857143 77.4285714 77.5714286 77.7142857 77.8571429 78.0000000 #> [547] 78.1428571 78.2857143 78.4285714 78.5714286 78.7142857 78.8571429 #> [553] 79.0000000 79.1428571 79.2857143 79.4285714 79.5714286 79.7142857 #> [559] 79.8571429 80.0000000 80.1428571 80.2857143 80.4285714 80.5714286 #> [565] 80.7142857 80.8571429 81.0000000 81.1428571 81.2857143 81.4285714 #> [571] 81.5714286 81.7142857 81.8571429 82.0000000 82.1428571 82.2857143 #> [577] 82.4285714 82.5714286 82.7142857 82.8571429 83.0000000 83.1428571 #> [583] 83.2857143 83.4285714 83.5714286 83.7142857 83.8571429 84.0000000 #> [589] 84.1428571 84.2857143 84.4285714 84.5714286 84.7142857 84.8571429 #> [595] 85.0000000 85.1428571 85.2857143 85.4285714 85.5714286 85.7142857 #> [601] 85.8571429 86.0000000 86.1428571 86.2857143 86.4285714 86.5714286 #> [607] 86.7142857 86.8571429 87.0000000 87.1428571 87.2857143 87.4285714 #> [613] 87.5714286 87.7142857 87.8571429 88.0000000 88.1428571 88.2857143 #> [619] 88.4285714 88.5714286 88.7142857 88.8571429 89.0000000 89.1428571 #> [625] 89.2857143 89.4285714 89.5714286 89.7142857 89.8571429 90.0000000 #> [631] 90.1428571 90.2857143 90.4285714 90.5714286 90.7142857 90.8571429 #> [637] 91.0000000 91.1428571 91.2857143 91.4285714 91.5714286 91.7142857 #> [643] 91.8571429 92.0000000 92.1428571 92.2857143 92.4285714 92.5714286 #> [649] 92.7142857 92.8571429 93.0000000 93.1428571 93.2857143 93.4285714 #> [655] 93.5714286 93.7142857 93.8571429 94.0000000 94.1428571 94.2857143 #> [661] 94.4285714 94.5714286 94.7142857 94.8571429 95.0000000 95.1428571 #> [667] 95.2857143 95.4285714 95.5714286 95.7142857 95.8571429 96.0000000 #> [673] 96.1428571 96.2857143 96.4285714 96.5714286 96.7142857 96.8571429 #> [679] 97.0000000 97.1428571 97.2857143 97.4285714 97.5714286 97.7142857 #> [685] 97.8571429 98.0000000 98.1428571 98.2857143 98.4285714 98.5714286 #> [691] 98.7142857 98.8571429 99.0000000 99.1428571 99.2857143 99.4285714 #> [697] 99.5714286 99.7142857 99.8571429"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_to_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a set of dates to numeric timepoints — date_to_time","title":"Convert a set of dates to numeric timepoints — date_to_time","text":"Using start_date unit specification","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_to_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a set of dates to numeric timepoints — date_to_time","text":"","code":"date_to_time(   dates,   unit = .day_interval(dates),   start_date = getOption(\"day_zero\", \"2019-12-29\") )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_to_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a set of dates to numeric timepoints — date_to_time","text":"dates vector dates convert unit specification unit resulting time series. determined periodicity dates specified. another time_period given unit start_date origin conversion. Defaults beginning COVID pandemic","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_to_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a set of dates to numeric timepoints — date_to_time","text":"vector class time_period","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/date_to_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a set of dates to numeric timepoints — date_to_time","text":"","code":"times = date_to_time(as.Date(\"2019-12-29\")+0:100, \"1 week\") dates = time_to_date(times)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dbeta2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Beta Distribution — dbeta2","title":"The Beta Distribution — dbeta2","text":"Density, distribution function, quantile function random   generation Beta distribution parameters shape1   shape2 (optional non-centrality parameter ncp).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dbeta2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Beta Distribution — dbeta2","text":"","code":"dbeta2(x, prob, kappa, log = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dbeta2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Beta Distribution — dbeta2","text":"x vector quantiles prob mean probability (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised) log logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dbeta2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Beta Distribution — dbeta2","text":"dbeta gives density, pbeta distribution   function, qbeta quantile function, rbeta   generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rbeta, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dbeta2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Beta Distribution — dbeta2","text":"","code":"dbeta2(c(0.25,0.5,0.75), 0.5, 0.25) #> [1] 0.008405383 5.441004532 0.008405383"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dgamma2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Gamma Distribution — dgamma2","title":"The Gamma Distribution — dgamma2","text":"Density, distribution function, quantile function random   generation Gamma distribution parameters shape   scale.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dgamma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Gamma Distribution — dgamma2","text":"","code":"dgamma2(x, mean, sd = sqrt(mean), log = FALSE, convex = TRUE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dgamma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Gamma Distribution — dgamma2","text":"x vector quantiles mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) log logical; TRUE, probabilities p given log(p). convex Show warning distribution selected convex function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dgamma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Gamma Distribution — dgamma2","text":"dgamma gives density,   pgamma gives distribution function,   qgamma gives quantile function,   rgamma generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rgamma, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dgamma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Gamma Distribution — dgamma2","text":"","code":"dgamma2(seq(0,4,0.25), 2, 1) #>  [1] 0.00000000 0.02527211 0.12262648 0.25102143 0.36089409 0.42752603 #>  [7] 0.44808362 0.43157094 0.39073363 0.33743577 0.28074779 0.22664553 #> [13] 0.17847016 0.13762733 0.10425850 0.07777749 0.05725229"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Log Normal Distribution — dlnorm2","title":"The Log Normal Distribution — dlnorm2","text":"Density, distribution function, quantile function random   generation log normal distribution whose logarithm mean   equal meanlog standard deviation equal sdlog.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Log Normal Distribution — dlnorm2","text":"","code":"dlnorm2(x, mean = 1, sd = sqrt(exp(1) - 1), log = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Log Normal Distribution — dlnorm2","text":"dlnorm calculated definition (‘Details’).   [pqr]lnorm based relationship normal. Consequently, model single point mass exp(meanlog)   boundary case sdlog = 0.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Log Normal Distribution — dlnorm2","text":"x vector quantiles mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) log logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Log Normal Distribution — dlnorm2","text":"dlnorm gives density,   plnorm gives distribution function,   qlnorm gives quantile function,   rlnorm generates random deviates. length result determined n   rlnorm, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Log Normal Distribution — dlnorm2","text":"log normal distribution density   $$     f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma x} e^{-(\\log(x) - \\mu)^2/2 \\sigma^2}%   $$   \\(\\mu\\) \\(\\sigma\\) mean standard   deviation logarithm.   mean \\(E(X) = exp(\\mu + 1/2 \\sigma^2)\\),   median \\(med(X) = exp(\\mu)\\), variance   \\(Var(X) = exp(2\\mu + \\sigma^2)(exp(\\sigma^2) - 1)\\)   hence coefficient variation   \\(\\sqrt{exp(\\sigma^2) - 1}\\)   approximately \\(\\sigma\\) small (e.g., \\(\\sigma < 1/2\\)).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The Log Normal Distribution — dlnorm2","text":"cumulative hazard \\(H(t) = - \\log(1 - F(t))\\)   -plnorm(t, r, lower = FALSE, log = TRUE).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Log Normal Distribution — dlnorm2","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole. Johnson, N. L., Kotz, S. Balakrishnan, N. (1995)   Continuous Univariate Distributions, volume 1, chapter 14.   Wiley, New York.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dlnorm2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Log Normal Distribution — dlnorm2","text":"","code":"dlnorm2(seq(0,4,0.25), 2, 1) #>  [1] 0.0000000000 0.0005757428 0.0442991085 0.2071346586 0.3958009702 #>  [6] 0.5066252419 0.5252248069 0.4820705272 0.4106521947 0.3336148024 #> [11] 0.2628174046 0.2029235657 0.1546511354 0.1168989116 0.0879351969 #> [16] 0.0659844844 0.0494751213"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Negative Binomial Distribution — dnbinom2","title":"The Negative Binomial Distribution — dnbinom2","text":"Density, distribution function, quantile function random   generation negative binomial distribution parameters   size prob.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Negative Binomial Distribution — dnbinom2","text":"","code":"dnbinom2(x, mean, sd = sqrt(mean), log = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Negative Binomial Distribution — dnbinom2","text":"dnbinom computes via binomial probabilities, using code   contributed Catherine Loader (see dbinom). pnbinom uses pbeta. qnbinom uses Cornish–Fisher Expansion include skewness   correction normal approximation, followed search. rnbinom uses derivation gamma mixture Poisson   distributions, see Devroye, L. (1986) Non-Uniform Random Variate Generation.   Springer-Verlag, New York. Page 480.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Negative Binomial Distribution — dnbinom2","text":"x vector (non-negative integer) quantiles. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) log logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Negative Binomial Distribution — dnbinom2","text":"dnbinom gives density,   pnbinom gives distribution function,   qnbinom gives quantile function,   rnbinom generates random deviates. Invalid size prob result return value   NaN, warning. length result determined n   rnbinom, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used. rnbinom returns vector type integer unless generated   values exceed maximum representable integer double   values returned.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Negative Binomial Distribution — dnbinom2","text":"negative binomial distribution size \\(= n\\)   prob \\(= p\\) density   $$     p(x) = \\frac{\\Gamma(x+n)}{\\Gamma(n) x!} p^n (1-p)^x$$   \\(x = 0, 1, 2, \\ldots\\), \\(n > 0\\) \\(0 < p \\le 1\\). represents number failures occur sequence   Bernoulli trials target number successes reached.   mean \\(\\mu = n(1-p)/p\\) variance \\(n(1-p)/p^2\\). negative binomial distribution can also arise mixture   Poisson distributions mean distributed gamma distribution   (see pgamma) scale parameter (1 - prob)/prob   shape parameter size.  (definition allows non-integer   values size.) alternative parametrization (often used ecology)   mean mu (see ), size, dispersion   parameter, prob = size/(size+mu).  variance   mu + mu^2/size parametrization. element x integer, result dnbinom   zero, warning. case size == 0 distribution concentrated zero.   limiting distribution size approaching zero,   even mu rather prob held constant.  Notice   though, mean limit distribution 0, whatever   value mu. quantile defined smallest value \\(x\\)   \\(F(x) \\ge p\\), \\(F\\) distribution function.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dnbinom2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Negative Binomial Distribution — dnbinom2","text":"","code":"dnbinom2(0:5, 2, sqrt(2)) #> [1] 0.13533528 0.27067057 0.27067057 0.18044704 0.09022352 0.03608941"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixbeta.html","id":null,"dir":"Reference","previous_headings":"","what":"The cumulative density function of a mixture of beta distributions — .pmixbeta","title":"The cumulative density function of a mixture of beta distributions — .pmixbeta","text":"cumulative density function mixture beta distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixbeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The cumulative density function of a mixture of beta distributions — .pmixbeta","text":"","code":".pmixbeta(q, alphas, betas, weights = 1, na.rm = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixbeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The cumulative density function of a mixture of beta distributions — .pmixbeta","text":"q vector quantiles. alphas vector beta distribution alphas betas vector gamma distribution betas weights vector weights na.rm remove distributions NA shape rate","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixbeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The cumulative density function of a mixture of beta distributions — .pmixbeta","text":"pdf mixture distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixbeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The cumulative density function of a mixture of beta distributions — .pmixbeta","text":"","code":"try({   .pmixbeta(q=c(2,20), alphas=c(10,13,14), betas=c(1,1,1), weights=c(2,2,3)) }) #> Error in .pmixbeta(q = c(2, 20), alphas = c(10, 13, 14), betas = c(1,  :  #>   could not find function \".pmixbeta\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixgamma.html","id":null,"dir":"Reference","previous_headings":"","what":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","title":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","text":"cumulative density function mixture gamma distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixgamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","text":"","code":".pmixgamma(q, shapes, rates, weights = 1, na.rm = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixgamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","text":"q vector quantiles. shapes vector gamma distribution shapes rates vector gamma distribution rates weights vector weights na.rm remove distributions NA shape rate","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixgamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","text":"pdf mixture distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixgamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The cumulative density function of a mixture of gamma distributions — .pmixgamma","text":"","code":"try({   .pmixgamma(q=c(2,20), shapes=c(10,13,14), rates=c(1,1,1), weights=c(2,2,3)) }) #> Error in .pmixgamma(q = c(2, 20), shapes = c(10, 13, 14), rates = c(1,  :  #>   could not find function \".pmixgamma\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixlnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","title":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","text":"cumulative density function mixture log normal distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixlnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","text":"","code":".pmixlnorm(q, meanlogs, sdlogs, weights = 1, na.rm = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixlnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","text":"q vector quantiles. meanlogs vector normal distribution means sdlogs vector normal distribution sds weights vector weights na.rm remove distributions NA mean sd","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixlnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","text":"pdf mixture distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixlnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The cumulative density function of a mixture of log normal distributions — .pmixlnorm","text":"","code":"try({ .pmixlnorm(q=c(2,20), meanlogs=c(1.0,1.3,1.4), sdlogs=c(1,1,2), weights=c(2,2,3)) }) #> Error in .pmixlnorm(q = c(2, 20), meanlogs = c(1, 1.3, 1.4), sdlogs = c(1,  :  #>   could not find function \".pmixlnorm\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"The cumulative density function of a mixture of normal distributions — .pmixnorm","title":"The cumulative density function of a mixture of normal distributions — .pmixnorm","text":"cumulative density function mixture normal distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The cumulative density function of a mixture of normal distributions — .pmixnorm","text":"","code":".pmixnorm(q, means, sds, weights = 1, na.rm = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The cumulative density function of a mixture of normal distributions — .pmixnorm","text":"q vector quantiles. means vector normal distribution means sds vector normal distribution sds weights vector weights na.rm remove distributions NA mean sd","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The cumulative density function of a mixture of normal distributions — .pmixnorm","text":"pdf mixture distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-pmixnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The cumulative density function of a mixture of normal distributions — .pmixnorm","text":"","code":"try({ .pmixnorm(q=c(2,20), means=c(10,13,14), sds=c(1,1,2), weights=c(2,2,3)) }) #> Error in .pmixnorm(q = c(2, 20), means = c(10, 13, 14), sds = c(1, 1,  :  #>   could not find function \".pmixnorm\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixbeta.html","id":null,"dir":"Reference","previous_headings":"","what":"A quantile function for a mixture of gamma distributions — .qmixbeta","title":"A quantile function for a mixture of gamma distributions — .qmixbeta","text":"quantile function mixture gamma distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixbeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quantile function for a mixture of gamma distributions — .qmixbeta","text":"","code":".qmixbeta(   p,   alphas,   betas,   weights = 1,   na.rm = FALSE,   method = c(\"exact\", \"samples\", \"moments\"),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixbeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quantile function for a mixture of gamma distributions — .qmixbeta","text":"p vector probabilities. alphas vector gamma distribution shapes betas vector gamma distribution rates weights vector weights na.rm remove distributions NA values mean sd method one exact (solve uniroot), samples (random resampling), moments (Cornish Fisher approximation) ... passed internal function, seed=XXX fix random seed","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixbeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quantile function for a mixture of gamma distributions — .qmixbeta","text":"value pth quantile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixbeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A quantile function for a mixture of gamma distributions — .qmixbeta","text":"","code":"try({   .qmixbeta(p=c(0.025,0.5,0.975), alphas=c(10,13,14), betas=c(1,1,2))   .qmixbeta(p=c(0.025,0.5,0.975), alphas=c(10,13,14), betas=c(1,1,2), method=\"moments\") }) #> Error in .qmixbeta(p = c(0.025, 0.5, 0.975), alphas = c(10, 13, 14), betas = c(1,  :  #>   could not find function \".qmixbeta\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixgamma.html","id":null,"dir":"Reference","previous_headings":"","what":"A quantile function for a mixture of gamma distributions — .qmixgamma","title":"A quantile function for a mixture of gamma distributions — .qmixgamma","text":"quantile function mixture gamma distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixgamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quantile function for a mixture of gamma distributions — .qmixgamma","text":"","code":".qmixgamma(   p,   shapes,   rates,   weights = 1,   na.rm = FALSE,   method = c(\"exact\", \"samples\", \"moments\"),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixgamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quantile function for a mixture of gamma distributions — .qmixgamma","text":"p vector probabilities. shapes vector gamma distribution shapes rates vector gamma distribution rates weights vector weights na.rm remove distributions NA values mean sd method one exact (solve uniroot), samples (random resampling), moments (Cornish Fisher approximation) ... passed internal function, seed=XXX fix random seed","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixgamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quantile function for a mixture of gamma distributions — .qmixgamma","text":"value pth quantile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixgamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A quantile function for a mixture of gamma distributions — .qmixgamma","text":"","code":"try({   .qmixgamma(p=c(0.025,0.5,0.975), shapes=c(10,13,14), rates=c(1,1,2), method=\"moments\")   .qmixgamma(p=c(0.025,0.5,0.975), shapes=c(10,13,14), rates=c(1,1,2), method=\"exact\") }) #> Error in .qmixgamma(p = c(0.025, 0.5, 0.975), shapes = c(10, 13, 14),  :  #>   could not find function \".qmixgamma\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixlnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"A quantile function for a mixture of log normal distributions — .qmixlnorm","title":"A quantile function for a mixture of log normal distributions — .qmixlnorm","text":"quantile function mixture log normal distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixlnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quantile function for a mixture of log normal distributions — .qmixlnorm","text":"","code":".qmixlnorm(   p,   meanlogs,   sdlogs,   weights = rep(1, length(meanlogs)),   na.rm = FALSE,   method = c(\"exact\", \"samples\", \"moments\"),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixlnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quantile function for a mixture of log normal distributions — .qmixlnorm","text":"p vector probabilities. meanlogs vector log normal distribution means sdlogs vector log normal distribution sds weights vector weights na.rm remove distributions NA values mean sd method one exact (solve uniroot), samples (random resampling), moments (Cornish Fisher approximation) ... passed internal function, seed=XXX fix random seed","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixlnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quantile function for a mixture of log normal distributions — .qmixlnorm","text":"value pth quantile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixlnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A quantile function for a mixture of log normal distributions — .qmixlnorm","text":"","code":"try({   .qmixlnorm(p=c(0.025,0.5,0.975), meanlogs=c(1,1.3,1.4), sdlogs=c(0.1,0.1,0.2))   .qmixlnorm(p=c(0.025,0.5,0.975), meanlogs=c(1,1.3,1.4), sdlogs=c(0.1,0.1,0.2), method=\"samples\")   .qmixlnorm(p=c(0.025,0.5,0.975), meanlogs=c(1,1.3,1.4), sdlogs=c(0.1,0.1,0.2), method=\"moments\") }) #> Error in .qmixlnorm(p = c(0.025, 0.5, 0.975), meanlogs = c(1, 1.3, 1.4),  :  #>   could not find function \".qmixlnorm\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"A quantile function for a mixture of normal distributions — .qmixnorm","title":"A quantile function for a mixture of normal distributions — .qmixnorm","text":"quantile function mixture normal distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quantile function for a mixture of normal distributions — .qmixnorm","text":"","code":".qmixnorm(   p,   means,   sds,   weights = 1,   na.rm = FALSE,   method = c(\"exact\", \"samples\", \"moments\"),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quantile function for a mixture of normal distributions — .qmixnorm","text":"p vector probabilities. means vector normal distribution means sds vector normal distribution sds weights vector weights na.rm remove distributions NA values mean sd method one exact (solve uniroot), samples (random resampling), moments (Cornish Fisher approximation) ... passed internal function, samples=TRUE force random sampling","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quantile function for a mixture of normal distributions — .qmixnorm","text":"value pth quantile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-qmixnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A quantile function for a mixture of normal distributions — .qmixnorm","text":"","code":"try({ .qmixnorm(p=c(0.025,0.5,0.975), means=c(10,13,14), sds=c(1,1,2)) }) #> Error in .qmixnorm(p = c(0.025, 0.5, 0.975), means = c(10, 13, 14), sds = c(1,  :  #>   could not find function \".qmixnorm\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-ts_evaluate.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate a function in a timeseries dataframe — .ts_evaluate","title":"Evaluate a function in a timeseries dataframe — .ts_evaluate","text":"N.B. exported used one vignette demo purposes","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-ts_evaluate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate a function in a timeseries dataframe — .ts_evaluate","text":"","code":".ts_evaluate(fn, df)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-ts_evaluate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate a function in a timeseries dataframe — .ts_evaluate","text":"fn function. df dataframe numeric time column, plus columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-ts_evaluate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate a function in a timeseries dataframe — .ts_evaluate","text":"vector, result applying function df.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dot-ts_evaluate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate a function in a timeseries dataframe — .ts_evaluate","text":"","code":"test = tibble::tibble(   time = 1:10,   class = rep(c(\"one\",\"two\"),5) ) .ts_evaluate(\\(t,class) {print(t); print(class); 1}, test ) #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  [1] \"one\" \"two\" \"one\" \"two\" \"one\" \"two\" \"one\" \"two\" \"one\" \"two\" #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/doubling_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Doubling time from growth rate — doubling_time","title":"Doubling time from growth rate — doubling_time","text":"unit doubling times always days.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/doubling_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Doubling time from growth rate — doubling_time","text":"","code":"doubling_time(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/doubling_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Doubling time from growth rate — doubling_time","text":"x proportion incidence growth rates - EITHER: dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed. ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/doubling_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Doubling time from growth rate — doubling_time","text":"dataframe additional columns doubling time relative doubling time plus confidence intervals.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/doubling_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Doubling time from growth rate — doubling_time","text":"","code":"ggoutbreak::test_poisson_rt_smooth %>%   ggoutbreak::poisson_locfit_model(window=21) %>%   ggoutbreak::doubling_time() %>%   dplyr::glimpse() #> Rows: 161 #> Columns: 23 #> Groups: statistic [1] #> $ statistic           <chr> \"infections\", \"infections\", \"infections\", \"infecti… #> $ time                <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,… #> $ incidence.fit       <dbl> 1.675990, 1.659573, 1.640519, 1.619772, 1.598274, … #> $ incidence.se.fit    <dbl> 0.2834589, 0.2692993, 0.2557942, 0.2429439, 0.2307… #> $ incidence.0.025     <dbl> 3.066143, 3.101097, 3.124179, 3.138078, 3.145633, … #> $ incidence.0.05      <dbl> 3.352617, 3.375741, 3.386426, 3.387745, 3.382876, … #> $ incidence.0.25      <dbl> 4.414080, 4.383876, 4.340496, 4.288378, 4.231837, … #> $ incidence.0.5       <dbl> 5.344081, 5.257065, 5.157847, 5.051937, 4.944489, … #> $ incidence.0.75      <dbl> 6.470023, 6.304177, 6.129111, 5.951450, 5.777153, … #> $ incidence.0.95      <dbl> 8.518480, 8.186862, 7.855888, 7.533643, 7.226977, … #> $ incidence.0.975     <dbl> 9.314374, 8.911920, 8.515318, 8.133025, 7.772035, … #> $ growth.fit          <dbl> -0.014783887, -0.014465898, -0.013602786, -0.01233… #> $ growth.se.fit       <dbl> 0.01678017, 0.01670875, 0.01655455, 0.01633873, 0.… #> $ growth.0.025        <dbl> -0.047672415, -0.047214451, -0.046049112, -0.04435… #> $ growth.0.05         <dbl> -0.042384810, -0.041949350, -0.040832601, -0.03920… #> $ growth.0.25         <dbl> -0.026101939, -0.025735780, -0.024768662, -0.02335… #> $ growth.0.5          <dbl> -0.014783887, -0.014465898, -0.013602786, -0.01233… #> $ growth.0.75         <dbl> -3.465834e-03, -3.196016e-03, -2.436910e-03, -1.31… #> $ growth.0.95         <dbl> 0.01281704, 0.01301755, 0.01362703, 0.01454398, 0.… #> $ growth.0.975        <dbl> 0.01810464, 0.01828265, 0.01884354, 0.01969249, 0.… #> $ doubling_time.0.5   <dbl> -46.885315, -47.915945, -50.956267, -56.212528, -6… #> $ doubling_time.0.025 <dbl> 38.285607, 37.912830, 36.784339, 35.198562, 33.429… #> $ doubling_time.0.975 <dbl> -14.53980, -14.68083, -15.05235, -15.62756, -16.38…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/du_serial_interval_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"The Du empirical serial interval dataset — du_serial_interval_ip","title":"The Du empirical serial interval dataset — du_serial_interval_ip","text":"Z. Du, X. Xu, Y. Wu, L. Wang, B. J. Cowling, L. . Meyers, ‘Serial Interval COVID-19 among Publicly Reported Confirmed Cases’, Emerg Infect Dis, vol. 26, . 6, pp. 1341–1343, Jun. 2020, doi: 10.3201/eid2606.200357.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/du_serial_interval_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Du empirical serial interval dataset — du_serial_interval_ip","text":"","code":"data(du_serial_interval_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/du_serial_interval_ip.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The Du empirical serial interval dataset — du_serial_interval_ip","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 2603 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge distribution — dwedge","title":"Wedge distribution — dwedge","text":"wedge distribution domain 0 1 linear probability density function domain.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wedge distribution — dwedge","text":"","code":"dwedge(x, a, lower.tail = TRUE, log = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge distribution — dwedge","text":"x vector quantiles gradient -2 (left skewed) 2 (right skewed) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge distribution — dwedge","text":"vector probabilities, quantiles, densities samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge distribution — dwedge","text":"rwedge can combined quantile functions skew standard distributions, introduce correlation weight certain parts distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/dwedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge distribution — dwedge","text":"","code":"pwedge(seq(0,1,0.1), a=1) #>  [1] 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 dwedge(seq(0,1,0.1), a=1) #>  [1] 0.000 0.055 0.120 0.195 0.280 0.375 0.480 0.595 0.720 0.855 1.000 qwedge(c(0.25,0.5,0.75), a=-1) #> [1] 0.1771243 0.3819660 0.6339746  stats::cor(   stats::qnorm(rwedge(1000, a=2)),   stats::qnorm(rwedge(1000, a=-2)) ) #> [1] 0.0007035295"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_growth_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"The SPI-M-O England consensus growth rate — england_consensus_growth_rate","title":"The SPI-M-O England consensus growth rate — england_consensus_growth_rate","text":"SPI-M-O used range different statistical mechanistic models produce estimates growth rate epidemic various data sources (including early version ggoutbreak).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_growth_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The SPI-M-O England consensus growth rate — england_consensus_growth_rate","text":"","code":"data(england_consensus_growth_rate)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_growth_rate.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The SPI-M-O England consensus growth rate — england_consensus_growth_rate","text":"dataframe containing following columns: date (date) - date estimate low (numeric) - lower published estimate growth rate high (numeric) - higher published estimate growth rate mandatory groupings. default value. 111 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"The SPI-M-O England consensus reproduction number — england_consensus_rt","title":"The SPI-M-O England consensus reproduction number — england_consensus_rt","text":"SPI-M-O used range different statistical mechanistic models produce estimates  reproduction number epidemic various data sources.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The SPI-M-O England consensus reproduction number — england_consensus_rt","text":"","code":"data(england_consensus_rt)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_consensus_rt.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The SPI-M-O England consensus reproduction number — england_consensus_rt","text":"dataframe containing following columns: date (date) - date estimate low (numeric) - lower published estimate reproduction number high (numeric) - higher published estimate reproduction number mandatory groupings. default value. 113 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid.html","id":null,"dir":"Reference","previous_headings":"","what":"Daily COVID-19 case counts by age group in England — england_covid","title":"Daily COVID-19 case counts by age group in England — england_covid","text":"dataset daily count COVID-19 cases age group England downloaded UKHSA coronavirus API, formatted use ggoutbreak. denominator calculated overall positive count age groups. data set can used calculate group-wise incidence absolute growth rates group wise proportions relative growth rates age group.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Daily COVID-19 case counts by age group in England — england_covid","text":"","code":"data(england_covid)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Daily COVID-19 case counts by age group in England — england_covid","text":"dataframe containing following columns: date (.Date) - date column class (enum(00_04,05_09,10_14,15_19,20_24,25_29,30_34,35_39,40_44,45_49,50_54,55_59,60_64,65_69,70_74,75_79,80_84,85_89,90+)) - class column count (numeric) - test positives age group denom (numeric) - test positives across age groups time (time_period) - time column Must grouped : class (groupings allowed). default value. 26790 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Daily COVID-19 case counts by age group in England — england_covid","text":"may want england_covid_test_positives instead includes population denominator. denominator total number positive tests across age groups number tests taken population size.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_pcr_positivity.html","id":null,"dir":"Reference","previous_headings":"","what":"England COVID-19 PCR test positivity — england_covid_pcr_positivity","title":"England COVID-19 PCR test positivity — england_covid_pcr_positivity","text":"coronavirus.gov.uk dashboard published tests conducted positive results separate data sets range geographies. case data combined testing rate denominator, test positives count whole England.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_pcr_positivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"England COVID-19 PCR test positivity — england_covid_pcr_positivity","text":"","code":"data(england_covid_pcr_positivity)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_pcr_positivity.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"England COVID-19 PCR test positivity — england_covid_pcr_positivity","text":"dataframe containing following columns: date (date) - daily time series time (time_period) - time column count (numeric) - test positives England day denom (numeric) - total tests conducted day mandatory groupings. default value. 1413 rows 4 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"The England COVID-19 poisson model dataset — england_covid_poisson","title":"The England COVID-19 poisson model dataset — england_covid_poisson","text":"output following estimator, speed examples:","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The England COVID-19 poisson model dataset — england_covid_poisson","text":"","code":"data(england_covid_poisson)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The England COVID-19 poisson model dataset — england_covid_poisson","text":"dataframe containing following columns: time (.time_period) - time column incidence.fit (numeric) - incidence.fit column incidence.se.fit (numeric) - incidence.se.fit column incidence.0.025 (numeric) - incidence.0.025 column incidence.0.05 (numeric) - incidence.0.05 column incidence.0.25 (numeric) - incidence.0.25 column incidence.0.5 (numeric) - incidence.0.5 column incidence.0.75 (numeric) - incidence.0.75 column incidence.0.95 (numeric) - incidence.0.95 column incidence.0.975 (numeric) - incidence.0.975 column growth.fit (numeric) - growth.fit column growth.se.fit (numeric) - growth.se.fit column growth.0.025 (numeric) - growth.0.025 column growth.0.05 (numeric) - growth.0.05 column growth.0.25 (numeric) - growth.0.25 column growth.0.5 (numeric) - growth.0.5 column growth.0.75 (numeric) - growth.0.75 column growth.0.95 (numeric) - growth.0.95 column growth.0.975 (numeric) - growth.0.975 column grouping allowed. 1410 rows 19 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The England COVID-19 poisson model dataset — england_covid_poisson","text":"","code":"england_covid %>% time_aggregate() %>% ggoutbreak::poisson_locfit_model(window=14)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson_age_stratified.html","id":null,"dir":"Reference","previous_headings":"","what":"The England COVID-19 age stratified poisson model dataset — england_covid_poisson_age_stratified","title":"The England COVID-19 age stratified poisson model dataset — england_covid_poisson_age_stratified","text":"output following estimator, speed examples:","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson_age_stratified.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The England COVID-19 age stratified poisson model dataset — england_covid_poisson_age_stratified","text":"","code":"data(england_covid_poisson_age_stratified)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson_age_stratified.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The England COVID-19 age stratified poisson model dataset — england_covid_poisson_age_stratified","text":"dataframe containing following columns: class (enum(00_04,05_09,10_14,15_19,20_24,25_29,30_34,35_39,40_44,45_49,50_54,55_59,60_64,65_69,70_74,75_79,80_84,85_89,90+)) - class column time (.time_period) - time column incidence.fit (numeric) - incidence.fit column incidence.se.fit (numeric) - incidence.se.fit column incidence.0.025 (numeric) - incidence.0.025 column incidence.0.05 (numeric) - incidence.0.05 column incidence.0.25 (numeric) - incidence.0.25 column incidence.0.5 (numeric) - incidence.0.5 column incidence.0.75 (numeric) - incidence.0.75 column incidence.0.95 (numeric) - incidence.0.95 column incidence.0.975 (numeric) - incidence.0.975 column growth.fit (numeric) - growth.fit column growth.se.fit (numeric) - growth.se.fit column growth.0.025 (numeric) - growth.0.025 column growth.0.05 (numeric) - growth.0.05 column growth.0.25 (numeric) - growth.0.25 column growth.0.5 (numeric) - growth.0.5 column growth.0.75 (numeric) - growth.0.75 column growth.0.95 (numeric) - growth.0.95 column growth.0.975 (numeric) - growth.0.975 column Minimally grouped : class (groupings allowed). 26790 rows 20 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_poisson_age_stratified.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The England COVID-19 age stratified poisson model dataset — england_covid_poisson_age_stratified","text":"","code":"england_covid %>% ggoutbreak::poisson_locfit_model(window=14)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion.html","id":null,"dir":"Reference","previous_headings":"","what":"England COVID by age group for ascertainment — england_covid_proportion","title":"England COVID by age group for ascertainment — england_covid_proportion","text":"age group stratified dataset ","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"England COVID by age group for ascertainment — england_covid_proportion","text":"","code":"data(england_covid_proportion)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"England COVID by age group for ascertainment — england_covid_proportion","text":"dataframe containing following columns: class (character) - age group date (date) - start date week count (numeric) - count COVID positives denom (numeric) - number COVID tests performed population (numeric) - size population age group time (time_period) - time column (weekly) Must grouped : class (groupings allowed). default value. 1050 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"England COVID by age group for ascertainment — england_covid_proportion","text":"coronavirus.gov.uk site positive cases aggregated 10 year age groups weekly time. NHS test trace date reported regional age group testing effort aggregated country level. ONS 2021 census population aggregated 10 year age groups.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion_age_stratified.html","id":null,"dir":"Reference","previous_headings":"","what":"The England COVID-19 age stratified proportion model dataset — england_covid_proportion_age_stratified","title":"The England COVID-19 age stratified proportion model dataset — england_covid_proportion_age_stratified","text":"output following estimator, speed examples. proportion represented positive tests age group, versus positive tests age groups. considered respect overall population.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion_age_stratified.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The England COVID-19 age stratified proportion model dataset — england_covid_proportion_age_stratified","text":"","code":"data(england_covid_proportion_age_stratified)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion_age_stratified.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The England COVID-19 age stratified proportion model dataset — england_covid_proportion_age_stratified","text":"dataframe containing following columns: class (enum(00_04,05_09,10_14,15_19,20_24,25_29,30_34,35_39,40_44,45_49,50_54,55_59,60_64,65_69,70_74,75_79,80_84,85_89,90+)) - class column time (.time_period) - time column proportion.fit (numeric) - proportion.fit column proportion.se.fit (numeric) - proportion.se.fit column proportion.0.025 (numeric) - proportion.0.025 column proportion.0.05 (numeric) - proportion.0.05 column proportion.0.25 (numeric) - proportion.0.25 column proportion.0.5 (numeric) - proportion.0.5 column proportion.0.75 (numeric) - proportion.0.75 column proportion.0.95 (numeric) - proportion.0.95 column proportion.0.975 (numeric) - proportion.0.975 column relative.growth.fit (numeric) - relative.growth.fit column relative.growth.se.fit (numeric) - relative.growth.se.fit column relative.growth.0.025 (numeric) - relative.growth.0.025 column relative.growth.0.05 (numeric) - relative.growth.0.05 column relative.growth.0.25 (numeric) - relative.growth.0.25 column relative.growth.0.5 (numeric) - relative.growth.0.5 column relative.growth.0.75 (numeric) - relative.growth.0.75 column relative.growth.0.95 (numeric) - relative.growth.0.95 column relative.growth.0.975 (numeric) - relative.growth.0.975 column Minimally grouped : class (groupings allowed). 26790 rows 20 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_proportion_age_stratified.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The England COVID-19 age stratified proportion model dataset — england_covid_proportion_age_stratified","text":"","code":"england_covid %>% ggoutbreak::proportion_locfit_model(window=14)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_test_positives.html","id":null,"dir":"Reference","previous_headings":"","what":"Weekly England COVID test positives by age group including testing effort — england_covid_test_positives","title":"Weekly England COVID test positives by age group including testing effort — england_covid_test_positives","text":"age group stratified dataset ","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_test_positives.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weekly England COVID test positives by age group including testing effort — england_covid_test_positives","text":"","code":"data(england_covid_test_positives)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_test_positives.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Weekly England COVID test positives by age group including testing effort — england_covid_test_positives","text":"dataframe containing following columns: class (character) - age group date (date) - start date week count (numeric) - count COVID positives denom (numeric) - number COVID tests performed age group week population (numeric) - size population age group time (time_period) - time column (weekly) Must grouped : class (groupings allowed). default value. 1050 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_covid_test_positives.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weekly England COVID test positives by age group including testing effort — england_covid_test_positives","text":"coronavirus.gov.uk site positive cases aggregated 10 year age groups weekly time. NHS test trace date reported regional age group testing effort aggregated country level. ONS 2021 census population aggregated 10 year age groups.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_demographics.html","id":null,"dir":"Reference","previous_headings":"","what":"England demographics — england_demographics","title":"England demographics — england_demographics","text":"Population counts 5 year age group England 2021 census.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_demographics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"England demographics — england_demographics","text":"","code":"data(england_demographics)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_demographics.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"England demographics — england_demographics","text":"dataframe containing following columns: class (enum(00_04,05_09,10_14,15_19,20_24,25_29,30_34,35_39,40_44,45_49,50_54,55_59,60_64,65_69,70_74,75_79,80_84,85_89,90+)) - class column population (numeric) - population count column baseline_proportion (numeric) - baseline proportion proportion age group makes total. Must grouped : class (groupings allowed). default value. 19 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_demographics.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"England demographics — england_demographics","text":"https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationandhouseholdestimatesenglandandwalescensus2021/census2021/census2021firstresultsenglandwales1.xlsx","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Key dated in the COVID-19 response in England — england_events","title":"Key dated in the COVID-19 response in England — england_events","text":"includes mainly dates lockdowns, releases social distancing measures dates new variants first detected.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Key dated in the COVID-19 response in England — england_events","text":"","code":"data(england_events)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_events.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Key dated in the COVID-19 response in England — england_events","text":"dataframe containing following columns: label (character) - event label start (date) - event start date end (date) - (optional) event end date mandatory groupings. default value. 13 rows 3 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_nhs_app.html","id":null,"dir":"Reference","previous_headings":"","what":"NHS COVID-19 app data — england_nhs_app","title":"NHS COVID-19 app data — england_nhs_app","text":"check-(social activity) alerts (self isolation instruction) data NHS COVID-19 app, aggregated country level week week basis.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_nhs_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NHS COVID-19 app data — england_nhs_app","text":"","code":"data(england_nhs_app)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_nhs_app.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"NHS COVID-19 app data — england_nhs_app","text":"dataframe containing following columns: date (date) - start date week alerts (integer) - count self-isolation alerts visits (integer) - number venue check-ins representing visits social venues. time (time_period) - time column mandatory groupings. default value. 137 rows 4 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_ons_infection_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"The england_ons_infection_survey dataset — england_ons_infection_survey","title":"The england_ons_infection_survey dataset — england_ons_infection_survey","text":"COVID-19 ONS infection survey took random sample population provides estimate prevalence COVID-19 supposedly free ascertainment bias.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_ons_infection_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The england_ons_infection_survey dataset — england_ons_infection_survey","text":"","code":"data(england_ons_infection_survey)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_ons_infection_survey.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The england_ons_infection_survey dataset — england_ons_infection_survey","text":"dataframe containing following columns: date (date) - date column geography (character) - geography column prevalence.0.5 (numeric) - median proportion people region testing positive COVID-19 prevalence.0.025 (numeric) - lower CI proportion people region testing positive COVID-19 prevalence.0.975 (numeric) - upper CI proportion people region testing positive COVID-19 denom (integer) - sample size estimate made (daily rate inferred weekly sample sizes.) time (time_period) - time column mandatory groupings. default value. 9820 rows 7 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_ons_infection_survey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The england_ons_infection_survey dataset — england_ons_infection_survey","text":"data available : https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/healthandsocialcare/conditionsanddiseases/datasets/coronaviruscovid19infectionsurveydata/2023/20230310covid19infectionsurveydatasetsengland.xlsx","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_variants.html","id":null,"dir":"Reference","previous_headings":"","what":"Counts of COVID-19 variants — england_variants","title":"Counts of COVID-19 variants — england_variants","text":"Data COG-UK Sanger centre sequencing programme. data made available Welcome foundation Lower tier local authority level, weekly time series counts per variant. Variants assigned using tree structure Pango lineage. Different sub-lineages aggregated major variants concern.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_variants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Counts of COVID-19 variants — england_variants","text":"","code":"data(england_variants)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/england_variants.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Counts of COVID-19 variants — england_variants","text":"dataframe containing following columns: date (date) - end date week time (time_period) - time column class (enum(,Alpha (B.1.1.7),Delta (B.1.617.2),Delta (AY.4),Omicron (),Omicron (BA.2),Omicron (BA.4),Omicron (BA.5),XBB (),Kraken (XBB.1.5),Arcturus (XBB.1.16),Eris (EG.5.1))) - class column who_class (enum(,Alpha,Delta,Omicron,Kraken,Arcturus,Eris)) - who_class column count (numeric) - weekly count column denom (numeric) - number sequences performed week Must grouped : class (groupings allowed). default value. 479 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/fdmy.html","id":null,"dir":"Reference","previous_headings":"","what":"Format date as dmy — fdmy","title":"Format date as dmy — fdmy","text":"Format date dmy","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/fdmy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format date as dmy — fdmy","text":"","code":"fdmy(date)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/fdmy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format date as dmy — fdmy","text":"date date convert","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/fdmy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format date as dmy — fdmy","text":"formatted date","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/fdmy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format date as dmy — fdmy","text":"","code":"fdmy(Sys.Date()) #> [1] \"24 Jul 2025\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/format_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a summary of an infectivity profile — format_ip","title":"Print a summary of an infectivity profile — format_ip","text":"Print summary infectivity profile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/format_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a summary of an infectivity profile — format_ip","text":"","code":"format_ip(ip = i_empirical_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/format_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a summary of an infectivity profile — format_ip","text":"ip infectivity profile summarise. a0 a1 columns optional tau given. - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/format_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a summary of an infectivity profile — format_ip","text":"infectivity profile description","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/format_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a summary of an infectivity profile — format_ip","text":"","code":"format_ip(ganyani_ip) #> [1] \"PDF: mean: 5.25 [3.74 — 6.65]; sd: 1.92 [0.705 — 3.19]; 100 bootstraps\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip","text":"COVID-19 infectivity profile based Ganyani et al 2020 Ganyani serial interval dataset, compatible EpiEstim","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip","text":"","code":"data(ganyani_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (double) - time index probability relates (days) a0 - beginning time period a1 - end time period Grouped boot (exactly). dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 2400 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip","text":"https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.17.2000257","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip_2.html","id":null,"dir":"Reference","previous_headings":"","what":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip_2","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip_2","text":"version discretised manner makes incompatible EpiEstim.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip_2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip_2","text":"","code":"data(ganyani_ip_2)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip_2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip_2","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (double) - time index probability relates (days) a0 - beginning time period a1 - end time period Grouped boot (exactly). dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 2800 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ganyani_ip_2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A COVID-19 infectivity profile based on an Ganyani et al 2020 — ganyani_ip_2","text":"https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.17.2000257","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/geom_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Add time series event markers to a time series plot. — geom_events","title":"Add time series event markers to a time series plot. — geom_events","text":"x axis must date.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/geom_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add time series event markers to a time series plot. — geom_events","text":"","code":"geom_events(   events = i_events,   event_label_size = 7,   event_label_colour = \"black\",   event_label_angle = -30,   event_line_colour = \"grey50\",   event_fill_colour = \"grey50\",   hide_labels = FALSE,   guide_axis = ggplot2::derive(),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/geom_events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add time series event markers to a time series plot. — geom_events","text":"events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined. event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/geom_events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add time series event markers to a time series plot. — geom_events","text":"set geoms time series.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_covid.html","id":null,"dir":"Reference","previous_headings":"","what":"Weekly COVID-19 case counts by age group in Germany — germany_covid","title":"Weekly COVID-19 case counts by age group in Germany — germany_covid","text":"dataset weekly count COVID-19 cases age group Germany downloaded Robert Koch Institute Survstat service, formatted use growth rates. denominator calculated overall positive count age groups. data set can used calculate group-wise incidence absolute growth rates group wise proportions relative growth rates.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_covid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weekly COVID-19 case counts by age group in Germany — germany_covid","text":"","code":"data(germany_covid)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_covid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Weekly COVID-19 case counts by age group in Germany — germany_covid","text":"dataframe containing following columns: class (enum(0–14,15–19,20–24,25–29,30–39,40–49,50–59,60–69,70–79,80+,Unknown, .ordered=TRUE)) - age group date (.Date) - date column count (integer) - test positives age group time (time_period) - time column denom (integer) - test positives age groups Must grouped : class (groupings allowed). default value. 2070 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_demographics.html","id":null,"dir":"Reference","previous_headings":"","what":"Germany demographics — germany_demographics","title":"Germany demographics — germany_demographics","text":"Derived Robert Koch Survstat service comparing counts incidence rates.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_demographics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Germany demographics — germany_demographics","text":"","code":"data(germany_demographics)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/germany_demographics.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Germany demographics — germany_demographics","text":"dataframe containing following columns: class (enum(0–14,15–19,20–24,25–29,30–39,40–49,50–59,60–69,70–79,80+, .ordered=TRUE)) - class column population (integer) - population column Must grouped : class (groupings allowed). default value. 10 rows 2 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ggoutbreak-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ggoutbreak: Estimate Incidence, Proportions and Exponential Growth Rates — ggoutbreak-package","title":"ggoutbreak: Estimate Incidence, Proportions and Exponential Growth Rates — ggoutbreak-package","text":"Simple statistical models visualisations calculating incidence, proportion, exponential growth rate, reproduction number infectious disease case time series. toolkit largely developed COVID-19 pandemic.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/ggoutbreak-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ggoutbreak: Estimate Incidence, Proportions and Exponential Growth Rates — ggoutbreak-package","text":"Maintainer: Robert Challen rob.challen@bristol.ac.uk (ORCID) [copyright holder]","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/grapes-above-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert a layer at the bottom of a ggplot — %above%","title":"Insert a layer at the bottom of a ggplot — %above%","text":"Insert layer bottom ggplot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/grapes-above-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert a layer at the bottom of a ggplot — %above%","text":"","code":"plot %above% layer"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/grapes-above-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert a layer at the bottom of a ggplot — %above%","text":"plot plot add layer layer layer insert underneath plot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/grapes-above-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert a layer at the bottom of a ggplot — %above%","text":"ggplot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_population.html","id":null,"dir":"Reference","previous_headings":"","what":"Infers a daily baseline population for a timeseries — infer_population","title":"Infers a daily baseline population for a timeseries — infer_population","text":"function augments timeseries population denominator. population data may static estimates, set estimates time points. population data may grouped case grouping might geographical area age group gender example. two inputs must compatible grouping (.e. groups population data must present timeseries).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_population.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infers a daily baseline population for a timeseries — infer_population","text":"","code":"infer_population(df = i_timeseries, pop = i_population_data)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_population.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infers a daily baseline population for a timeseries — infer_population","text":"df time series, grouped collection time series. - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. pop population data must grouped way df. might also time column time_period population static - dataframe columns: population (positive_integer) - Size population grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_population.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infers a daily baseline population for a timeseries — infer_population","text":"df timeseries additional population column","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_population.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infers a daily baseline population for a timeseries — infer_population","text":"","code":"ggoutbreak::england_covid %>%   ggoutbreak::infer_population(ggoutbreak::england_demographics) %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 6 #> Groups: class [19] #> $ date       <date> 2023-12-09, 2023-12-09, 2023-12-09, 2023-12-09, 2023-12-09… #> $ class      <fct> 00_04, 05_09, 10_14, 15_19, 20_24, 25_29, 30_34, 35_39, 40_… #> $ count      <dbl> 24, 8, 8, 4, 21, 20, 29, 36, 41, 59, 53, 54, 56, 54, 67, 72… #> $ denom      <dbl> 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771,… #> $ time       <time_prd> 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409, … #> $ population <int> 3077000, 3348600, 3413100, 3218900, 3414400, 3715400, 39526…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_prevalence.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","title":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","text":"Log-scaled incidence estimates used generate samples incidence. convolved infectivity profile (set discrete distributions) result evaluated fraction population. result fitted logit-normal (using moments) quantiles produced samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_prevalence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","text":"","code":"infer_prevalence(   modelled = i_incidence_model,   pop = i_population_data,   ip = i_discrete_ip,   bootstraps = 1000,   seed = Sys.time(),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_prevalence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","text":"modelled Model output processing raw dataframe something like poission_locfit_model - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. pop population data must grouped way modelled. - dataframe columns: population (positive_integer) - Size population grouping allowed. ip discrete distribution representing probability detection disease given day infection. necessarily sum one, entry exceed asymptomatic fraction. - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. tau (integer + complete) - days since index event. Minimally grouped : boot (groupings allowed). default value defined. bootstraps number samples take time point. rounded whole multiple infectivity profile distribution length. seed random number seed reproducibility ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_prevalence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","text":"modelled input additional proportion columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_prevalence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infer the prevalence of disease from incidence estimates and population size. — infer_prevalence","text":"","code":"tmp = ggoutbreak::test_poisson_rt_smooth %>%   ggoutbreak::poisson_locfit_model(window=14) %>%   ggoutbreak::infer_prevalence(      pop = 10000,      ip = ggoutbreak::test_ip   )  if(interactive()) {   plot_prevalence(tmp) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_rate_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a risk ratio from incidence — infer_rate_ratio","title":"Calculate a risk ratio from incidence — infer_rate_ratio","text":"enables incidence rates able compared baseline figure incidence. baseline come example population average average incidence time. output incidence rate ratio. incidence_baseline column rate events per unit time. time unit expected date modelled checked.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_rate_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a risk ratio from incidence — infer_rate_ratio","text":"","code":"infer_rate_ratio(   modelled = i_incidence_model,   base = i_baseline_incidence_data,   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_rate_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a risk ratio from incidence — infer_rate_ratio","text":"modelled Model output something like poisson_locfit_model(). really makes sense grouped model. - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. base baseline data must grouped way modelled. may time series . See example note may change future. - dataframe columns: baseline_incidence (positive_double) - Baseline raw incidence rate count data grouping allowed. ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_rate_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a risk ratio from incidence — infer_rate_ratio","text":"dataframe incidence rate ratios classes modelled. dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rate_ratio.0.025 (positive_double) - lower confidence limit rate ratio population group rate_ratio.0.5 (positive_double) - median estimate rate ratio population group rate_ratio.0.975 (positive_double) - upper confidence limit rate ratio population group grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_rate_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a risk ratio from incidence — infer_rate_ratio","text":"","code":"baseline = ggoutbreak::england_covid_poisson %>%   dplyr::mutate(baseline_incidence = incidence.0.5)   tmp = ggoutbreak::england_covid_poisson_age_stratified %>%   ggoutbreak::infer_rate_ratio(baseline) %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 24 #> Groups: class [19] #> $ class              <fct> 00_04, 00_04, 00_04, 00_04, 00_04, 00_04, 00_04, 00… #> $ time               <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, … #> $ incidence.fit      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, -97… #> $ incidence.se.fit   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.025    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.05     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.25     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.5      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.75     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.95     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ incidence.0.975    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.fit         <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.se.fit      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.025       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.05        <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.25        <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.5         <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.75        <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.95        <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ growth.0.975       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ baseline_incidence <dbl> 3.1078399, 2.8905742, 2.6931935, 2.5110697, 2.34049… #> $ rate_ratio.0.025   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ rate_ratio.0.5     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0… #> $ rate_ratio.0.975   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.0…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_risk_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","title":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","text":"assumes example, case distribution proportions stratified population grouping, e.g. geography age, estimates size population time period. Normalising population proportion allows us compare relative risk outcome groups, compared expected population risk outcome evenly distributed across population. may proportions population fractions may useful compare. moment handle uncertainty.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_risk_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","text":"","code":"infer_risk_ratio(   modelled = i_proportion_model,   base = i_baseline_proportion_data,   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_risk_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","text":"modelled Model output something like proportion_locfit_model() - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) grouping allowed. base baseline data must grouped way modelled. may time series . - dataframe columns: baseline_proportion (proportion) - Baseline proportion comparison grouping allowed. ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_risk_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","text":"dataframe relative risk / risk ratio columns. dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period risk_ratio.0.025 (positive_double) - lower confidence limit excess risk ratio population group risk_ratio.0.5 (positive_double) - median estimate excess risk ratio population group risk_ratio.0.975 (positive_double) - upper confidence limit excess risk ratio population group grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/infer_risk_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a normalised risk ratio from proportions — infer_risk_ratio","text":"","code":"tmp = ggoutbreak::england_covid_proportion_age_stratified  %>%   ggoutbreak::infer_risk_ratio(ggoutbreak::england_demographics) %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 24 #> Groups: class [19] #> $ class                  <fct> 00_04, 00_04, 00_04, 00_04, 00_04, 00_04, 00_04… #> $ time                   <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, … #> $ proportion.fit         <dbl> -1000.00000, -1000.00000, -1000.00000, -1000.00… #> $ proportion.se.fit      <dbl> 0.01129143, 0.01127551, 0.01125958, 0.01124366,… #> $ proportion.0.025       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.05        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.25        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.5         <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.75        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.95        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.975       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ relative.growth.fit    <dbl> 0.00000000, 0.00000000, 0.00000000, 0.00000000,… #> $ relative.growth.se.fit <dbl> 1.626352e-05, 1.626352e-05, 1.626352e-05, 1.626… #> $ relative.growth.0.025  <dbl> -3.187591e-05, -3.187591e-05, -3.187591e-05, -3… #> $ relative.growth.0.05   <dbl> -2.675111e-05, -2.675111e-05, -2.675111e-05, -2… #> $ relative.growth.0.25   <dbl> -1.096958e-05, -1.096958e-05, -1.096958e-05, -1… #> $ relative.growth.0.5    <dbl> 0.00000000, 0.00000000, 0.00000000, 0.00000000,… #> $ relative.growth.0.75   <dbl> 1.096958e-05, 1.096958e-05, 1.096958e-05, 1.096… #> $ relative.growth.0.95   <dbl> 2.675111e-05, 2.675111e-05, 2.675111e-05, 2.675… #> $ relative.growth.0.975  <dbl> 3.187591e-05, 3.187591e-05, 3.187591e-05, 3.187… #> $ baseline_proportion    <dbl> 0.05447011, 0.05447011, 0.05447011, 0.05447011,… #> $ risk_ratio.0.025       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ risk_ratio.0.5         <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ risk_ratio.0.975       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000…  if(interactive()) {   plot_growth_phase(tmp,duration = 14*4)+   ggplot2::scale_colour_viridis_d()+   ggplot2::coord_cartesian(xlim=c(-0.25,0.25),ylim=c(0.02,20)) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/integer_breaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Strictly integer breaks for continuous scale — integer_breaks","title":"Strictly integer breaks for continuous scale — integer_breaks","text":"Strictly integer breaks continuous scale","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/integer_breaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Strictly integer breaks for continuous scale — integer_breaks","text":"","code":"integer_breaks(n = 5, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/integer_breaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Strictly integer breaks for continuous scale — integer_breaks","text":"n number breaks ... arguments methods.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/integer_breaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Strictly integer breaks for continuous scale — integer_breaks","text":"ggplot breaks function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"solves relationship $R_t$ growth rates described Wallinga Lipsitch, get growth rate $R_t$ infectivity profile.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"","code":"inv_wallinga_lipsitch(   Rt,   y = i_empirical_ip,   a1 = seq(0.5, length.out = length(y)),   a0 = dplyr::lag(a1, default = 0) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"Rt vector reproduction numbers y empirical infectivity profile probability vector dataframe format: dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined. a1 end time infectivity profile probability estimate (defaults 0.5,1.5,2.5,...). a0 start time infectivity profile probability estimate (defaults 0,0.5,1.5,...).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"vector growth rates","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"function uses single empirical distribution infectivity profile / generation time. multiple provided average central value chosen (.e. propagate uncertainty infectivity profile)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/inv_wallinga_lipsitch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a growth rate from a reproduction number and an infectivity profile, — inv_wallinga_lipsitch","text":"","code":"inv_wallinga_lipsitch(Rt=seq(0.5,2.5,length.out=9), y=test_ip) #> [1] -0.13029123 -0.05611202  0.00000000  0.04556024  0.08418300  0.11783066 #> [7]  0.14773785  0.17471945  0.19934691"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/is.Date.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether vector is a date — is.Date","title":"Check whether vector is a date — is.Date","text":"Check whether vector date","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/is.Date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether vector is a date — is.Date","text":"","code":"is.Date(x)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/is.Date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether vector is a date — is.Date","text":"x vector check","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/is.Date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether vector is a date — is.Date","text":"TRUE dates, FALSE otherwise","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/is.Date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check whether vector is a date — is.Date","text":"","code":"is.Date(Sys.Date()) #> [1] TRUE"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parts of a POSIXt or Date Object — julian.time_period","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"Extract weekday, month quarter, Julian time   (days since origin).  generic functions: methods   internal date-time classes documented .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"","code":"# S3 method for class 'time_period' julian(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"x object inheriting class \"POSIXt\" \"Date\". ... arguments methods.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"weekdays months return character   vector names locale use, .e., Sys.getlocale(\"LC_TIME\"). quarters returns character vector \"Q1\"   \"Q4\". julian returns number days (possibly fractional)   since origin, origin \"origin\" attribute.   time calculations R done ignoring leap-seconds.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"components day month year   easy compute: just use .POSIXlt extract   relevant component.  Alternatively (especially components   desired character strings), use strftime.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/julian.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Parts of a POSIXt or Date Object — julian.time_period","text":"","code":"## first two are locale dependent: weekdays(.leap.seconds) #>  [1] \"Saturday\"  \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Saturday\"  #>  [7] \"Sunday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"    #> [13] \"Monday\"    \"Friday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  #> [19] \"Friday\"    \"Monday\"    \"Tuesday\"   \"Friday\"    \"Sunday\"    \"Thursday\"  #> [25] \"Sunday\"    \"Wednesday\" \"Sunday\"    months  (.leap.seconds) #>  [1] \"July\"    \"January\" \"January\" \"January\" \"January\" \"January\" \"January\" #>  [8] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"July\"    \"January\" #> [15] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"January\" \"July\"    #> [22] \"January\" \"January\" \"January\" \"July\"    \"July\"    \"January\" quarters(.leap.seconds) #>  [1] \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q1\" #> [16] \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q1\"  ## Show how easily you get month, day, year, day (of {month, week, yr}), ... : ## (remember to count from 0 (!): mon = 0..11, wday = 0..6,  etc !!)  ##' Transform (Time-)Date vector  to  convenient data frame : dt2df <- function(dt, dName = deparse(substitute(dt))) {     DF <- as.data.frame(unclass(as.POSIXlt( dt )))     `names<-`(cbind(dt, DF, deparse.level=0L), c(dName, names(DF))) } ## e.g., dt2df(.leap.seconds)    # date+time #>    .leap.seconds sec min hour mday mon year wday yday isdst zone gmtoff #> 1     1972-07-01   0   0    0    1   6   72    6  182     0  GMT      0 #> 2     1973-01-01   0   0    0    1   0   73    1    0     0  GMT      0 #> 3     1974-01-01   0   0    0    1   0   74    2    0     0  GMT      0 #> 4     1975-01-01   0   0    0    1   0   75    3    0     0  GMT      0 #> 5     1976-01-01   0   0    0    1   0   76    4    0     0  GMT      0 #> 6     1977-01-01   0   0    0    1   0   77    6    0     0  GMT      0 #> 7     1978-01-01   0   0    0    1   0   78    0    0     0  GMT      0 #> 8     1979-01-01   0   0    0    1   0   79    1    0     0  GMT      0 #> 9     1980-01-01   0   0    0    1   0   80    2    0     0  GMT      0 #> 10    1981-07-01   0   0    0    1   6   81    3  181     0  GMT      0 #> 11    1982-07-01   0   0    0    1   6   82    4  181     0  GMT      0 #> 12    1983-07-01   0   0    0    1   6   83    5  181     0  GMT      0 #> 13    1985-07-01   0   0    0    1   6   85    1  181     0  GMT      0 #> 14    1988-01-01   0   0    0    1   0   88    5    0     0  GMT      0 #> 15    1990-01-01   0   0    0    1   0   90    1    0     0  GMT      0 #> 16    1991-01-01   0   0    0    1   0   91    2    0     0  GMT      0 #> 17    1992-07-01   0   0    0    1   6   92    3  182     0  GMT      0 #> 18    1993-07-01   0   0    0    1   6   93    4  181     0  GMT      0 #> 19    1994-07-01   0   0    0    1   6   94    5  181     0  GMT      0 #> 20    1996-01-01   0   0    0    1   0   96    1    0     0  GMT      0 #> 21    1997-07-01   0   0    0    1   6   97    2  181     0  GMT      0 #> 22    1999-01-01   0   0    0    1   0   99    5    0     0  GMT      0 #> 23    2006-01-01   0   0    0    1   0  106    0    0     0  GMT      0 #> 24    2009-01-01   0   0    0    1   0  109    4    0     0  GMT      0 #> 25    2012-07-01   0   0    0    1   6  112    0  182     0  GMT      0 #> 26    2015-07-01   0   0    0    1   6  115    3  181     0  GMT      0 #> 27    2017-01-01   0   0    0    1   0  117    0    0     0  GMT      0 dt2df(Sys.Date() + 0:9) # date #>    Sys.Date() + 0:9 sec min hour mday mon year wday yday isdst zone gmtoff #> 1        2025-07-24   0   0    0   24   6  125    4  204     0  UTC      0 #> 2        2025-07-25   0   0    0   25   6  125    5  205     0  UTC      0 #> 3        2025-07-26   0   0    0   26   6  125    6  206     0  UTC      0 #> 4        2025-07-27   0   0    0   27   6  125    0  207     0  UTC      0 #> 5        2025-07-28   0   0    0   28   6  125    1  208     0  UTC      0 #> 6        2025-07-29   0   0    0   29   6  125    2  209     0  UTC      0 #> 7        2025-07-30   0   0    0   30   6  125    3  210     0  UTC      0 #> 8        2025-07-31   0   0    0   31   6  125    4  211     0  UTC      0 #> 9        2025-08-01   0   0    0    1   7  125    5  212     0  UTC      0 #> 10       2025-08-02   0   0    0    2   7  125    6  213     0  UTC      0  ##' Even simpler:  Date -> Matrix - dropping time info {sec,min,hour, isdst} d2mat <- function(x) simplify2array(unclass(as.POSIXlt(x))[4:7]) ## e.g., d2mat(seq(as.Date(\"2000-02-02\"), by=1, length.out=30)) # has R 1.0.0's release date #>       mday mon year wday #>  [1,]    2   1  100    3 #>  [2,]    3   1  100    4 #>  [3,]    4   1  100    5 #>  [4,]    5   1  100    6 #>  [5,]    6   1  100    0 #>  [6,]    7   1  100    1 #>  [7,]    8   1  100    2 #>  [8,]    9   1  100    3 #>  [9,]   10   1  100    4 #> [10,]   11   1  100    5 #> [11,]   12   1  100    6 #> [12,]   13   1  100    0 #> [13,]   14   1  100    1 #> [14,]   15   1  100    2 #> [15,]   16   1  100    3 #> [16,]   17   1  100    4 #> [17,]   18   1  100    5 #> [18,]   19   1  100    6 #> [19,]   20   1  100    0 #> [20,]   21   1  100    1 #> [21,]   22   1  100    2 #> [22,]   23   1  100    3 #> [23,]   24   1  100    4 #> [24,]   25   1  100    5 #> [25,]   26   1  100    6 #> [26,]   27   1  100    0 #> [27,]   28   1  100    1 #> [28,]   29   1  100    2 #> [29,]    1   2  100    3 #> [30,]    2   2  100    4  # \\donttest{ ## Julian Day Number (JDN, https://en.wikipedia.org/wiki/Julian_day) ## is the number of days since noon UTC on the first day of 4317 BCE. ## in the proleptic Julian calendar.  To more recently, in ## 'Terrestrial Time' which differs from UTC by a few seconds ## See https://en.wikipedia.org/wiki/Terrestrial_Time julian(Sys.Date(), -2440588) # from a day #> [1] 2460881 #> attr(,\"origin\") #> [1] -2440588 floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time #> [1] 2460881 # }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/labels.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Label a time period — labels.time_period","title":"Label a time period — labels.time_period","text":"Create set labels time period based start duration period. format configurable using start end dates dfmt ifmt parameters, however time period names used preference.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/labels.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label a time period — labels.time_period","text":"","code":"# S3 method for class 'time_period' labels(   object,   ...,   dfmt = \"%d/%b\",   ifmt = \"{start} — {end}\",   na.value = \"Unknown\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/labels.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label a time period — labels.time_period","text":"object set decimal times time_period ... used dfmt strptime format specification format date ifmt glue spec referring start end period formatted date na.value label NA times","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/labels.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label a time period — labels.time_period","text":"set character labels time","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/labels.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label a time period — labels.time_period","text":"","code":"eg = as.time_period(Sys.Date()+0:10*7, anchor=\"start\") #> No unit given. Guessing a sensible value from the dates gives: 7d 0H 0M 0S labels(eg) #> 24/Jul — 30/Jul #> 31/Jul — 06/Aug #> 07/Aug — 13/Aug #> 14/Aug — 20/Aug #> 21/Aug — 27/Aug #> 28/Aug — 03/Sep #> 04/Sep — 10/Sep #> 11/Sep — 17/Sep #> 18/Sep — 24/Sep #> 25/Sep — 01/Oct #> 02/Oct — 08/Oct labels(eg, ifmt=\"{start}\", dfmt=\"%d/%b/%y\") #> 24/Jul/25 #> 31/Jul/25 #> 07/Aug/25 #> 14/Aug/25 #> 21/Aug/25 #> 28/Aug/25 #> 04/Sep/25 #> 11/Sep/25 #> 18/Sep/25 #> 25/Sep/25 #> 02/Oct/25 labels(eg, ifmt=\"until {end}\", dfmt=\"%d %b %Y\") #> until 30 Jul 2025 #> until 06 Aug 2025 #> until 13 Aug 2025 #> until 20 Aug 2025 #> until 27 Aug 2025 #> until 03 Sep 2025 #> until 10 Sep 2025 #> until 17 Sep 2025 #> until 24 Sep 2025 #> until 01 Oct 2025 #> until 08 Oct 2025  # labels retained in constructor: eg2 = Sys.Date()+0:10*7 names(eg2) = paste0(\"week \",0:10) labels(eg2) #>  [1] \"week 0\"  \"week 1\"  \"week 2\"  \"week 3\"  \"week 4\"  \"week 5\"  \"week 6\"  #>  [8] \"week 7\"  \"week 8\"  \"week 9\"  \"week 10\" labels(as.time_period(eg2, anchor=\"start\")) #>  [1] \"week 0\"  \"week 1\"  \"week 2\"  \"week 3\"  \"week 4\"  \"week 5\"  \"week 6\"  #>  [8] \"week 7\"  \"week 8\"  \"week 9\"  \"week 10\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/logit_trans.html","id":null,"dir":"Reference","previous_headings":"","what":"logit scale — logit_trans","title":"logit scale — logit_trans","text":"Perform logit scaling correct axis formatting. used directly ggplot (e.g. ggplot2::scale_y_continuous(trans = \"logit\") )","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/logit_trans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"logit scale — logit_trans","text":"","code":"logit_trans(n = 5, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/logit_trans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"logit scale — logit_trans","text":"n number breaks ... used, compatibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/logit_trans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"logit scale — logit_trans","text":"scales object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/logit_trans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"logit scale — logit_trans","text":"","code":"library(ggplot2) library(tibble)  tibble::tibble(pvalue = c(0.001, 0.05, 0.1), fold_change = 1:3) %>%  ggplot2::ggplot(aes(fold_change , pvalue)) +  ggplot2::geom_point() +  ggplot2::scale_y_continuous(trans = \"logit\")"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_empirical_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","title":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","text":"Recover long format infectivity profile EpiEstim style matrix","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_empirical_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","text":"","code":"make_empirical_ip(omega, normalise = TRUE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_empirical_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","text":"omega matrix probabilities, starting time zero, columns representing one possible infectivity profile, fist value probability time zero (0.5). Alternatively can vector probabilities one single profile, resulting 1 bootstrap. normalise probability mass function? case make sum equal one (default). FALSE input matrix, vector clipped maximum value one. number PMF scaled value.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_empirical_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","text":"long format ip delay distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_empirical_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recover a long format infectivity profile from an EpiEstim style matrix — make_empirical_ip","text":"","code":"format_ip(make_empirical_ip(c(0,0,1,1,1,2,2,2,1,1))) #> [1] \"mean: 5.64; sd: 2.03\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Make an infectivity profile from published data — make_gamma_ip","title":"Make an infectivity profile from published data — make_gamma_ip","text":"infectivity profile typically fitted data MCMC reported median 95% credible intervals, mean, SD (usually) gamma distribution. function generates discrete infectivity probability distribution representing chance infectee infected specific day infector infected (given infectee infected).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make an infectivity profile from published data — make_gamma_ip","text":"","code":"make_gamma_ip(   median_of_mean,   lower_ci_of_mean = median_of_mean,   upper_ci_of_mean = median_of_mean,   median_of_sd = sqrt(median_of_mean),   lower_ci_of_sd = median_of_sd,   upper_ci_of_sd = median_of_sd,   correlation = NA,   n_boots = 100,   epiestim_compat = FALSE,   epiestim_sampler = epiestim_compat,   z_crit = 0.95 )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make an infectivity profile from published data — make_gamma_ip","text":"median_of_mean, lower_ci_of_mean, upper_ci_of_mean Quantiles infectivity profile mean. median_of_sd, lower_ci_of_sd, upper_ci_of_sd Quantiles infectivity profile SD. correlation correlation mean sd. optional inferred provided. n_boots number samples generate. epiestim_compat Use EpiEstim generate infectivity profiles. true value results infectivity profile probability 0 day 0. false infectivity profile may include density zero even negative values. epiestim_sampler Use EpiEstim generate random samples using independent truncated normal distributions mean SD based parameters . FALSE use log normal distributions correlation. z_crit width confidence intervals (defaults 95%).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make an infectivity profile from published data — make_gamma_ip","text":"long format infectivity profile data frame, list dataframes input vector.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make an infectivity profile from published data — make_gamma_ip","text":"EpiEstim generates distributions sampling truncated normal distribution mean sd. means sds thus produced discretised using gamma distribution offset 1 day, enforce probability infection day zero zero. constraint changes shape distribution somewhat may cause small bias (although ground truth evaluate). function two different sampling discretisation strategy provided. sampler uses log-normal distributions mean SD degree correlation. discretizer assigns probabilities direct CDF gamma distribution without offset. results non zero values probability time zero can used Rt estimation methods can handle zero/negative serial intervals (e.g. rt_from_incidence rt_from_renewal, rt_from_growth_rate). alternative follows EpiEstims algorithm.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_gamma_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make an infectivity profile from published data — make_gamma_ip","text":"","code":"# COVID-19 estimates from Ganyani et al 2020. tmp = make_gamma_ip(5.2, 3.78, 6.78, 1.72, 0.91, 3.93,   epiestim_sampler=FALSE, epiestim_compat=FALSE)  tmp %>%   dplyr::group_by(boot) %>%   dplyr::summarise(     mean = sum(tau*probability),     sd = sqrt(sum((tau-sum(tau*probability))^2*probability))   ) %>%   dplyr::summarise(     mean = sprintf(\"%1.2f [%1.2f-%1.2f]\",       stats::quantile(mean,0.5),       stats::quantile(mean,0.025),       stats::quantile(mean,0.975)),     sd = sprintf(\"%1.2f [%1.2f-%1.2f]\",       stats::quantile(sd,0.5),       stats::quantile(sd,0.025),       stats::quantile(sd,0.975))   ) #> # A tibble: 1 × 2 #>   mean             sd               #>   <chr>            <chr>            #> 1 5.13 [4.01-6.51] 1.86 [0.95-3.83]  if(interactive()) {   plot_ip(tmp, alpha=0.1) +     ggplot2::coord_cartesian(xlim=c(0,15)) }  means = c(3,4,5) ips = make_gamma_ip(means)  if (interactive()) {   purrr::map2(ips,means, ~ .x %>% dplyr::mutate(label = sprintf(\"Mean: %1.2f\",.y))) %>%     purrr::map( ~ plot_ip(.x,alpha=0.1)+ggplot2::facet_wrap(~label)) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Make an infectivity profile from posterior samples — make_posterior_ip","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"infectivity profile typically fitted data MCMC gamma distribution. function generates discrete infectivity probability distribution representing chance infectee infected specific day infector infected (given infectee infected), posterior samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"","code":"make_posterior_ip(   ...,   mean,   sd,   shape,   rate,   scale,   epiestim_compat = FALSE,   n_boots = 100 )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"... used, must empty mean vector gamma distribution means sd vector gamma distribution sds shape vector gamma distribution shape parameters rate vector gamma distribution rate parameters scale vector gamma distribution scale parameters epiestim_compat Use EpiEstim generate infectivity profiles. true value results infectivity profile probability 0 day 0. n_boots posterior samples limit maximum n_boots ip distributions created (randomly sampled).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"long format ip delay distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"using EpiEstim coarseDataTools::dic.fit.mcmc output MCMC S4 object samples slot, containing dataframe shape=var1 scale=var2 columns. use output make_posterior_ip invoke like : .call(make_posterior_ip, SI_fit_clever@samples %>% dplyr::rename(shape=var1, scale=var2)) N.b. one combination mean sd, shape rate, shape scale, required.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_posterior_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make an infectivity profile from posterior samples — make_posterior_ip","text":"","code":"tmp = make_posterior_ip(   mean = stats::rnorm(100,5,0.1),   sd = stats::rnorm(100,1.5,0.1) ) tmp %>% dplyr::glimpse() #> Rows: 1,400 #> Columns: 5 #> Groups: boot [100] #> $ tau         <int> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1, 2, 3, … #> $ a0          <dbl> 0.0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.… #> $ a1          <dbl> 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11… #> $ probability <dbl> 1.092022e-08, 4.302621e-04, 2.007607e-02, 1.187329e-01, 2.… #> $ boot        <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2… if (interactive()) plot_ip(tmp)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_resampled_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","title":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","text":"Suits larger contact tracing data sets delay 2 events may may precisely known.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_resampled_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","text":"","code":"make_resampled_ip(   tau,   min_tau = pmax(tau - 0.5, truncate),   max_tau = tau + 0.5,   add_noise = TRUE,   truncate = 0,   n_boots = 100,   seed = Sys.time() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_resampled_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","text":"tau delay first second events min_tau minimum delay interval censored delays max_tau maximum delay interval censored delays add_noise adds noise date point replicate truncate minimum realistic value parameter n_boots number replicates generate seed random number seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_resampled_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","text":"long format ip delay distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/make_resampled_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Re-sample an empirical IP distribution direct from data — make_resampled_ip","text":"","code":"tau = rgamma2(100, 5,2) ip = make_resampled_ip(min_tau = tau-1, max_tau = tau+1, seed = 100) if(interactive()) {   plot_ip(ip,alpha=0.1) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/max_date.html","id":null,"dir":"Reference","previous_headings":"","what":"The maximum of a set of dates — max_date","title":"The maximum of a set of dates — max_date","text":"max.Date returns integer -Inf set NA dates. usually inconvenient.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/max_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The maximum of a set of dates — max_date","text":"","code":"max_date(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/max_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The maximum of a set of dates — max_date","text":"x vector dates ... ignored","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/max_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The maximum of a set of dates — max_date","text":"date. `0001-01-01“ well defined minimum.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/max_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The maximum of a set of dates — max_date","text":"","code":"max_date(NA) #> [1] \"1-01-01\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/min_date.html","id":null,"dir":"Reference","previous_headings":"","what":"The minimum of a set of dates — min_date","title":"The minimum of a set of dates — min_date","text":"min.Date returns integer Inf set NA dates. usually inconvenient.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/min_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The minimum of a set of dates — min_date","text":"","code":"min_date(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/min_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The minimum of a set of dates — min_date","text":"x vector dates ... ignored","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/min_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The minimum of a set of dates — min_date","text":"date. 9999-12-31 well defined minimum.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/min_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The minimum of a set of dates — min_date","text":"","code":"min_date(NA) #> [1] \"9999-12-31\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parts of a POSIXt or Date Object — months.time_period","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"Extract weekday, month quarter, Julian time   (days since origin).  generic functions: methods   internal date-time classes documented .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"","code":"# S3 method for class 'time_period' months(x, abbreviate = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"x object inheriting class \"POSIXt\" \"Date\". abbreviate logical vector (possibly recycled).  names     abbreviated?","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"weekdays months return character   vector names locale use, .e., Sys.getlocale(\"LC_TIME\"). quarters returns character vector \"Q1\"   \"Q4\". julian returns number days (possibly fractional)   since origin, origin \"origin\" attribute.   time calculations R done ignoring leap-seconds.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"components day month year   easy compute: just use .POSIXlt extract   relevant component.  Alternatively (especially components   desired character strings), use strftime.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/months.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Parts of a POSIXt or Date Object — months.time_period","text":"","code":"## first two are locale dependent: weekdays(.leap.seconds) #>  [1] \"Saturday\"  \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Saturday\"  #>  [7] \"Sunday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"    #> [13] \"Monday\"    \"Friday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  #> [19] \"Friday\"    \"Monday\"    \"Tuesday\"   \"Friday\"    \"Sunday\"    \"Thursday\"  #> [25] \"Sunday\"    \"Wednesday\" \"Sunday\"    months  (.leap.seconds) #>  [1] \"July\"    \"January\" \"January\" \"January\" \"January\" \"January\" \"January\" #>  [8] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"July\"    \"January\" #> [15] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"January\" \"July\"    #> [22] \"January\" \"January\" \"January\" \"July\"    \"July\"    \"January\" quarters(.leap.seconds) #>  [1] \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q1\" #> [16] \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q1\"  ## Show how easily you get month, day, year, day (of {month, week, yr}), ... : ## (remember to count from 0 (!): mon = 0..11, wday = 0..6,  etc !!)  ##' Transform (Time-)Date vector  to  convenient data frame : dt2df <- function(dt, dName = deparse(substitute(dt))) {     DF <- as.data.frame(unclass(as.POSIXlt( dt )))     `names<-`(cbind(dt, DF, deparse.level=0L), c(dName, names(DF))) } ## e.g., dt2df(.leap.seconds)    # date+time #>    .leap.seconds sec min hour mday mon year wday yday isdst zone gmtoff #> 1     1972-07-01   0   0    0    1   6   72    6  182     0  GMT      0 #> 2     1973-01-01   0   0    0    1   0   73    1    0     0  GMT      0 #> 3     1974-01-01   0   0    0    1   0   74    2    0     0  GMT      0 #> 4     1975-01-01   0   0    0    1   0   75    3    0     0  GMT      0 #> 5     1976-01-01   0   0    0    1   0   76    4    0     0  GMT      0 #> 6     1977-01-01   0   0    0    1   0   77    6    0     0  GMT      0 #> 7     1978-01-01   0   0    0    1   0   78    0    0     0  GMT      0 #> 8     1979-01-01   0   0    0    1   0   79    1    0     0  GMT      0 #> 9     1980-01-01   0   0    0    1   0   80    2    0     0  GMT      0 #> 10    1981-07-01   0   0    0    1   6   81    3  181     0  GMT      0 #> 11    1982-07-01   0   0    0    1   6   82    4  181     0  GMT      0 #> 12    1983-07-01   0   0    0    1   6   83    5  181     0  GMT      0 #> 13    1985-07-01   0   0    0    1   6   85    1  181     0  GMT      0 #> 14    1988-01-01   0   0    0    1   0   88    5    0     0  GMT      0 #> 15    1990-01-01   0   0    0    1   0   90    1    0     0  GMT      0 #> 16    1991-01-01   0   0    0    1   0   91    2    0     0  GMT      0 #> 17    1992-07-01   0   0    0    1   6   92    3  182     0  GMT      0 #> 18    1993-07-01   0   0    0    1   6   93    4  181     0  GMT      0 #> 19    1994-07-01   0   0    0    1   6   94    5  181     0  GMT      0 #> 20    1996-01-01   0   0    0    1   0   96    1    0     0  GMT      0 #> 21    1997-07-01   0   0    0    1   6   97    2  181     0  GMT      0 #> 22    1999-01-01   0   0    0    1   0   99    5    0     0  GMT      0 #> 23    2006-01-01   0   0    0    1   0  106    0    0     0  GMT      0 #> 24    2009-01-01   0   0    0    1   0  109    4    0     0  GMT      0 #> 25    2012-07-01   0   0    0    1   6  112    0  182     0  GMT      0 #> 26    2015-07-01   0   0    0    1   6  115    3  181     0  GMT      0 #> 27    2017-01-01   0   0    0    1   0  117    0    0     0  GMT      0 dt2df(Sys.Date() + 0:9) # date #>    Sys.Date() + 0:9 sec min hour mday mon year wday yday isdst zone gmtoff #> 1        2025-07-24   0   0    0   24   6  125    4  204     0  UTC      0 #> 2        2025-07-25   0   0    0   25   6  125    5  205     0  UTC      0 #> 3        2025-07-26   0   0    0   26   6  125    6  206     0  UTC      0 #> 4        2025-07-27   0   0    0   27   6  125    0  207     0  UTC      0 #> 5        2025-07-28   0   0    0   28   6  125    1  208     0  UTC      0 #> 6        2025-07-29   0   0    0   29   6  125    2  209     0  UTC      0 #> 7        2025-07-30   0   0    0   30   6  125    3  210     0  UTC      0 #> 8        2025-07-31   0   0    0   31   6  125    4  211     0  UTC      0 #> 9        2025-08-01   0   0    0    1   7  125    5  212     0  UTC      0 #> 10       2025-08-02   0   0    0    2   7  125    6  213     0  UTC      0  ##' Even simpler:  Date -> Matrix - dropping time info {sec,min,hour, isdst} d2mat <- function(x) simplify2array(unclass(as.POSIXlt(x))[4:7]) ## e.g., d2mat(seq(as.Date(\"2000-02-02\"), by=1, length.out=30)) # has R 1.0.0's release date #>       mday mon year wday #>  [1,]    2   1  100    3 #>  [2,]    3   1  100    4 #>  [3,]    4   1  100    5 #>  [4,]    5   1  100    6 #>  [5,]    6   1  100    0 #>  [6,]    7   1  100    1 #>  [7,]    8   1  100    2 #>  [8,]    9   1  100    3 #>  [9,]   10   1  100    4 #> [10,]   11   1  100    5 #> [11,]   12   1  100    6 #> [12,]   13   1  100    0 #> [13,]   14   1  100    1 #> [14,]   15   1  100    2 #> [15,]   16   1  100    3 #> [16,]   17   1  100    4 #> [17,]   18   1  100    5 #> [18,]   19   1  100    6 #> [19,]   20   1  100    0 #> [20,]   21   1  100    1 #> [21,]   22   1  100    2 #> [22,]   23   1  100    3 #> [23,]   24   1  100    4 #> [24,]   25   1  100    5 #> [25,]   26   1  100    6 #> [26,]   27   1  100    0 #> [27,]   28   1  100    1 #> [28,]   29   1  100    2 #> [29,]    1   2  100    3 #> [30,]    2   2  100    4  # \\donttest{ ## Julian Day Number (JDN, https://en.wikipedia.org/wiki/Julian_day) ## is the number of days since noon UTC on the first day of 4317 BCE. ## in the proleptic Julian calendar.  To more recently, in ## 'Terrestrial Time' which differs from UTC by a few seconds ## See https://en.wikipedia.org/wiki/Terrestrial_Time julian(Sys.Date(), -2440588) # from a day #> [1] 2460881 #> attr(,\"origin\") #> [1] -2440588 floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time #> [1] 2460881 # }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial time-series model. — multinomial_nnet_model","title":"Multinomial time-series model. — multinomial_nnet_model","text":"Takes list times, classes counts, e.g. COGUK variant like data set time, (multinomial) class (e.g. variant) count count time period. Fits quadratic B-spline time proportion data using nnet::multinom, approx one degree freedom per class per window units time series.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial time-series model. — multinomial_nnet_model","text":"","code":"multinomial_nnet_model(   d = i_multinomial_input,   ...,   window = 14,   frequency = \"1 day\",   predict = TRUE,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial time-series model. — multinomial_nnet_model","text":"d multi-class count input dataframe - dataframe columns: class (factor) - factor specifying type observation. things like variant, serotype, multinomial model. missing data points ignored. count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : class (groupings allowed). ... used window number data points knots, smaller values result less smoothing, large value . frequency temporal density output estimates. predict result prediction. false return model. .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multinomial time-series model. — multinomial_nnet_model","text":"new dataframe time (time period), class, proportion.0.5, model object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multinomial time-series model. — multinomial_nnet_model","text":"Additional groupings treated distinct proportions models.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/multinomial_nnet_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multinomial time-series model. — multinomial_nnet_model","text":"","code":"data = test_poisson_rt_2class tmp = data %>% ggoutbreak::multinomial_nnet_model(window=14) #> # weights:  28 (13 variable) #> initial  value 43356.356144  #> iter  10 value 38674.268766 #> iter  20 value 37400.259934 #> final  value 37399.822194  #> converged  if (interactive()) {   plot_multinomial(tmp, date_labels=\"%b %y\") }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a normalised count per capita — normalise_count","title":"Calculate a normalised count per capita — normalise_count","text":"assumes positive disease counts stratified population grouping, e.g. geography age, estimates size population time period. Normalising population size allows us compare groups.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a normalised count per capita — normalise_count","text":"","code":"normalise_count(   raw = i_incidence_data,   pop = i_population_data,   ...,   population_unit = 1e+05,   normalise_time = FALSE )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a normalised count per capita — normalise_count","text":"raw count data - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. pop population data must grouped way raw. - dataframe columns: population (positive_integer) - Size population grouping allowed. ... used population_unit population unit want count data normalised e.g. per 100K normalise_time default behaviour normalising keep time units input data. parameter set TRUE incidence rates calculated per year. given lubridate period string e.g. \"1 week\" incidence calculated time period.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a normalised count per capita — normalise_count","text":"dataframe incidence rates per unit capita. dataframe containing following columns: population (positive_integer) - Size population count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a normalised count per capita — normalise_count","text":"","code":"tmp = ggoutbreak::england_covid %>%   ggoutbreak::normalise_count(ggoutbreak::england_demographics) %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 9 #> Groups: class [19] #> $ date             <date> 2023-12-09, 2023-12-09, 2023-12-09, 2023-12-09, 2023… #> $ class            <fct> 00_04, 05_09, 10_14, 15_19, 20_24, 25_29, 30_34, 35_3… #> $ count            <int> 24, 8, 8, 4, 21, 20, 29, 36, 41, 59, 53, 54, 56, 54, … #> $ denom            <dbl> 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771… #> $ time             <time_prd> 1409, 1409, 1409, 1409, 1409, 1409, 1409, 1409, … #> $ population       <int> 3077000, 3348600, 3413100, 3218900, 3414400, 3715400,… #> $ count.per_capita <dbl> 0.77998050, 0.23890581, 0.23439102, 0.12426605, 0.615… #> $ population_unit  <dbl> 1e+05, 1e+05, 1e+05, 1e+05, 1e+05, 1e+05, 1e+05, 1e+0… #> $ time_unit        <Period> 1d 0H 0M 0S, 1d 0H 0M 0S, 1d 0H 0M 0S, 1d 0H 0M 0S…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_incidence.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a normalised incidence rate per capita — normalise_incidence","title":"Calculate a normalised incidence rate per capita — normalise_incidence","text":"assumes positive disease counts stratified population grouping, e.g. geography age, estimates size population time period. Normalising population size allows us compare groups.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_incidence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a normalised incidence rate per capita — normalise_incidence","text":"","code":"normalise_incidence(   modelled = i_incidence_model,   pop = i_population_data,   ...,   population_unit = 1e+05,   normalise_time = FALSE )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_incidence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a normalised incidence rate per capita — normalise_incidence","text":"modelled Model output processing raw dataframe something like poission_locfit_model - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. pop population data must grouped way modelled. - dataframe columns: population (positive_integer) - Size population grouping allowed. ... used population_unit population unit want incidence e.g. per 100K normalise_time default behaviour incidence keep time units input data. parameter set TRUE incidence rates calculated per year. given lubridate period string e.g. \"1 day\" incidence calculated time period.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_incidence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a normalised incidence rate per capita — normalise_incidence","text":"dataframe incidence rates per unit capita. dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period incidence.per_capita.fit (double) - estimate incidence per capita rate log scale incidence.per_capita.se.fit (positive_double) - standard error incidence per capita rate estimate log scale incidence.per_capita.0.025 (positive_double) - lower confidence limit incidence per capita rate (true scale) incidence.per_capita.0.5 (positive_double) - median estimate incidence per capita rate (true scale) incidence.per_capita.0.975 (positive_double) - upper confidence limit incidence per capita rate (true scale) population_unit (double) - population unit per capita incidence rate calculated time_unit (lubridate::.period) - time period per capita incidence rate calculated grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/normalise_incidence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a normalised incidence rate per capita — normalise_incidence","text":"","code":"ggoutbreak::england_covid_poisson_age_stratified %>%   ggoutbreak::normalise_incidence(ggoutbreak::england_demographics) %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 28 #> Groups: class [19] #> $ class                       <fct> 00_04, 00_04, 00_04, 00_04, 00_04, 00_04, … #> $ time                        <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,… #> $ incidence.fit               <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.se.fit            <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.025             <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.05              <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.25              <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.5               <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.75              <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.95              <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.0.975             <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.fit                  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.se.fit               <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.025                <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.05                 <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.25                 <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.5                  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.75                 <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.95                 <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ growth.0.975                <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ population                  <int> 3077000, 3077000, 3077000, 3077000, 307700… #> $ incidence.per_capita.0.025  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.per_capita.0.5    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.per_capita.0.975  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.per_capita.fit    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ incidence.per_capita.se.fit <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ population_unit             <dbl> 1e+05, 1e+05, 1e+05, 1e+05, 1e+05, 1e+05, … #> $ time_unit                   <Period> 1d 0H 0M 0S, 1d 0H 0M 0S, 1d 0H 0M 0S, …"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pbeta2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Beta Distribution — pbeta2","title":"The Beta Distribution — pbeta2","text":"Density, distribution function, quantile function random   generation Beta distribution parameters shape1   shape2 (optional non-centrality parameter ncp).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pbeta2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Beta Distribution — pbeta2","text":"","code":"pbeta2(q, prob, kappa, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pbeta2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Beta Distribution — pbeta2","text":"q vector quantiles prob mean probability (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pbeta2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Beta Distribution — pbeta2","text":"dbeta gives density, pbeta distribution   function, qbeta quantile function, rbeta   generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rbeta, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pbeta2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Beta Distribution — pbeta2","text":"","code":"pbeta2(c(0.25,0.5,0.75), 0.5, 0.25) #> [1] 0.0001270637 0.5000000000 0.9998729363"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pgamma2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Gamma Distribution — pgamma2","title":"The Gamma Distribution — pgamma2","text":"Density, distribution function, quantile function random   generation Gamma distribution parameters shape   scale.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pgamma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Gamma Distribution — pgamma2","text":"","code":"pgamma2(   q,   mean,   sd = sqrt(mean),   lower.tail = TRUE,   log.p = FALSE,   convex = TRUE )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pgamma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Gamma Distribution — pgamma2","text":"q vector quantiles mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log.p logical; TRUE, probabilities p given log(p). convex Show warning distribution selected convex function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pgamma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Gamma Distribution — pgamma2","text":"dgamma gives density,   pgamma gives distribution function,   qgamma gives quantile function,   rgamma generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rgamma, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pgamma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Gamma Distribution — pgamma2","text":"","code":"pgamma2(seq(0,4,0.25), 2, 1) #>  [1] 0.000000000 0.001751623 0.018988157 0.065642454 0.142876540 0.242423867 #>  [7] 0.352768111 0.463367332 0.566529880 0.657704044 0.734974085 0.798300801 #> [13] 0.848796117 0.888150388 0.918234584 0.940854540 0.957619888"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Log Normal Distribution — plnorm2","title":"The Log Normal Distribution — plnorm2","text":"Density, distribution function, quantile function random   generation log normal distribution whose logarithm mean   equal meanlog standard deviation equal sdlog.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Log Normal Distribution — plnorm2","text":"","code":"plnorm2(q, mean = 1, sd = sqrt(exp(1) - 1), lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Log Normal Distribution — plnorm2","text":"dlnorm calculated definition (‘Details’).   [pqr]lnorm based relationship normal. Consequently, model single point mass exp(meanlog)   boundary case sdlog = 0.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Log Normal Distribution — plnorm2","text":"q vector quantiles mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities     \\(P[X \\le x]\\), otherwise, \\(P[X > x]\\). log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Log Normal Distribution — plnorm2","text":"dlnorm gives density,   plnorm gives distribution function,   qlnorm gives quantile function,   rlnorm generates random deviates. length result determined n   rlnorm, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Log Normal Distribution — plnorm2","text":"log normal distribution density   $$     f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma x} e^{-(\\log(x) - \\mu)^2/2 \\sigma^2}%   $$   \\(\\mu\\) \\(\\sigma\\) mean standard   deviation logarithm.   mean \\(E(X) = exp(\\mu + 1/2 \\sigma^2)\\),   median \\(med(X) = exp(\\mu)\\), variance   \\(Var(X) = exp(2\\mu + \\sigma^2)(exp(\\sigma^2) - 1)\\)   hence coefficient variation   \\(\\sqrt{exp(\\sigma^2) - 1}\\)   approximately \\(\\sigma\\) small (e.g., \\(\\sigma < 1/2\\)).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The Log Normal Distribution — plnorm2","text":"cumulative hazard \\(H(t) = - \\log(1 - F(t))\\)   -plnorm(t, r, lower = FALSE, log = TRUE).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Log Normal Distribution — plnorm2","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole. Johnson, N. L., Kotz, S. Balakrishnan, N. (1995)   Continuous Univariate Distributions, volume 1, chapter 14.   Wiley, New York.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plnorm2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Log Normal Distribution — plnorm2","text":"","code":"plnorm2(seq(0,4,0.25), 2, 1) #>  [1] 0.000000e+00 1.550937e-05 3.482566e-03 3.287216e-02 1.091319e-01 #>  [6] 2.239928e-01 3.546433e-01 4.814610e-01 5.933575e-01 6.863496e-01 #> [11] 7.607047e-01 8.186775e-01 8.631396e-01 8.968813e-01 9.223215e-01 #> [16] 9.414327e-01 9.557664e-01"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a raw case counts as a histogram — plot_cases","title":"Plot a raw case counts as a histogram — plot_cases","text":"Plot raw case counts histogram","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a raw case counts as a histogram — plot_cases","text":"","code":"plot_cases(   raw,   ...,   mapping = .check_for_aes(raw, ..., class_aes = \"fill\"),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a raw case counts as a histogram — plot_cases","text":"raw raw case data either summarised count line-list - EITHER: dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. columns: time (ggoutbreak::time_period) - set events timestamp `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting fill something multiple types event plot. class column present mapping default using . events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a raw case counts as a histogram — plot_cases","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a raw case counts as a histogram — plot_cases","text":"","code":"# 50 random times: tmp = tibble::tibble(   time = as.time_period( sample.int(10,50,replace=TRUE) ,\"1 day\"),   class = rep(c(\"one\",\"two\",\"three\"), length.out=50) )  if(interactive()) {   plot_cases(tmp) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a raw case count timeseries — plot_counts","title":"Plot a raw case count timeseries — plot_counts","text":"Plot raw case count timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a raw case count timeseries — plot_counts","text":"","code":"plot_counts(raw, ..., mapping = .check_for_aes(raw, ...), events = i_events)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a raw case count timeseries — plot_counts","text":"raw raw count data, raw count data normalised population ( see normalise_count()) - EITHER: dataframe columns: population (positive_integer) - Size population count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a raw case count timeseries — plot_counts","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_counts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a raw case count timeseries — plot_counts","text":"","code":"# example code  tmp = ggoutbreak::england_covid %>%   time_aggregate(count=sum(count)) %>%   normalise_count(pop=56489700, population_unit=1000, normalise_time=TRUE)  # normalised by England population (56489700 people)  if(interactive()) {   plot_counts(tmp, colour=\"blue\",size=0.25) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_phase.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","title":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","text":"Plot incidence proportion versus growth phase diagram","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_phase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","text":"","code":"plot_growth_phase(   modelled,   timepoints = NULL,   duration = max(dplyr::count(modelled)$n),   interval = 7,   mapping = if (interfacer::is_col_present(modelled, class)) {      ggplot2::aes(colour =     class)  } else {      ggplot2::aes()  },   cis = TRUE,   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_phase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","text":"modelled Growth rates incidence / proportion timeseries outputs functions proportion_locfit_model, poisson_locfit_model, similar. - EITHER: dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.per_capita.fit (double) - estimate incidence per capita rate log scale incidence.per_capita.se.fit (positive_double) - standard error incidence per capita rate estimate log scale incidence.per_capita.0.025 (positive_double) - lower confidence limit incidence per capita rate (true scale) incidence.per_capita.0.5 (positive_double) - median estimate incidence per capita rate (true scale) incidence.per_capita.0.975 (positive_double) - upper confidence limit incidence per capita rate (true scale) population_unit (double) - population unit per capita incidence rate calculated time_unit (lubridate::.period) - time period per capita incidence rate calculated growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` risk_ratio.0.025 (positive_double) - lower confidence limit excess risk ratio population group risk_ratio.0.5 (positive_double) - median estimate excess risk ratio population group risk_ratio.0.975 (positive_double) - upper confidence limit excess risk ratio population group proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed. NULL timepoints time points (Date time_period vector) dates plot phase diagrams. multiple result sequence plots facets. NULL (default) last time point series duration length growth rate phase trail interval length time markers phase plot mapping ggplot2::aes() mapping cis logical; phases marked confidence intervals? ... Named arguments passed geom_events events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined. event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. Named arguments passed ggplot2::facet_wrap facets set variables expressions quoted vars() defining faceting groups rows columns dimension. variables can named (names passed labeller). compatibility classic interface, can also formula character vector. Use either one sided formula, ~+ b, character vector, c(\"\", \"b\"). nrow,ncol Number rows columns. scales scales fixed (\"fixed\", default), free (\"free\"), free one dimension (\"free_x\", \"free_y\")? shrink TRUE, shrink scales fit output statistics, raw data. FALSE, range raw data statistical summary. labeller function takes one data frame labels returns list data frame character vectors. input column corresponds one factor. Thus one vars(cyl, ). output column gets displayed one separate line strip label. function inherit \"labeller\" S3 class compatibility labeller(). can use different labeling functions different kind labels, example use label_parsed() formatting facet labels. label_value() used default, check details pointers options. .table TRUE, default, facets laid like table highest values bottom-right. FALSE, facets laid like plot highest value top-right. switch default, labels displayed top right plot. \"x\", top labels displayed bottom. \"y\", right-hand side labels displayed left. Can also set \"\". drop TRUE, default, factor levels used data automatically dropped. FALSE, factor levels shown, regardless whether appear data. dir Direction: either \"h\" horizontal, default, \"v\", vertical. strip.position default, labels displayed top plot. Using strip.position possible place labels either four sides setting strip.position = c(\"top\",   \"bottom\", \"left\", \"right\") axes Determines axes drawn case fixed scales. \"margins\" (default), axes drawn exterior margins. \"all_x\" \"all_y\" draw respective axes interior panels , whereas \"\" draw axes panels. axis.labels Determines whether draw labels interior axes scale fixed axis argument \"margins\". \"\" (default), interior axes get labels. \"margins\", exterior axes get labels, interior axes get none. \"all_x\" \"all_y\", draws labels interior axes x- y-direction respectively.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_phase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","text":"ggplot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_phase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an incidence or proportion versus growth phase diagram — plot_growth_phase","text":"","code":"data = ggoutbreak::test_poisson_rt_2class tmp2 = data %>% poisson_locfit_model()  timepoints = as.Date(tmp2$time[c(40,80,120,160)])  if(interactive()) {   plot_growth_phase(tmp2, timepoints, duration=108) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth rate timeseries diagram — plot_growth_rate","title":"Growth rate timeseries diagram — plot_growth_rate","text":"Growth rate timeseries diagram","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Growth rate timeseries diagram — plot_growth_rate","text":"","code":"plot_growth_rate(   modelled,   ...,   mapping = .check_for_aes(modelled, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth rate timeseries diagram — plot_growth_rate","text":"modelled growth rate dataframe. - EITHER: dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting colour something multiple incidence time series plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth rate timeseries diagram — plot_growth_rate","text":"ggplot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_growth_rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Growth rate timeseries diagram — plot_growth_rate","text":"","code":"data = ggoutbreak::test_poisson_rt_2class tmp2 = data %>% poisson_locfit_model()  if(interactive()) {   plot_growth_rate(tmp2) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_incidence.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an incidence timeseries — plot_incidence","title":"Plot an incidence timeseries — plot_incidence","text":"Plot incidence timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_incidence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an incidence timeseries — plot_incidence","text":"","code":"plot_incidence(   modelled,   raw = i_incidence_data,   ...,   mapping = .check_for_aes(modelled, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_incidence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an incidence timeseries — plot_incidence","text":"modelled optional estimate incidence time series. modelled missing estimated raw using poisson_locfit_model. case parameters window deg may supplied control fit. modelled can also output normalise_incidence case plot uses per capita rates calculated function. - EITHER: dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.per_capita.fit (double) - estimate incidence per capita rate log scale incidence.per_capita.se.fit (positive_double) - standard error incidence per capita rate estimate log scale incidence.per_capita.0.025 (positive_double) - lower confidence limit incidence per capita rate (true scale) incidence.per_capita.0.5 (positive_double) - median estimate incidence per capita rate (true scale) incidence.per_capita.0.975 (positive_double) - upper confidence limit incidence per capita rate (true scale) population_unit (double) - population unit per capita incidence rate calculated time_unit (lubridate::.period) - time period per capita incidence rate calculated grouping allowed. columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. raw raw count data - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. Named arguments passed poisson_locfit_model d input data - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 deg polynomial degree (min 1) - higher degree results less smoothing, lower values result smoothing. degree 1 fitting linear model piece wise. - default 1 frequency density output estimates time period 7 days 2 weeks. - default 1 day predict result prediction dataframe. false return locfit models (advanced). - default TRUE .progress show CLI progress bar mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_incidence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an incidence timeseries — plot_incidence","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_incidence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an incidence timeseries — plot_incidence","text":"","code":"# example code  tmp = test_poisson_rt_2class tmp2 = tmp %>% poisson_locfit_model()  if(interactive()) {   plot_incidence(tmp2,tmp,size=0.25) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an infectivity profile — plot_ip","title":"Plot an infectivity profile — plot_ip","text":"Plot infectivity profile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an infectivity profile — plot_ip","text":"","code":"plot_ip(ip = i_empirical_ip, alpha = NULL, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an infectivity profile — plot_ip","text":"ip long format infectivity profile - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined. alpha alpha value bootstrap lines ... passed onto geom_segment controlling line thickness, alpha etc.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an infectivity profile — plot_ip","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_ip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an infectivity profile — plot_ip","text":"","code":"if(interactive()) {   plot_ip(ganyani_ip) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a multinomial proportions model — plot_multinomial","title":"Plot a multinomial proportions model — plot_multinomial","text":"multinomial proportions model tell proportion class versus others data set. case denominator total count across across classes.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a multinomial proportions model — plot_multinomial","text":"","code":"plot_multinomial(   modelled = i_multinomial_proportion_model,   ...,   mapping = ggplot2::aes(fill = class),   events = i_events,   normalise = FALSE )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a multinomial proportions model — plot_multinomial","text":"modelled multinomial count data - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` class (factor) - factor specifying type observation. things like variant, serotype, multinomial model. missing data points ignored. proportion.0.5 (proportion) - median estimate proportion (true scale) Must grouped : class (exactly). ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. Usually left default events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined. normalise make sure probabilities add one - can bad idea know may missing values, hand proportions models guaranteed add one.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a multinomial proportions model — plot_multinomial","text":"ggplot","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_multinomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a multinomial proportions model — plot_multinomial","text":"","code":"tmp = ggoutbreak::england_covid_proportion_age_stratified %>%   dplyr::glimpse() #> Rows: 26,790 #> Columns: 20 #> Groups: class [19] #> $ class                  <fct> 00_04, 00_04, 00_04, 00_04, 00_04, 00_04, 00_04… #> $ time                   <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, … #> $ proportion.fit         <dbl> -1000.00000, -1000.00000, -1000.00000, -1000.00… #> $ proportion.se.fit      <dbl> 0.01129143, 0.01127551, 0.01125958, 0.01124366,… #> $ proportion.0.025       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.05        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.25        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.5         <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.75        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.95        <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ proportion.0.975       <dbl> 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000… #> $ relative.growth.fit    <dbl> 0.00000000, 0.00000000, 0.00000000, 0.00000000,… #> $ relative.growth.se.fit <dbl> 1.626352e-05, 1.626352e-05, 1.626352e-05, 1.626… #> $ relative.growth.0.025  <dbl> -3.187591e-05, -3.187591e-05, -3.187591e-05, -3… #> $ relative.growth.0.05   <dbl> -2.675111e-05, -2.675111e-05, -2.675111e-05, -2… #> $ relative.growth.0.25   <dbl> -1.096958e-05, -1.096958e-05, -1.096958e-05, -1… #> $ relative.growth.0.5    <dbl> 0.00000000, 0.00000000, 0.00000000, 0.00000000,… #> $ relative.growth.0.75   <dbl> 1.096958e-05, 1.096958e-05, 1.096958e-05, 1.096… #> $ relative.growth.0.95   <dbl> 2.675111e-05, 2.675111e-05, 2.675111e-05, 2.675… #> $ relative.growth.0.975  <dbl> 3.187591e-05, 3.187591e-05, 3.187591e-05, 3.187…  if(interactive()) {   plot_multinomial(tmp, normalise=TRUE)+     ggplot2::scale_fill_viridis_d() }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_prevalence.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a proportions timeseries — plot_prevalence","title":"Plot a proportions timeseries — plot_prevalence","text":"Plot proportions timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_prevalence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a proportions timeseries — plot_prevalence","text":"","code":"plot_prevalence(   modelled = i_prevalence_model,   raw = i_proportion_data,   ...,   mapping = .check_for_aes(modelled, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_prevalence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a proportions timeseries — plot_prevalence","text":"modelled Proportion model estimates - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` prevalence.0.025 (proportion) - lower confidence limit prevalence (true scale) prevalence.0.5 (proportion) - median estimate prevalence (true scale) prevalence.0.975 (proportion) - upper confidence limit prevalence (true scale) grouping allowed. raw Raw count data - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. Named arguments passed proportion_locfit_model d input - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 deg polynomial degree (min 1) - higher degree results less smoothing, lower values result smoothing. degree 1 fitting linear model piece wise. - default 1 frequency density output estimates time period 7 days 2 weeks. - default 1 day predict result prediction dataframe. false return locfit models (advanced). - default TRUE .progress show CLI progress bar mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_prevalence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a proportions timeseries — plot_prevalence","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_prevalence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a proportions timeseries — plot_prevalence","text":"","code":"if(interactive()) {   plot_prevalence(     ggoutbreak::england_ons_infection_survey,     mapping = ggplot2::aes(colour=geography)) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportion.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a proportions timeseries — plot_proportion","title":"Plot a proportions timeseries — plot_proportion","text":"Plot proportions timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a proportions timeseries — plot_proportion","text":"","code":"plot_proportion(   modelled = i_proportion_model,   raw = i_proportion_data,   ...,   mapping = .check_for_aes(modelled, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a proportions timeseries — plot_proportion","text":"modelled Proportion model estimates - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) grouping allowed. raw Raw count data denominator - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. Named arguments passed proportion_locfit_model d input - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 deg polynomial degree (min 1) - higher degree results less smoothing, lower values result smoothing. degree 1 fitting linear model piece wise. - default 1 frequency density output estimates time period 7 days 2 weeks. - default 1 day predict result prediction dataframe. false return locfit models (advanced). - default TRUE .progress show CLI progress bar mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a proportions timeseries — plot_proportion","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a proportions timeseries — plot_proportion","text":"","code":"tmp = ggoutbreak::test_poisson_rt_2class %>%   ggoutbreak::proportion_locfit_model(window=21) %>%   dplyr::glimpse() #> Rows: 322 #> Columns: 20 #> Groups: class [2] #> $ class                  <fct> one, one, one, one, one, one, one, one, one, on… #> $ time                   <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, … #> $ proportion.fit         <dbl> -0.20764707, -0.16164731, -0.11585089, -0.07019… #> $ proportion.se.fit      <dbl> 0.3489260, 0.3328725, 0.3174466, 0.3027491, 0.2… #> $ proportion.0.025       <dbl> 0.2907943, 0.3070249, 0.3234340, 0.3399387, 0.3… #> $ proportion.0.05        <dbl> 0.3139796, 0.3297814, 0.3456979, 0.3616597, 0.3… #> $ proportion.0.25        <dbl> 0.3910278, 0.4046405, 0.4182491, 0.4318294, 0.4… #> $ proportion.0.5         <dbl> 0.4482740, 0.4596759, 0.4710696, 0.4824597, 0.4… #> $ proportion.0.75        <dbl> 0.5069245, 0.5157128, 0.5245461, 0.5334527, 0.5… #> $ proportion.0.95        <dbl> 0.5905610, 0.5952903, 0.6002009, 0.6053453, 0.6… #> $ proportion.0.975       <dbl> 0.6168585, 0.6202880, 0.6239464, 0.6278927, 0.6… #> $ relative.growth.fit    <dbl> 0.04612401, 0.04614297, 0.04619444, 0.04627030,… #> $ relative.growth.se.fit <dbl> 0.02358606, 0.02352733, 0.02336793, 0.02313302,… #> $ relative.growth.0.025  <dbl> -1.038145e-04, 3.025148e-05, 3.941448e-04, 9.30… #> $ relative.growth.0.05   <dbl> 0.007328397, 0.007443957, 0.007757621, 0.008219… #> $ relative.growth.0.25   <dbl> 0.03021546, 0.03027403, 0.03043302, 0.03066731,… #> $ relative.growth.0.5    <dbl> 0.04612401, 0.04614297, 0.04619444, 0.04627030,… #> $ relative.growth.0.75   <dbl> 0.06203256, 0.06201192, 0.06195587, 0.06187328,… #> $ relative.growth.0.95   <dbl> 0.08491962, 0.08484199, 0.08463127, 0.08432073,… #> $ relative.growth.0.975  <dbl> 0.09235184, 0.09225570, 0.09199474, 0.09161018,…  if(interactive()) {   plot_proportion(tmp)+     ggplot2::scale_fill_viridis_d(aesthetics = c(\"fill\",\"colour\")) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a raw case count proportion timeseries — plot_proportions","title":"Plot a raw case count proportion timeseries — plot_proportions","text":"Plot raw case count proportion timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a raw case count proportion timeseries — plot_proportions","text":"","code":"plot_proportions(   raw = i_proportion_data,   ...,   mapping = .check_for_aes(raw, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a raw case count proportion timeseries — plot_proportions","text":"raw raw count denominator data - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a raw case count proportion timeseries — plot_proportions","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a raw case count proportion timeseries — plot_proportions","text":"","code":"# example code  tmp = tibble::tibble(   time = as.time_period(1:10, \"1 day\"),   count = 101:110 ) %>% dplyr::mutate(   denom = count*time )  if(interactive()) {   plot_proportions(tmp)+ggplot2::geom_line() }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a raw case count proportion timeseries — plot_proportions_data","title":"Plot a raw case count proportion timeseries — plot_proportions_data","text":"Plot raw case count proportion timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a raw case count proportion timeseries — plot_proportions_data","text":"","code":"plot_proportions_data(   raw = i_proportion_data,   ...,   mapping = .check_for_aes(raw, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a raw case count proportion timeseries — plot_proportions_data","text":"raw raw count denominator data - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting colour something multiple incidence timeseries plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a raw case count proportion timeseries — plot_proportions_data","text":"ggplot object","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_proportions_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a raw case count proportion timeseries — plot_proportions_data","text":"","code":"# example code  tmp = tibble::tibble(   time = as.time_period(1:10, \"1 day\"),   count = 101:110 ) %>% dplyr::mutate(   denom = count*time )  if(interactive()) {   plot_proportions_data(tmp)+ggplot2::geom_line() }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproduction number timeseries diagram — plot_rt","title":"Reproduction number timeseries diagram — plot_rt","text":"Reproduction number timeseries diagram","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproduction number timeseries diagram — plot_rt","text":"","code":"plot_rt(   modelled = i_reproduction_number,   ...,   mapping = .check_for_aes(modelled, ...),   events = i_events )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproduction number timeseries diagram — plot_rt","text":"modelled modelled Rt estimate - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed. ... Named arguments passed geom_events event_label_size big make event label event_label_colour event label colour event_label_angle event label colour event_line_colour event line colour event_fill_colour event area fill hide_labels show labels guide_axis guide axis configuration labels (see ggplot2::guide_axis ggplot2::dup_axis). can used specify position amongst things. ... Named arguments passed ggplot2::scale_x_date name name scale. Used axis legend title. waiver(), default, name scale taken first mapping used aesthetic. NULL, legend title omitted. breaks One : NULL breaks waiver() breaks specified date_breaks Date/POSIXct vector giving positions breaks function takes limits input returns breaks output date_breaks string giving distance breaks like \"2 weeks\", \"10 years\". breaks date_breaks specified, date_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. labels One : NULL labels waiver() default labels computed transformation object character vector giving labels (must length breaks) expression vector (must length breaks). See ?plotmath details. function takes breaks input returns labels output. Also accepts rlang lambda function notation. date_labels string giving formatting specification labels. Codes defined strftime(). labels date_labels specified, date_labels wins. minor_breaks One : NULL breaks waiver() breaks specified date_minor_breaks Date/POSIXct vector giving positions minor breaks function takes limits input returns minor breaks output date_minor_breaks string giving distance minor breaks like \"2 weeks\", \"10 years\". minor_breaks date_minor_breaks specified, date_minor_breaks wins. Valid specifications 'sec', 'min', 'hour', 'day', 'week', 'month' 'year', optionally followed 's'. limits One : NULL use default scale range numeric vector length two providing limits scale. Use NA refer existing minimum maximum function accepts existing (automatic) limits returns new limits. Also accepts rlang lambda function notation. Note setting limits positional scales remove data outside limits. purpose zoom, use limit argument coordinate system (see coord_cartesian()). expand position scales, vector range expansion constants used add padding around data ensure placed distance away axes. Use convenience function expansion() generate values expand argument. defaults expand scale 5% side continuous variables, 0.6 units side discrete variables. oob One : Function handles limits outside scale limits (bounds). Also accepts rlang lambda function notation. default (scales::censor()) replaces bounds values NA. scales::squish() squishing bounds values range. scales::squish_infinite() squishing infinite values range. guide function used create guide name. See guides() information. position position scales, position axis. left right y axes, top bottom x axes. sec.axis sec_axis() used specify secondary axis. timezone timezone use display axes. default (NULL) uses timezone encoded data. na.value Missing values replaced value. mapping ggplot2::aes mapping. importantly setting colour something multiple incidence time series plot events Significant events time spans - dataframe columns: label (character) - event label start (date) - start date, date event end (date) - end date NA single event grouping allowed. default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproduction number timeseries diagram — plot_rt","text":"ggplot timeseries","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/plot_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproduction number timeseries diagram — plot_rt","text":"","code":"# example code if (interactive()) {    tmp2 = england_covid_poisson %>%     rt_from_incidence()    # comparing RT from growth rates with England consensus Rt   # (N.B. offset by 17 days to align with estimates):    plot_rt(tmp2,colour=\"blue\")+     ggplot2::geom_errorbar(       data=england_consensus_rt,       mapping=ggplot2::aes(x=date-17,ymin=low,ymax=high),       colour=\"red\")  }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Negative Binomial Distribution — pnbinom2","title":"The Negative Binomial Distribution — pnbinom2","text":"Density, distribution function, quantile function random   generation negative binomial distribution parameters   size prob.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Negative Binomial Distribution — pnbinom2","text":"","code":"pnbinom2(q, mean, sd = sqrt(mean), lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Negative Binomial Distribution — pnbinom2","text":"dnbinom computes via binomial probabilities, using code   contributed Catherine Loader (see dbinom). pnbinom uses pbeta. qnbinom uses Cornish–Fisher Expansion include skewness   correction normal approximation, followed search. rnbinom uses derivation gamma mixture Poisson   distributions, see Devroye, L. (1986) Non-Uniform Random Variate Generation.   Springer-Verlag, New York. Page 480.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Negative Binomial Distribution — pnbinom2","text":"q vector quantiles. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities     \\(P[X \\le x]\\), otherwise, \\(P[X > x]\\). log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Negative Binomial Distribution — pnbinom2","text":"dnbinom gives density,   pnbinom gives distribution function,   qnbinom gives quantile function,   rnbinom generates random deviates. Invalid size prob result return value   NaN, warning. length result determined n   rnbinom, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used. rnbinom returns vector type integer unless generated   values exceed maximum representable integer double   values returned.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Negative Binomial Distribution — pnbinom2","text":"negative binomial distribution size \\(= n\\)   prob \\(= p\\) density   $$     p(x) = \\frac{\\Gamma(x+n)}{\\Gamma(n) x!} p^n (1-p)^x$$   \\(x = 0, 1, 2, \\ldots\\), \\(n > 0\\) \\(0 < p \\le 1\\). represents number failures occur sequence   Bernoulli trials target number successes reached.   mean \\(\\mu = n(1-p)/p\\) variance \\(n(1-p)/p^2\\). negative binomial distribution can also arise mixture   Poisson distributions mean distributed gamma distribution   (see pgamma) scale parameter (1 - prob)/prob   shape parameter size.  (definition allows non-integer   values size.) alternative parametrization (often used ecology)   mean mu (see ), size, dispersion   parameter, prob = size/(size+mu).  variance   mu + mu^2/size parametrization. element x integer, result dnbinom   zero, warning. case size == 0 distribution concentrated zero.   limiting distribution size approaching zero,   even mu rather prob held constant.  Notice   though, mean limit distribution 0, whatever   value mu. quantile defined smallest value \\(x\\)   \\(F(x) \\ge p\\), \\(F\\) distribution function.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pnbinom2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Negative Binomial Distribution — pnbinom2","text":"","code":"pnbinom2(0:5, 2, sqrt(2)) #> [1] 0.1353353 0.4060058 0.6766764 0.8571235 0.9473470 0.9834364"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_glm_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson time-series model. — poisson_glm_model","title":"Poisson time-series model. — poisson_glm_model","text":"uses generalised linear model fit quasi-poisson model time varying rate natural cubic spline approx one degree freedom per window units time series.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_glm_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson time-series model. — poisson_glm_model","text":"","code":"poisson_glm_model(   d = i_incidence_input,   ...,   window = 14,   frequency = \"1 day\",   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_glm_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson time-series model. — poisson_glm_model","text":"d Count model input - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 frequency density output estimates time period 7 days 2 weeks. - default 1 day .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_glm_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson time-series model. — poisson_glm_model","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_glm_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poisson time-series model. — poisson_glm_model","text":"","code":"data = test_poisson_growth_rate  tmp2 = data %>% ggoutbreak::poisson_glm_model(window=7,deg=2) tmp3 = data %>% ggoutbreak::poisson_glm_model(window=14,deg=1)  comp = dplyr::bind_rows(   tmp2 %>% dplyr::mutate(class=\"7:2\"),   tmp3 %>% dplyr::mutate(class=\"14:1\"), ) %>% dplyr::group_by(class)  if (interactive()) {   plot_incidence(comp, date_labels=\"%b %y\", raw=data)+     ggplot2::geom_line(       data=data,       mapping=ggplot2::aes(x=as.Date(time),y=rate),       colour=\"grey40\"     ) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson time-series model. — poisson_locfit_model","title":"Poisson time-series model. — poisson_locfit_model","text":"Takes list times counts fits quasi-poisson model fitted log link function count data using local regression using package locfit.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson time-series model. — poisson_locfit_model","text":"","code":"poisson_locfit_model(   d = i_incidence_input,   ...,   window = 14,   deg = 1,   frequency = \"1 day\",   predict = TRUE,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson time-series model. — poisson_locfit_model","text":"d input data - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 deg polynomial degree (min 1) - higher degree results less smoothing, lower values result smoothing. degree 1 fitting linear model piece wise. - default 1 frequency density output estimates time period 7 days 2 weeks. - default 1 day predict result prediction dataframe. false return locfit models (advanced). - default TRUE .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson time-series model. — poisson_locfit_model","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Poisson time-series model. — poisson_locfit_model","text":"results incidence rate estimate plus absolute exponential growth rate estimate based time unit input data (e.g. daily data rate cases per day growth rate daily).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/poisson_locfit_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poisson time-series model. — poisson_locfit_model","text":"","code":"data = test_poisson_growth_rate  tmp2 = data %>% ggoutbreak::poisson_locfit_model(window=7,deg=2) tmp3 = data %>% ggoutbreak::poisson_locfit_model(window=14,deg=1)  comp = dplyr::bind_rows(   tmp2 %>% dplyr::mutate(class=\"7:2\"),   tmp3 %>% dplyr::mutate(class=\"14:1\"), ) %>% dplyr::group_by(class)  if (interactive()) {   plot_incidence(     comp,     date_labels=\"%b %y\",     raw=data   )+   ggplot2::geom_line(     data=data,     mapping=ggplot2::aes(x=as.Date(time),y=rate),     colour=\"grey40\"   )    plot_growth_rate(     comp,     date_labels=\"%b %y\"   )+   sim_geom_function(data,colour=\"black\") }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_glm_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial time-series model. — proportion_glm_model","title":"Binomial time-series model. — proportion_glm_model","text":"uses generalised linear model fit quasi-binomial model time varying rate natural cubic spline approx one degree freedom per window units time series.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_glm_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial time-series model. — proportion_glm_model","text":"","code":"proportion_glm_model(   d = i_proportion_input,   ...,   window = 14,   frequency = \"1 day\",   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_glm_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial time-series model. — proportion_glm_model","text":"d Proportion model input - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 frequency density output estimates time period 7 days 2 weeks. - default 1 day .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_glm_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binomial time-series model. — proportion_glm_model","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_glm_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binomial time-series model. — proportion_glm_model","text":"","code":"data = test_poisson_rt_2class  tmp2 = data %>% ggoutbreak::proportion_glm_model(window=7,deg=2) tmp3 = data %>% ggoutbreak::proportion_glm_model(window=14,deg=1)  comp = dplyr::bind_rows(   tmp2 %>% dplyr::mutate(model=\"7:2\"),   tmp3 %>% dplyr::mutate(model=\"14:1\"), ) %>% dplyr::group_by(model,class)  if (interactive()) {   plot_proportion(       comp,       date_labels=\"%b %y\",       mapping=ggplot2::aes(colour=model),       raw=data    )+    ggplot2::facet_wrap(~class) }  # TODO: deal with error conditions # \"observations with zero weight not used for calculating dispersion"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":null,"dir":"Reference","previous_headings":"","what":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"takes list times, counts denominator fits quasi-binomial model using logit link function proportion data using local regression using package locfit.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"","code":"proportion_locfit_model(   d = i_proportion_input,   ...,   window = 14,   deg = 1,   frequency = \"1 day\",   predict = TRUE,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"d input - dataframe columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ... used present allow proportion model used group_modify window number data points defining bandwidth estimate, smaller values result less smoothing, large value . default value 14 calibrated data provided daily frequency, weekly data lower value may preferred. - default 14 deg polynomial degree (min 1) - higher degree results less smoothing, lower values result smoothing. degree 1 fitting linear model piece wise. - default 1 frequency density output estimates time period 7 days 2 weeks. - default 1 day predict result prediction dataframe. false return locfit models (advanced). - default TRUE .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"expects d contain one combination : time count denom columns - e.g. tests conducted. results one versus others comparison binomial proportion estimate plus relative growth rate estimate specifying much quicker growing compared growth denominator. denominator maybe sum subgroups denom = sum(count), e.g. situation multiple variants disease circulating. case relative growth subgroup compared overall. can make one-versus-others comparison making denominator exclude current item (e.g. denom = sum(count)-count). denominator can also used express size population tested. gives us relative growth rate different essence previous may better estimate true growth rate situation testing effort variable, capacity saturated.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/proportion_locfit_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A binomial proportion estimate and associated exponential growth rate — proportion_locfit_model","text":"","code":"data = test_poisson_rt_2class  tmp2 = data %>% ggoutbreak::proportion_locfit_model(window=7,deg=2) tmp3 = data %>% ggoutbreak::proportion_locfit_model(window=14,deg=1)  comp = dplyr::bind_rows(   tmp2 %>% dplyr::mutate(model=\"7:2\"),   tmp3 %>% dplyr::mutate(model=\"14:1\"), ) %>% dplyr::group_by(model,class)  if (interactive()) {   plot_proportion(     comp,     date_labels=\"%b %y\",     mapping=ggplot2::aes(colour=model),     raw=data   )+ggplot2::facet_wrap(~class) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge distribution — pwedge","title":"Wedge distribution — pwedge","text":"wedge distribution domain 0 1 linear probability density function domain.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wedge distribution — pwedge","text":"","code":"pwedge(q, a, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge distribution — pwedge","text":"q vector quantiles gradient -2 (left skewed) 2 (right skewed) log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge distribution — pwedge","text":"vector probabilities, quantiles, densities samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge distribution — pwedge","text":"rwedge can combined quantile functions skew standard distributions, introduce correlation weight certain parts distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/pwedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge distribution — pwedge","text":"","code":"pwedge(seq(0,1,0.1), a=1) #>  [1] 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 dwedge(seq(0,1,0.1), a=1) #>  [1] 0.000 0.055 0.120 0.195 0.280 0.375 0.480 0.595 0.720 0.855 1.000 qwedge(c(0.25,0.5,0.75), a=-1) #> [1] 0.1771243 0.3819660 0.6339746  stats::cor(   stats::qnorm(rwedge(1000, a=2)),   stats::qnorm(rwedge(1000, a=-2)) ) #> [1] -0.02740504"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qbeta2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Beta Distribution — qbeta2","title":"The Beta Distribution — qbeta2","text":"Density, distribution function, quantile function random   generation Beta distribution parameters shape1   shape2 (optional non-centrality parameter ncp).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qbeta2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Beta Distribution — qbeta2","text":"","code":"qbeta2(p, prob, kappa, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qbeta2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Beta Distribution — qbeta2","text":"p vector probabilities prob mean probability (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qbeta2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Beta Distribution — qbeta2","text":"dbeta gives density, pbeta distribution   function, qbeta quantile function, rbeta   generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rbeta, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qbeta2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Beta Distribution — qbeta2","text":"","code":"qbeta2(c(0.25,0.5,0.75), 0.5, 0.25) #> [1] 0.4506664 0.5000000 0.5493336"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qgamma2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Gamma Distribution — qgamma2","title":"The Gamma Distribution — qgamma2","text":"Density, distribution function, quantile function random   generation Gamma distribution parameters shape   scale.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qgamma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Gamma Distribution — qgamma2","text":"","code":"qgamma2(   p,   mean,   sd = sqrt(mean),   lower.tail = TRUE,   log.p = FALSE,   convex = TRUE )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qgamma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Gamma Distribution — qgamma2","text":"p vector probabilities mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log.p logical; TRUE, probabilities p given log(p). convex Show warning distribution selected convex function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qgamma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Gamma Distribution — qgamma2","text":"dgamma gives density,   pgamma gives distribution function,   qgamma gives quantile function,   rgamma generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rgamma, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qgamma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Gamma Distribution — qgamma2","text":"","code":"qgamma2(c(0.25,0.5,0.75), 2, 1) #> [1] 1.267660 1.836030 2.554714"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Log Normal Distribution — qlnorm2","title":"The Log Normal Distribution — qlnorm2","text":"Density, distribution function, quantile function random   generation log normal distribution whose logarithm mean   equal meanlog standard deviation equal sdlog.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Log Normal Distribution — qlnorm2","text":"","code":"qlnorm2(p, mean = 1, sd = sqrt(exp(1) - 1), lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Log Normal Distribution — qlnorm2","text":"dlnorm calculated definition (‘Details’).   [pqr]lnorm based relationship normal. Consequently, model single point mass exp(meanlog)   boundary case sdlog = 0.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Log Normal Distribution — qlnorm2","text":"p vector probabilities. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities     \\(P[X \\le x]\\), otherwise, \\(P[X > x]\\). log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Log Normal Distribution — qlnorm2","text":"dlnorm gives density,   plnorm gives distribution function,   qlnorm gives quantile function,   rlnorm generates random deviates. length result determined n   rlnorm, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Log Normal Distribution — qlnorm2","text":"log normal distribution density   $$     f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma x} e^{-(\\log(x) - \\mu)^2/2 \\sigma^2}%   $$   \\(\\mu\\) \\(\\sigma\\) mean standard   deviation logarithm.   mean \\(E(X) = exp(\\mu + 1/2 \\sigma^2)\\),   median \\(med(X) = exp(\\mu)\\), variance   \\(Var(X) = exp(2\\mu + \\sigma^2)(exp(\\sigma^2) - 1)\\)   hence coefficient variation   \\(\\sqrt{exp(\\sigma^2) - 1}\\)   approximately \\(\\sigma\\) small (e.g., \\(\\sigma < 1/2\\)).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The Log Normal Distribution — qlnorm2","text":"cumulative hazard \\(H(t) = - \\log(1 - F(t))\\)   -plnorm(t, r, lower = FALSE, log = TRUE).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Log Normal Distribution — qlnorm2","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole. Johnson, N. L., Kotz, S. Balakrishnan, N. (1995)   Continuous Univariate Distributions, volume 1, chapter 14.   Wiley, New York.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qlnorm2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Log Normal Distribution — qlnorm2","text":"","code":"qlnorm2(c(0.25,0.5,0.72), 2, 1) #> [1] 1.300774 1.788854 2.355843"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Negative Binomial Distribution — qnbinom2","title":"The Negative Binomial Distribution — qnbinom2","text":"Density, distribution function, quantile function random   generation negative binomial distribution parameters   size prob.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Negative Binomial Distribution — qnbinom2","text":"","code":"qnbinom2(p, mean, sd = sqrt(mean), lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Negative Binomial Distribution — qnbinom2","text":"dnbinom computes via binomial probabilities, using code   contributed Catherine Loader (see dbinom). pnbinom uses pbeta. qnbinom uses Cornish–Fisher Expansion include skewness   correction normal approximation, followed search. rnbinom uses derivation gamma mixture Poisson   distributions, see Devroye, L. (1986) Non-Uniform Random Variate Generation.   Springer-Verlag, New York. Page 480.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Negative Binomial Distribution — qnbinom2","text":"p vector probabilities. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) lower.tail logical; TRUE (default), probabilities     \\(P[X \\le x]\\), otherwise, \\(P[X > x]\\). log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Negative Binomial Distribution — qnbinom2","text":"dnbinom gives density,   pnbinom gives distribution function,   qnbinom gives quantile function,   rnbinom generates random deviates. Invalid size prob result return value   NaN, warning. length result determined n   rnbinom, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used. rnbinom returns vector type integer unless generated   values exceed maximum representable integer double   values returned.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Negative Binomial Distribution — qnbinom2","text":"negative binomial distribution size \\(= n\\)   prob \\(= p\\) density   $$     p(x) = \\frac{\\Gamma(x+n)}{\\Gamma(n) x!} p^n (1-p)^x$$   \\(x = 0, 1, 2, \\ldots\\), \\(n > 0\\) \\(0 < p \\le 1\\). represents number failures occur sequence   Bernoulli trials target number successes reached.   mean \\(\\mu = n(1-p)/p\\) variance \\(n(1-p)/p^2\\). negative binomial distribution can also arise mixture   Poisson distributions mean distributed gamma distribution   (see pgamma) scale parameter (1 - prob)/prob   shape parameter size.  (definition allows non-integer   values size.) alternative parametrization (often used ecology)   mean mu (see ), size, dispersion   parameter, prob = size/(size+mu).  variance   mu + mu^2/size parametrization. element x integer, result dnbinom   zero, warning. case size == 0 distribution concentrated zero.   limiting distribution size approaching zero,   even mu rather prob held constant.  Notice   though, mean limit distribution 0, whatever   value mu. quantile defined smallest value \\(x\\)   \\(F(x) \\ge p\\), \\(F\\) distribution function.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qnbinom2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Negative Binomial Distribution — qnbinom2","text":"","code":"qnbinom2(c(0.25,0.5,0.75), 5, sqrt(5)) #> [1] 4 6 8"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify estimate lags in a model — quantify_lag","title":"Identify estimate lags in a model — quantify_lag","text":"specific parameter set parameters can estimated pipeline. function applies pipeline synthetic epidemic sawtooth incidence resulting stepped growth rate function. lag synthetic input estimate assessed minimising root mean square error input estimated based different lag offsets.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify estimate lags in a model — quantify_lag","text":"","code":"quantify_lag(pipeline, ip = i_empirical_ip, lags = -10:30)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify estimate lags in a model — quantify_lag","text":"pipeline function taking input dataset infectivity profile inputs producing estimate output. whole parametrised pipeline including inputs. can purrr style function, case .x variable input dataset .y infectivity profile. ip infectivity profile. - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined. lags vector delays test. Defaults -10 +30 days","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify estimate lags in a model — quantify_lag","text":"lag analysis dataframe containing estimate type lag days estimate behind actual observation","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quantify_lag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify estimate lags in a model — quantify_lag","text":"","code":"# lags from a locfit incidence model with Rt estimation. # This model has no estimator lag: pipeline = ~ .x %>% poisson_locfit_model() %>% rt_from_incidence(ip = .y) quantify_lag(pipeline, ip = test_ip) #> # A tibble: 3 × 2 #> # Groups:   estimate [3] #>   estimate    lag #> * <chr>     <int> #> 1 growth        0 #> 2 incidence     0 #> 3 rt            0  # lags from an epiestim Rt estimation # this model's lags depend on the infectivity profile. # In this case it is 8 days pipeline2 =  ~ .x %>% rt_epiestim(ip = .y) quantify_lag(pipeline2, ip=test_ip ) #> # A tibble: 1 × 2 #> # Groups:   estimate [1] #>   estimate   lag #> * <chr>    <int> #> 1 rt           8"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parts of a POSIXt or Date Object — quarters.time_period","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"Extract weekday, month quarter, Julian time   (days since origin).  generic functions: methods   internal date-time classes documented .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"","code":"# S3 method for class 'time_period' quarters(x, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"x object inheriting class \"POSIXt\" \"Date\". ... arguments methods.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"weekdays months return character   vector names locale use, .e., Sys.getlocale(\"LC_TIME\"). quarters returns character vector \"Q1\"   \"Q4\". julian returns number days (possibly fractional)   since origin, origin \"origin\" attribute.   time calculations R done ignoring leap-seconds.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"components day month year   easy compute: just use .POSIXlt extract   relevant component.  Alternatively (especially components   desired character strings), use strftime.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/quarters.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Parts of a POSIXt or Date Object — quarters.time_period","text":"","code":"## first two are locale dependent: weekdays(.leap.seconds) #>  [1] \"Saturday\"  \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Saturday\"  #>  [7] \"Sunday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"    #> [13] \"Monday\"    \"Friday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  #> [19] \"Friday\"    \"Monday\"    \"Tuesday\"   \"Friday\"    \"Sunday\"    \"Thursday\"  #> [25] \"Sunday\"    \"Wednesday\" \"Sunday\"    months  (.leap.seconds) #>  [1] \"July\"    \"January\" \"January\" \"January\" \"January\" \"January\" \"January\" #>  [8] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"July\"    \"January\" #> [15] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"January\" \"July\"    #> [22] \"January\" \"January\" \"January\" \"July\"    \"July\"    \"January\" quarters(.leap.seconds) #>  [1] \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q1\" #> [16] \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q1\"  ## Show how easily you get month, day, year, day (of {month, week, yr}), ... : ## (remember to count from 0 (!): mon = 0..11, wday = 0..6,  etc !!)  ##' Transform (Time-)Date vector  to  convenient data frame : dt2df <- function(dt, dName = deparse(substitute(dt))) {     DF <- as.data.frame(unclass(as.POSIXlt( dt )))     `names<-`(cbind(dt, DF, deparse.level=0L), c(dName, names(DF))) } ## e.g., dt2df(.leap.seconds)    # date+time #>    .leap.seconds sec min hour mday mon year wday yday isdst zone gmtoff #> 1     1972-07-01   0   0    0    1   6   72    6  182     0  GMT      0 #> 2     1973-01-01   0   0    0    1   0   73    1    0     0  GMT      0 #> 3     1974-01-01   0   0    0    1   0   74    2    0     0  GMT      0 #> 4     1975-01-01   0   0    0    1   0   75    3    0     0  GMT      0 #> 5     1976-01-01   0   0    0    1   0   76    4    0     0  GMT      0 #> 6     1977-01-01   0   0    0    1   0   77    6    0     0  GMT      0 #> 7     1978-01-01   0   0    0    1   0   78    0    0     0  GMT      0 #> 8     1979-01-01   0   0    0    1   0   79    1    0     0  GMT      0 #> 9     1980-01-01   0   0    0    1   0   80    2    0     0  GMT      0 #> 10    1981-07-01   0   0    0    1   6   81    3  181     0  GMT      0 #> 11    1982-07-01   0   0    0    1   6   82    4  181     0  GMT      0 #> 12    1983-07-01   0   0    0    1   6   83    5  181     0  GMT      0 #> 13    1985-07-01   0   0    0    1   6   85    1  181     0  GMT      0 #> 14    1988-01-01   0   0    0    1   0   88    5    0     0  GMT      0 #> 15    1990-01-01   0   0    0    1   0   90    1    0     0  GMT      0 #> 16    1991-01-01   0   0    0    1   0   91    2    0     0  GMT      0 #> 17    1992-07-01   0   0    0    1   6   92    3  182     0  GMT      0 #> 18    1993-07-01   0   0    0    1   6   93    4  181     0  GMT      0 #> 19    1994-07-01   0   0    0    1   6   94    5  181     0  GMT      0 #> 20    1996-01-01   0   0    0    1   0   96    1    0     0  GMT      0 #> 21    1997-07-01   0   0    0    1   6   97    2  181     0  GMT      0 #> 22    1999-01-01   0   0    0    1   0   99    5    0     0  GMT      0 #> 23    2006-01-01   0   0    0    1   0  106    0    0     0  GMT      0 #> 24    2009-01-01   0   0    0    1   0  109    4    0     0  GMT      0 #> 25    2012-07-01   0   0    0    1   6  112    0  182     0  GMT      0 #> 26    2015-07-01   0   0    0    1   6  115    3  181     0  GMT      0 #> 27    2017-01-01   0   0    0    1   0  117    0    0     0  GMT      0 dt2df(Sys.Date() + 0:9) # date #>    Sys.Date() + 0:9 sec min hour mday mon year wday yday isdst zone gmtoff #> 1        2025-07-24   0   0    0   24   6  125    4  204     0  UTC      0 #> 2        2025-07-25   0   0    0   25   6  125    5  205     0  UTC      0 #> 3        2025-07-26   0   0    0   26   6  125    6  206     0  UTC      0 #> 4        2025-07-27   0   0    0   27   6  125    0  207     0  UTC      0 #> 5        2025-07-28   0   0    0   28   6  125    1  208     0  UTC      0 #> 6        2025-07-29   0   0    0   29   6  125    2  209     0  UTC      0 #> 7        2025-07-30   0   0    0   30   6  125    3  210     0  UTC      0 #> 8        2025-07-31   0   0    0   31   6  125    4  211     0  UTC      0 #> 9        2025-08-01   0   0    0    1   7  125    5  212     0  UTC      0 #> 10       2025-08-02   0   0    0    2   7  125    6  213     0  UTC      0  ##' Even simpler:  Date -> Matrix - dropping time info {sec,min,hour, isdst} d2mat <- function(x) simplify2array(unclass(as.POSIXlt(x))[4:7]) ## e.g., d2mat(seq(as.Date(\"2000-02-02\"), by=1, length.out=30)) # has R 1.0.0's release date #>       mday mon year wday #>  [1,]    2   1  100    3 #>  [2,]    3   1  100    4 #>  [3,]    4   1  100    5 #>  [4,]    5   1  100    6 #>  [5,]    6   1  100    0 #>  [6,]    7   1  100    1 #>  [7,]    8   1  100    2 #>  [8,]    9   1  100    3 #>  [9,]   10   1  100    4 #> [10,]   11   1  100    5 #> [11,]   12   1  100    6 #> [12,]   13   1  100    0 #> [13,]   14   1  100    1 #> [14,]   15   1  100    2 #> [15,]   16   1  100    3 #> [16,]   17   1  100    4 #> [17,]   18   1  100    5 #> [18,]   19   1  100    6 #> [19,]   20   1  100    0 #> [20,]   21   1  100    1 #> [21,]   22   1  100    2 #> [22,]   23   1  100    3 #> [23,]   24   1  100    4 #> [24,]   25   1  100    5 #> [25,]   26   1  100    6 #> [26,]   27   1  100    0 #> [27,]   28   1  100    1 #> [28,]   29   1  100    2 #> [29,]    1   2  100    3 #> [30,]    2   2  100    4  # \\donttest{ ## Julian Day Number (JDN, https://en.wikipedia.org/wiki/Julian_day) ## is the number of days since noon UTC on the first day of 4317 BCE. ## in the proleptic Julian calendar.  To more recently, in ## 'Terrestrial Time' which differs from UTC by a few seconds ## See https://en.wikipedia.org/wiki/Terrestrial_Time julian(Sys.Date(), -2440588) # from a day #> [1] 2460881 #> attr(,\"origin\") #> [1] -2440588 floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time #> [1] 2460881 # }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge distribution — qwedge","title":"Wedge distribution — qwedge","text":"wedge distribution domain 0 1 linear probability density function domain.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wedge distribution — qwedge","text":"","code":"qwedge(p, a, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge distribution — qwedge","text":"p vector probabilities gradient -2 (left skewed) 2 (right skewed) lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. log.p logical; TRUE, probabilities p given log(p).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge distribution — qwedge","text":"vector probabilities, quantiles, densities samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge distribution — qwedge","text":"rwedge can combined quantile functions skew standard distributions, introduce correlation weight certain parts distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/qwedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge distribution — qwedge","text":"","code":"pwedge(seq(0,1,0.1), a=1) #>  [1] 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 dwedge(seq(0,1,0.1), a=1) #>  [1] 0.000 0.055 0.120 0.195 0.280 0.375 0.480 0.595 0.720 0.855 1.000 qwedge(c(0.25,0.5,0.75), a=-1) #> [1] 0.1771243 0.3819660 0.6339746  stats::cor(   stats::qnorm(rwedge(1000, a=2)),   stats::qnorm(rwedge(1000, a=-2)) ) #> [1] 0.003417679"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbern.html","id":null,"dir":"Reference","previous_headings":"","what":"A random Bernoulli sample as a logical value — rbern","title":"A random Bernoulli sample as a logical value — rbern","text":"random Bernoulli sample logical value","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A random Bernoulli sample as a logical value — rbern","text":"","code":"rbern(n, prob)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A random Bernoulli sample as a logical value — rbern","text":"n number observations prob mean probability (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A random Bernoulli sample as a logical value — rbern","text":"vector logical values size n","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A random Bernoulli sample as a logical value — rbern","text":"","code":"table(rbern(100, 0.25)) #>  #> FALSE  TRUE  #>    82    18"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbeta2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Beta Distribution — rbeta2","title":"The Beta Distribution — rbeta2","text":"Density, distribution function, quantile function random   generation Beta distribution parameters shape1   shape2 (optional non-centrality parameter ncp).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbeta2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Beta Distribution — rbeta2","text":"","code":"rbeta2(n, prob, kappa)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbeta2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Beta Distribution — rbeta2","text":"n number observations prob mean probability (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbeta2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Beta Distribution — rbeta2","text":"dbeta gives density, pbeta distribution   function, qbeta quantile function, rbeta   generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rbeta, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rbeta2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Beta Distribution — rbeta2","text":"","code":"rbeta2(3, c(0.1,0.5,0.9),0.1) #> [1] 0.09794551 0.52762488 0.90285869"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rcategorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","title":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","text":"Sampling multinomial equivalent Bernoulli distribution","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rcategorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","text":"","code":"rcategorical(n, prob, factor = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rcategorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","text":"n sample size prob (optionally named) vector probabilities normalised sum 1 factor FALSE factor levels either taken names prob first, character vector .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rcategorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","text":"vector random class labels length n. Labels come names prob character vector factor.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rcategorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sampling from the multinomial equivalent of the Bernoulli distribution — rcategorical","text":"","code":"prob = c(\"one\"=0.1,\"two\"=0.2,\"seven\"=0.7) table(rcategorical(1000,prob)) #>  #>   one seven   two  #>   102   701   197  rcategorical(10,prob,factor=TRUE) #>  [1] seven two   two   seven two   one   seven two   seven seven #> Levels: one two seven rcategorical(10,rep(1,26),factor=letters) #>  [1] a d g g q j f p i k #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rdiscgamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Random count data from a discrete gamma distribution — rdiscgamma","title":"Random count data from a discrete gamma distribution — rdiscgamma","text":"count data -dispersed can use gamma distribution rounded nearest whole number. method discretisation make_gamma_ip, suits delay distributions less variability can represented Poisson negative binomial distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rdiscgamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random count data from a discrete gamma distribution — rdiscgamma","text":"","code":"rdiscgamma(n, mean, sd, kappa)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rdiscgamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random count data from a discrete gamma distribution — rdiscgamma","text":"n number observations mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rdiscgamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random count data from a discrete gamma distribution — rdiscgamma","text":"integer valued vector gamma distribution.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rdiscgamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random count data from a discrete gamma distribution — rdiscgamma","text":"","code":"rdiscgamma(10, 2, 1) #>  [1] 1 1 1 2 3 2 1 1 3 3"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reband_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"Reband any discrete distribution — reband_discrete","title":"Reband any discrete distribution — reband_discrete","text":"e.g. age banded population, discrete probability distribution e.g. serial interval distribution. method fits monotonically increasing spline cumulative distribution (including upper lower limits) interpolating using spline new cut points.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reband_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reband any discrete distribution — reband_discrete","text":"","code":"reband_discrete(   x,   y,   xout,   xlim = c(0, NA),   ytotal = c(0, sum(y)),   digits = 0,   labelling = c(\"positive_integer\", \"inclusive\", \"exclusive\"),   sep = \"-\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reband_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reband any discrete distribution — reband_discrete","text":"x set upper limits bands, e.g. age: 0-14;15-64;65-79;80+ 15,65,80,NA y set quantities band e.g. population figures xout set new upper limits xlim Upper lower limits x. last band e.g 80+ input want know 85+ band output kind maximum upper limit needed interpolate . ytotal upper lower limits y. interpolation values fall outside x minimum maximum limits y given . c(0,1) probability distribution, example. digits xout value continuous many significant figures put labels labelling xout values interpretable inclusive upper limit, exclusive upper limit, upper limit `positive_integer“ quantity sep separator names e.g. 18-24 18 24","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reband_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reband any discrete distribution — reband_discrete","text":"re-banded set discrete values, guaranteed sum y","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reband_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reband any discrete distribution — reband_discrete","text":"","code":"ul = stringr::str_extract(england_demographics$class, \"_([0-9]+)\",group = 1) %>%   as.numeric()  tmp = reband_discrete(   ul, england_demographics$population,   c(5,10,15,40,80), xlim=c(0,120))  tmp #>      0-4      5-9    10-14    15-39    40-79      80+  #>  3745688  3361511  3384582 18173104 25360084  2464731   sum(tmp) #> [1] 56489700 sum(england_demographics$population) #> [1] 56489700"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reparam-dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-parametrised distributions — reparam-dist","title":"Re-parametrised distributions — reparam-dist","text":"Re-parametrised distributions","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/reparam-dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-parametrised distributions — reparam-dist","text":"n number observations x vector quantiles q vector quantiles p vector probabilities log logical; TRUE, probabilities p given log(p). log.p logical; TRUE, probabilities p given log(p). lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. convex Show warning distribution selected convex function prob mean probability (vectorised) kappa coefficient variation. 0 variability 1 maximally variability (vectorised) mean mean value true scale (vectorised) sd standard deviation true scale (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rescale_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale a timeseries in the temporal dimension — rescale_model","title":"Rescale a timeseries in the temporal dimension — rescale_model","text":"Sometimes may , example, modelled incidence growth rates weekly data resulting cases per week growth rate per week. may wish use estimate reproduction number, using algorithms assume daily incidence. everything dependence time, things proportions, prevalence change.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rescale_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale a timeseries in the temporal dimension — rescale_model","text":"","code":"rescale_model(df = i_timeseries, time_unit)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rescale_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rescale a timeseries in the temporal dimension — rescale_model","text":"df data frame containing modelled output. modify following columns present: dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period proportion.fit (double) - estimate proportion logit scale proportion.se.fit (positive_double) - standard error proportion estimate logit scale proportion.0.025 (proportion) - lower confidence limit proportion (true scale) proportion.0.5 (proportion) - median estimate proportion (true scale) proportion.0.975 (proportion) - upper confidence limit proportion (true scale) relative.growth.fit (double) - estimate relative growth rate relative.growth.se.fit (positive_double) - standard error relative growth rate relative.growth.0.025 (double) - lower confidence limit relative growth rate relative.growth.0.5 (double) - median estimate relative growth rate relative.growth.0.975 (double) - upper confidence limit relative growth rate grouping allowed. time_unit lubridate period string \"1 day\"","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rescale_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rescale a timeseries in the temporal dimension — rescale_model","text":"time series different time unit, adjusted incidence growth rate figures.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rescale_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rescale a timeseries in the temporal dimension — rescale_model","text":"","code":"sim = sim_poisson_model(time_unit = \"1 week\") #> interfacer: development mode active (local function). #> This message is displayed once every 8 hours. incidence = sim %>% poisson_locfit_model(frequency = \"1 day\", deg = 2, window=5) incidence2 = incidence %>% rescale_model(time_unit = \"1 day\") incidence2 %>% dplyr::glimpse() #> Rows: 727 #> Columns: 20 #> Groups: statistic [1] #> $ statistic        <chr> \"infections\", \"infections\", \"infections\", \"infections… #> $ time             <time_prd> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1… #> $ incidence.fit    <dbl> 2.496489, 2.517828, 2.539042, 2.560129, 2.581089, 2.6… #> $ incidence.se.fit <dbl> 0.04338465, 0.04060679, 0.03808768, 0.03581637, 0.033… #> $ incidence.0.025  <dbl> 11.15019, 11.45287, 11.75632, 12.06043, 12.36510, 12.… #> $ incidence.0.05   <dbl> 79.12566, 81.20251, 83.28791, 85.38124, 87.48201, 89.… #> $ incidence.0.25   <dbl> 82.52788, 84.46604, 86.42373, 88.40082, 90.39724, 92.… #> $ incidence.0.5    <dbl> 12.13979, 12.40163, 12.66753, 12.93749, 13.21152, 13.… #> $ incidence.0.75   <dbl> 87.50196, 89.22197, 90.98019, 92.77682, 94.61203, 96.… #> $ incidence.0.95   <dbl> 91.26434, 92.80780, 94.40563, 96.05796, 97.76485, 99.… #> $ incidence.0.975  <dbl> 13.21722, 13.42899, 13.64936, 13.87832, 14.11587, 14.… #> $ growth.fit       <dbl> 0.02140392, 0.02127503, 0.02114210, 0.02100573, 0.020… #> $ growth.se.fit    <dbl> 0.003824766, 0.003690481, 0.003554655, 0.003417722, 0… #> $ growth.0.025     <dbl> 0.01390752, 0.01404182, 0.01417510, 0.01430712, 0.014… #> $ growth.0.05      <dbl> 0.1057892, 0.1064331, 0.1070665, 0.1076885, 0.1082984… #> $ growth.0.25      <dbl> 0.1317691, 0.1315008, 0.1312116, 0.1309036, 0.1305787… #> $ growth.0.5       <dbl> 0.02140392, 0.02127503, 0.02114210, 0.02100573, 0.020… #> $ growth.0.75      <dbl> 0.1678858, 0.1663495, 0.1647777, 0.1631766, 0.1615524… #> $ growth.0.95      <dbl> 0.1938657, 0.1914173, 0.1889229, 0.1863917, 0.1838328… #> $ growth.0.975     <dbl> 0.02890033, 0.02850824, 0.02810909, 0.02770434, 0.027…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rgamma2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Gamma Distribution — rgamma2","title":"The Gamma Distribution — rgamma2","text":"Density, distribution function, quantile function random   generation Gamma distribution parameters shape   scale.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rgamma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Gamma Distribution — rgamma2","text":"","code":"rgamma2(n, mean, sd = sqrt(mean), convex = TRUE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rgamma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Gamma Distribution — rgamma2","text":"n number observations mean mean value true scale (vectorised) sd standard deviation true scale (vectorised) convex Show warning distribution selected convex function","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rgamma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Gamma Distribution — rgamma2","text":"dgamma gives density,   pgamma gives distribution function,   qgamma gives quantile function,   rgamma generates random deviates. Invalid arguments result return value NaN, warning. length result determined n   rgamma, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rgamma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Gamma Distribution — rgamma2","text":"","code":"rgamma2(10, 2, 1) #>  [1] 1.977208 1.025111 2.077852 1.984411 3.798504 2.598185 1.811783 2.310074 #>  [9] 2.071847 1.063863"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Log Normal Distribution — rlnorm2","title":"The Log Normal Distribution — rlnorm2","text":"Density, distribution function, quantile function random   generation log normal distribution whose logarithm mean   equal meanlog standard deviation equal sdlog.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Log Normal Distribution — rlnorm2","text":"","code":"rlnorm2(n, mean = 1, sd = sqrt(exp(1) - 1))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Log Normal Distribution — rlnorm2","text":"dlnorm calculated definition (‘Details’).   [pqr]lnorm based relationship normal. Consequently, model single point mass exp(meanlog)   boundary case sdlog = 0.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Log Normal Distribution — rlnorm2","text":"n number observations. length(n) > 1, length     taken number required. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Log Normal Distribution — rlnorm2","text":"dlnorm gives density,   plnorm gives distribution function,   qlnorm gives quantile function,   rlnorm generates random deviates. length result determined n   rlnorm, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Log Normal Distribution — rlnorm2","text":"log normal distribution density   $$     f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma x} e^{-(\\log(x) - \\mu)^2/2 \\sigma^2}%   $$   \\(\\mu\\) \\(\\sigma\\) mean standard   deviation logarithm.   mean \\(E(X) = exp(\\mu + 1/2 \\sigma^2)\\),   median \\(med(X) = exp(\\mu)\\), variance   \\(Var(X) = exp(2\\mu + \\sigma^2)(exp(\\sigma^2) - 1)\\)   hence coefficient variation   \\(\\sqrt{exp(\\sigma^2) - 1}\\)   approximately \\(\\sigma\\) small (e.g., \\(\\sigma < 1/2\\)).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The Log Normal Distribution — rlnorm2","text":"cumulative hazard \\(H(t) = - \\log(1 - F(t))\\)   -plnorm(t, r, lower = FALSE, log = TRUE).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Log Normal Distribution — rlnorm2","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole. Johnson, N. L., Kotz, S. Balakrishnan, N. (1995)   Continuous Univariate Distributions, volume 1, chapter 14.   Wiley, New York.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rlnorm2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Log Normal Distribution — rlnorm2","text":"","code":"rlnorm2(10, 2, 1) #>  [1] 1.0064717 2.4314232 2.8482057 2.2595842 1.4864037 0.7197925 2.0859423 #>  [8] 3.8114187 1.6629916 1.7212727"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Negative Binomial Distribution — rnbinom2","title":"The Negative Binomial Distribution — rnbinom2","text":"Density, distribution function, quantile function random   generation negative binomial distribution parameters   size prob.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Negative Binomial Distribution — rnbinom2","text":"","code":"rnbinom2(n, mean, sd = sqrt(mean))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The Negative Binomial Distribution — rnbinom2","text":"dnbinom computes via binomial probabilities, using code   contributed Catherine Loader (see dbinom). pnbinom uses pbeta. qnbinom uses Cornish–Fisher Expansion include skewness   correction normal approximation, followed search. rnbinom uses derivation gamma mixture Poisson   distributions, see Devroye, L. (1986) Non-Uniform Random Variate Generation.   Springer-Verlag, New York. Page 480.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Negative Binomial Distribution — rnbinom2","text":"n number observations.  length(n) > 1, length     taken number required. mean mean value true scale (vectorised) sd standard deviation true scale (vectorised)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Negative Binomial Distribution — rnbinom2","text":"dnbinom gives density,   pnbinom gives distribution function,   qnbinom gives quantile function,   rnbinom generates random deviates. Invalid size prob result return value   NaN, warning. length result determined n   rnbinom, maximum lengths   numerical arguments functions. numerical arguments n recycled   length result.  first elements logical   arguments used. rnbinom returns vector type integer unless generated   values exceed maximum representable integer double   values returned.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Negative Binomial Distribution — rnbinom2","text":"negative binomial distribution size \\(= n\\)   prob \\(= p\\) density   $$     p(x) = \\frac{\\Gamma(x+n)}{\\Gamma(n) x!} p^n (1-p)^x$$   \\(x = 0, 1, 2, \\ldots\\), \\(n > 0\\) \\(0 < p \\le 1\\). represents number failures occur sequence   Bernoulli trials target number successes reached.   mean \\(\\mu = n(1-p)/p\\) variance \\(n(1-p)/p^2\\). negative binomial distribution can also arise mixture   Poisson distributions mean distributed gamma distribution   (see pgamma) scale parameter (1 - prob)/prob   shape parameter size.  (definition allows non-integer   values size.) alternative parametrization (often used ecology)   mean mu (see ), size, dispersion   parameter, prob = size/(size+mu).  variance   mu + mu^2/size parametrization. element x integer, result dnbinom   zero, warning. case size == 0 distribution concentrated zero.   limiting distribution size approaching zero,   even mu rather prob held constant.  Notice   though, mean limit distribution 0, whatever   value mu. quantile defined smallest value \\(x\\)   \\(F(x) \\ge p\\), \\(F\\) distribution function.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rnbinom2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Negative Binomial Distribution — rnbinom2","text":"","code":"rnbinom2(10, 5, sqrt(5)) #>  [1]  3  7  7 10  4  6  8  5  6  1"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproduction number estimate using the Cori method — rt_cori","title":"Reproduction number estimate using the Cori method — rt_cori","text":"Calculate reproduction number estimate incidence data using reimplementation Cori method empirical generation time distribution. uses mixture distribution transmit uncertainty generation time estimates. number changes compared original EpiEstim implementation made. Firstly technical limitation infectivity profile strictly positive time. allows use serial intervals secondary potentially delayed observations. Secondly implementation tolerate missing count values (NA values must filtered though). Thirdly given time point t applies Rt estimates window spans time point t rather end time point t, tends address lag issues original, fourthly implementation allows multiple window widths calculated parallel aggregated. tends increase uncertainty result particularly time dimension, addresses issue seem EpiEstim pandemic. Finally quite bit quicker, especially approximate quantiles needed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproduction number estimate using the Cori method — rt_cori","text":"","code":"rt_cori(   df = i_incidence_input,   ip = i_discrete_ip,   window = 14,   mean_prior = 1,   std_prior = 2,   ...,   epiestim_compat = FALSE,   approx = FALSE,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproduction number estimate using the Cori method — rt_cori","text":"df count data. Extra groups allowed. - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ip long format infectivity profile. - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. tau (integer + complete) - days since index event. Minimally grouped : boot (groupings allowed). default value defined. window widths Cori method window include estimate. can vector values windows calculated aggregated. mean_prior prior $R_t$ estimate. sample size low $R_t$ estimate revert prior. EpiEstim default high number allow detection insufficient data tends create anomalies early part infection time series. possible value $R_0$ fact also poor choice value $R_t$ case numbers drop low value. std_prior prior $R_t$ SD. ... used epiestim_compat produce estimate Rt using windows end time t rather windows span time t. option selected can also one value window. approx approximate quantiles mixture distribution gamma distribution first mean SD. .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproduction number estimate using the Cori method — rt_cori","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reproduction number estimate using the Cori method — rt_cori","text":"still issues large $R_t$ estimates early part time series, resul tof renewal equaltion method. calculate reproduction number group input dataframe.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_cori.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproduction number estimate using the Cori method — rt_cori","text":"","code":"data = ggoutbreak::test_poisson_rt_smooth  tmp2 = data %>% rt_cori(ip=ggoutbreak::test_ip, epiestim_compat = TRUE) tmp3 = data %>% rt_cori(ip=ggoutbreak::test_ip, window=c(5:14), approx=TRUE)  comp = dplyr::bind_rows(   tmp2 %>% dplyr::mutate(class = \"EpiEstim\"),   tmp3 %>% dplyr::mutate(class = \"Cori+\") ) %>% dplyr::group_by(class)  if (interactive()) {   plot_rt(comp, date_labels=\"%b %y\")+sim_geom_function(data,colour=\"black\")+     ggplot2::coord_cartesian(ylim=c(0.5,3.0)) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":null,"dir":"Reference","previous_headings":"","what":"EpiEstim reproduction number wrapper function — rt_epiestim","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"Calculate reproduction number estimate incidence data using EpiEstim library empirical generation time distribution. uses resampling transmit uncertainty generation time estimates. quite slow time series depending number bootstraps samples infectivity profile.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"","code":"rt_epiestim(   df = i_incidence_input,   ip = i_discrete_ip,   bootstraps = 2000,   window = 14,   mean_prior = 1,   std_prior = 2,   ...,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"df Count data. Extra groups allowed. - dataframe columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` grouping allowed. ip infectivity profile - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. tau (integer + complete) - days since index event. Minimally grouped : boot (groupings allowed). default value defined. bootstraps number bootstraps take calculate point. window width EpiEstim window mean_prior prior $R_t$ estimate. sample size low $R_t$ estimate revert prior. EpiEstim default high number allow detection insufficient data tends create anomalies early part infection time series. possible value $R_0$ fact also poor choice value $R_t$ case numbers drop low value. std_prior prior $R_t$ SD. ... used .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"calculate reproduction number group input dataframe.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_epiestim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EpiEstim reproduction number wrapper function — rt_epiestim","text":"","code":"data = test_poisson_rt_smooth  tmp2 = data %>%    ggoutbreak::rt_epiestim(test_ip)  if (interactive()) {   plot_rt(tmp2, date_labels=\"%b %y\")+sim_geom_function(data,colour=\"red\") }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"Calculate reproduction number estimate growth rate using Wallinga Lipsitch 2007 estimation using empirical generation time distribution. uses resampling transmit uncertainty growth rate estimates. also handles time-series daily cadence (although experimental). reproduction number estimate neither instantaneous (backward looking) case (forward looking) reproduction number somewhere two, method looks flux infection single point time.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"","code":"rt_from_growth_rate(   df = i_growth_rate,   ip = i_empirical_ip,   bootstraps = 1000,   seed = Sys.time(),   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"df Growth rate estimates - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` growth.fit (double) - estimate growth rate growth.se.fit (positive_double) - standard error growth rate growth.0.025 (double) - lower confidence limit growth rate growth.0.5 (double) - median estimate growth rate growth.0.975 (double) - upper confidence limit growth rate grouping allowed. ip Infectivity profile - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined. bootstraps number bootstraps take calculate point. seed random number generator seed .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"method quite slow compared others default non deterministic.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_growth_rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wallinga-Lipsitch reproduction number from growth rates — rt_from_growth_rate","text":"","code":"data = ggoutbreak::test_poisson_rt_smooth  tmp = data %>%   poisson_locfit_model() %>%   rt_from_growth_rate(ip=ggoutbreak::test_ip)  if (interactive()) {   plot_rt(tmp, date_labels=\"%b %y\")+sim_geom_function(data,colour=\"red\") }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_incidence.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproduction number from modelled incidence — rt_from_incidence","title":"Reproduction number from modelled incidence — rt_from_incidence","text":"Calculate reproduction number estimate modelled incidence using methods described vignette \"Estimating reproduction number modelled incidence\" using set empirical generation time distributions. assumes modelled incidence time unit ip distribution, daily, case rescale_model() may able fix .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_incidence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproduction number from modelled incidence — rt_from_incidence","text":"","code":"rt_from_incidence(   df = i_incidence_model,   ip = i_discrete_ip,   approx = TRUE,   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_incidence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproduction number from modelled incidence — rt_from_incidence","text":"df modelled incidence estimate - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. ip infectivity profile (aka generation time distribution) - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. tau (integer + complete) - days since index event. Minimally grouped : boot (groupings allowed). default value defined. approx use faster, approximate, estimate quantiles .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_incidence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproduction number from modelled incidence — rt_from_incidence","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_incidence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproduction number from modelled incidence — rt_from_incidence","text":"","code":"tmp = ggoutbreak::test_poisson_rt_smooth %>%   poisson_locfit_model() %>%   rt_from_incidence(approx=FALSE)  tmp2 = ggoutbreak::test_poisson_rt_smooth %>%   poisson_locfit_model() %>%   rt_from_incidence(approx=TRUE)  plot_data = dplyr::bind_rows(   tmp %>% dplyr::mutate(class = \"exact\"),   tmp2 %>% dplyr::mutate(class = \"approx\"), ) %>% dplyr::group_by(class)  if (interactive()) {   plot_rt(plot_data, date_labels=\"%b %y\")+    sim_geom_function(ggoutbreak::test_poisson_rt_smooth)+    ggplot2::coord_cartesian(ylim=c(0.5,3))+    ggplot2::facet_wrap(~class) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"Calculate reproduction number estimate modelled incidence estimates, statistical sampling log-normally distributed incidence estimate, get I_t ~ Poisson(I_0 e^{rt})  model using log link function. combined uncertain infectivity profile specified multiple discrete empirical distributions, calculate range possible values $R_t$.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"","code":"rt_from_renewal(   df = i_incidence_model,   ip = i_discrete_ip,   bootstraps = 1000,   seed = Sys.time(),   .progress = interactive() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"df modelled incidence estimate - dataframe columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` incidence.fit (double) - estimate incidence rate log scale incidence.se.fit (positive_double) - standard error incidence rate estimate log scale incidence.0.025 (positive_double) - lower confidence limit incidence rate (true scale) incidence.0.5 (positive_double) - median estimate incidence rate (true scale) incidence.0.975 (positive_double) - upper confidence limit incidence rate (true scale) grouping allowed. ip infectivity profile - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. tau (integer + complete) - days since index event. Minimally grouped : boot (groupings allowed). default value defined. bootstraps number samples take time point. rounded whole multiple infectivity profile distribution length. seed random number seed reproducibility .progress show CLI progress bar","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"dataframe containing following columns: time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period rt.fit (double) - estimate reproduction number rt.se.fit (positive_double) - standard error reproduction number rt.0.025 (double) - lower confidence limit reproduction number rt.0.5 (double) - median estimate reproduction number rt.0.975 (double) - upper confidence limit reproduction number grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"method moderately slow non deterministic default.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rt_from_renewal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproduction number from renewal equation applied to modelled incidence using statistical re-sampling — rt_from_renewal","text":"","code":"data = test_poisson_rt_smooth  tmp2 = data %>%    ggoutbreak::poisson_locfit_model() %>%    ggoutbreak::rt_from_renewal(test_ip)  if (interactive()) {   plot_rt(tmp2, date_labels=\"%b %y\")+sim_geom_function(data,colour=\"red\") }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge distribution — rwedge","title":"Wedge distribution — rwedge","text":"wedge distribution domain 0 1 linear probability density function domain.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wedge distribution — rwedge","text":"","code":"rwedge(n, a)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge distribution — rwedge","text":"n number observations gradient -2 (left skewed) 2 (right skewed)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge distribution — rwedge","text":"vector probabilities, quantiles, densities samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge distribution — rwedge","text":"rwedge can combined quantile functions skew standard distributions, introduce correlation weight certain parts distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/rwedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge distribution — rwedge","text":"","code":"pwedge(seq(0,1,0.1), a=1) #>  [1] 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 dwedge(seq(0,1,0.1), a=1) #>  [1] 0.000 0.055 0.120 0.195 0.280 0.375 0.480 0.595 0.720 0.855 1.000 qwedge(c(0.25,0.5,0.75), a=-1) #> [1] 0.1771243 0.3819660 0.6339746  stats::cor(   stats::qnorm(rwedge(1000, a=2)),   stats::qnorm(rwedge(1000, a=-2)) ) #> [1] -0.01384537"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"A log1p y scale — scale_y_log1p","title":"A log1p y scale — scale_y_log1p","text":"log1p y scale","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A log1p y scale — scale_y_log1p","text":"","code":"scale_y_log1p(..., n = 5, base = 10, dp = 0)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A log1p y scale — scale_y_log1p","text":"... arguments passed scale_(x|y)_continuous() n number major breaks base base logarithm dp decimal points","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A log1p y scale — scale_y_log1p","text":"ggplot scale","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_logit.html","id":null,"dir":"Reference","previous_headings":"","what":"A logit y scale — scale_y_logit","title":"A logit y scale — scale_y_logit","text":"logit y scale","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A logit y scale — scale_y_logit","text":"","code":"scale_y_logit(...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A logit y scale — scale_y_logit","text":"... arguments passed scale_(x|y)_continuous()","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/scale_y_logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A logit y scale — scale_y_logit","text":"ggplot scale","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/score_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate scoring statistics from predictions. — score_estimate","title":"Calculate scoring statistics from predictions. — score_estimate","text":"performs range continuous scoring metrics estimate time-point using cumulative distribution functions estimate. Point quality metrics calculated estimate provided summarised. Summarisation performed using bootstrap resampling generate confidence intervals summary statistics, presented median +/1 95% CI.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/score_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate scoring statistics from predictions. — score_estimate","text":"","code":"score_estimate(   est,   obs,   lags = NULL,   summarise_by = est %>% dplyr::groups(),   bootstraps = 1000,   raw_bootstraps = FALSE,   seed = 100 )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/score_estimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate scoring statistics from predictions. — score_estimate","text":"est dataframe estimates incidence, growth rate reproduction number based simulation data known parameters. group est expected contain multiple estimates group scored separately. Estimates est must form column named XXX.cdf containing cumulative distribution function estimate XXX.link containing link function specification (one identity,log logit). generated default ggoutbreak estimators triggered setting option: options(\"ggoutbreak.keep_cdf\"=TRUE) running estimator. CDFs generated analytical, estimator generates parametrised output (mixture thereof), empirical estimator uses resampling, inferred estimator produces quantiles . obs dataframe ground truth, sharing grouping columns est least one column(s) named XXX.obs XXX e.g. rt,growth incidence column group predicted est (.e. obs column XXX.obs, est must one called XXX.cdf). lags data frame estimate types lags output quantify_lag() multiple models included columns must match obs. must 2 columns, one called estimate values matching incidence,rt,growth,proportion,relative.growth, lag column, (whole) number days. summarise_by default every group treated separately. can overridden tidyselect specification groupings want see final summarised output (e.g. want differentiate performance particular type scenario timeframe). exactly FALSE function return raw point estimates. bootstraps number bootstrap replicates draw assessing metric confidence. FALSE bootstrapping done metrics returned confidence intervals. raw_bootstraps (defaults FALSE) return summary metrics bootstrap rather quantiles summary metrics. seed random seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/score_estimate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate scoring statistics from predictions. — score_estimate","text":"dataframe scoring metrics, one row per group. includes following columns: mean_quantile_bias - average universal residuals. Lower values better. mean_trans_bias - bias link function scale. link - link function mean_bias - bias natural scale (may interpreted additive multiplicative depending link) pit_was - unadjusted probability integral transform histogram Wasserstein distance uniform (lower values better). unbiased_pit_was - PIT Wasserstein distance uniform, adjusted estimator bias (lower values better). measure calibration. directed_pit_was - PIT Wasserstein distance uniform, directed away centre, adjusted estimator bias (values closer zero better, positive values indicate overconfidence, negative values excessively conservative estimates). percent_iqr_coverage - percentage estimators include true value IQR. perfectly calibrated estimate 0.5. Lower values reflect overconfidence, higher values reflect excessively conservative estimates. measure calibration influenced bias. unbiased_percent_iqr_coverage - percentage estimators include true value IQR adjusted bias. 0.5. measure calibration, tells direction (smaller numbers -confident, larger values excessively conservative). mean_prediction_interval_width_50 - prediction interval width measure sharpness (smaller values sharper). Sharper estimators superior unbiased well calibrated. mean_crps - mean value continuous rank probability score point estimate (lower values better) mean_unbiased_crps - mean value continuous rank probability score point estimate assessed adjustment bias (lower values better) threshold_misclassification_probability - metric natural threshold like 1 Rt measures probable estimate propose epidemic shrinking growing vice versa. Lower better outputs possible summarise_by false.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/score_estimate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate scoring statistics from predictions. — score_estimate","text":"","code":"data = test_poisson_rt_smooth  pipeline = ~ .x %>% poisson_locfit_model() %>% rt_from_incidence(ip = .y) lags = quantify_lag(pipeline, ip = test_ip)  withr::with_options(list(\"ggoutbreak.keep_cdf\"=TRUE),{    est = data %>% poisson_locfit_model() %>% rt_from_incidence() })  if (interactive()) plot_rt(est)+sim_geom_function(data, colour=\"red\")  obs = data %>% dplyr::mutate(rt.obs = rt, incidence.obs = rate) score_estimate(est,obs,lags) %>% dplyr::glimpse() #> estimates match true observations using columns: statistic,time #> matching ground truth observations for: rt,incidence #> Rows: 2 #> Columns: 58 #> Groups: statistic, .type [2] #> $ statistic                                     <chr> \"infections\", \"infection… #> $ .type                                         <chr> \"incidence\", \"rt\" #> $ mean_crps.0.025                               <dbl> 10.98978668, 0.04032795 #> $ mean_crps.0.25                                <dbl> 13.62340944, 0.04414321 #> $ mean_crps.0.5                                 <dbl> 15.15158955, 0.04606762 #> $ mean_crps.0.75                                <dbl> 16.8417648, 0.0479307 #> $ mean_crps.0.975                               <dbl> 20.1882336, 0.0517226 #> $ threshold_misclassification_probability.0.025 <dbl> NA, 0.009876672 #> $ threshold_misclassification_probability.0.25  <dbl> NA, 0.01377113 #> $ threshold_misclassification_probability.0.5   <dbl> NA, 0.01626741 #> $ threshold_misclassification_probability.0.75  <dbl> NA, 0.01895191 #> $ threshold_misclassification_probability.0.975 <dbl> NA, 0.02449107 #> $ mean_trans_bias.0.025                         <dbl> -0.01266085, -0.02273671 #> $ mean_trans_bias.0.25                          <dbl> 0.01126477, -0.01601425 #> $ mean_trans_bias.0.5                           <dbl> 0.02684155, -0.01278173 #> $ mean_trans_bias.0.75                          <dbl> 0.046155970, -0.009099837 #> $ mean_trans_bias.0.975                         <dbl> 0.090329406, -0.003911726 #> $ mean_bias.0.025                               <dbl> 1.000166, 0.979561 #> $ mean_bias.0.25                                <dbl> 1.0336082, 0.9860565 #> $ mean_bias.0.5                                 <dbl> 1.2244771, 0.9892595 #> $ mean_bias.0.75                                <dbl> 1.4182445, 0.9929786 #> $ mean_bias.0.975                               <dbl> 1.7018174, 0.9980693 #> $ mean_quantile_bias.0.025                      <dbl> -0.2264054, -0.1050566 #> $ mean_quantile_bias.0.25                       <dbl> -0.15069353, -0.04200179 #> $ mean_quantile_bias.0.5                        <dbl> -0.11127710, -0.01255761 #> $ mean_quantile_bias.0.75                       <dbl> -0.06978917, 0.02237791 #> $ mean_quantile_bias.0.975                      <dbl> 0.008240465, 0.087022806 #> $ mean_prediction_interval_width_50.0.025       <dbl> 6.78317045, 0.09599041 #> $ mean_prediction_interval_width_50.0.25        <dbl> 7.7053714, 0.1051482 #> $ mean_prediction_interval_width_50.0.5         <dbl> 8.3034963, 0.1093185 #> $ mean_prediction_interval_width_50.0.75        <dbl> 8.9157488, 0.1141591 #> $ mean_prediction_interval_width_50.0.975       <dbl> 10.1931297, 0.1233715 #> $ pit_was.0.025                                 <dbl> 0.0726560, 0.0278309 #> $ pit_was.0.25                                  <dbl> 0.08870652, 0.03876108 #> $ pit_was.0.5                                   <dbl> 0.09940320, 0.04484022 #> $ pit_was.0.75                                  <dbl> 0.11181363, 0.05294238 #> $ pit_was.0.975                                 <dbl> 0.13696191, 0.07078622 #> $ unbiased_pit_was.0.025                        <dbl> 0.08855997, 0.04102905 #> $ unbiased_pit_was.0.25                         <dbl> 0.11069667, 0.05988691 #> $ unbiased_pit_was.0.5                          <dbl> 0.1243669, 0.0718268 #> $ unbiased_pit_was.0.75                         <dbl> 0.13765800, 0.08299567 #> $ unbiased_pit_was.0.975                        <dbl> 0.1661897, 0.1102013 #> $ directed_pit_was.0.025                        <dbl> 0.05657086, -0.01440478 #> $ directed_pit_was.0.25                         <dbl> 0.076202082, 0.002409855 #> $ directed_pit_was.0.5                          <dbl> 0.08589970, 0.01239666 #> $ directed_pit_was.0.75                         <dbl> 0.09571491, 0.02234276 #> $ directed_pit_was.0.975                        <dbl> 0.11304919, 0.04184877 #> $ percent_iqr_coverage.0.025                    <dbl> 0.3043478, 0.4161491 #> $ percent_iqr_coverage.0.25                     <dbl> 0.3540373, 0.4658385 #> $ percent_iqr_coverage.0.5                      <dbl> 0.3788820, 0.4906832 #> $ percent_iqr_coverage.0.75                     <dbl> 0.4037267, 0.5217391 #> $ percent_iqr_coverage.0.975                    <dbl> 0.4596273, 0.5653727 #> $ unbiased_percent_iqr_coverage.0.025           <dbl> 0.2919255, 0.3105590 #> $ unbiased_percent_iqr_coverage.0.25            <dbl> 0.3354037, 0.3602484 #> $ unbiased_percent_iqr_coverage.0.5             <dbl> 0.3602484, 0.3850932 #> $ unbiased_percent_iqr_coverage.0.75            <dbl> 0.3850932, 0.4099379 #> $ unbiased_percent_iqr_coverage.0.975           <dbl> 0.4347826, 0.4658385 #> $ link                                          <chr> \"log\", \"log\""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_ascertainment.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","title":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","text":"Apply ascertainment bias observed case counts.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_ascertainment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","text":"","code":"sim_apply_ascertainment(df = i_sim_count_data, fn_asc = ~1, seed = Sys.time())"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_ascertainment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","text":"df count dataframe e.g. sim_poisson_model() sim_summarise_linelist() - dataframe columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings allowed). fn_asc function takes single input vector t returns probability ascertainment, e.g. ~ stats::rbeta(.x, 20, 80) ~ rbeta2(.x,prob=<probability>,kappa=<dispersion>). cfg_weekly_proportion_rng() seed RNG seed","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_ascertainment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","text":"dataframe original column, count column modified include ascertainment bias.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_ascertainment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a ascertainment bias to the observed case counts. — sim_apply_ascertainment","text":"","code":"tibble::tibble(   statistic = \"incidence\",   time=as.time_period(1:10,\"1 day\"),   count=rep(100,10) ) %>% dplyr::group_by(statistic) %>% sim_apply_ascertainment(~ ifelse(.x<=5,0.1,0.9)) #> # A tibble: 10 × 5 #> # Groups:   statistic [1] #>    statistic time       count original ascertainment #>    <chr>     <time_prd> <int>    <int>         <dbl> #>  1 incidence  1            14      100           0.1 #>  2 incidence  2             5      100           0.1 #>  3 incidence  3            13      100           0.1 #>  4 incidence  4             6      100           0.1 #>  5 incidence  5            10      100           0.1 #>  6 incidence  6            83      100           0.9 #>  7 incidence  7            85      100           0.9 #>  8 incidence  8            90      100           0.9 #>  9 incidence  9            87      100           0.9 #> 10 incidence 10            84      100           0.9"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.count_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply delay distributions to count data — sim_apply_delay.count_data","title":"Apply delay distributions to count data — sim_apply_delay.count_data","text":"function uses convolution time delay functions (can function time, e.g. weekly periodicity) incident infections generate realistic looking outbreak metrics, including admission, death, symptom onset testing.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.count_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply delay distributions to count data — sim_apply_delay.count_data","text":"","code":"sim_apply_delay.count_data(   df,   ...,   fn_p_symptomatic = ~0.5,   fn_symptom_profile = cfg_gamma_ip_fn(~5),   fn_p_admitted = ~0.1,   fn_admission_profile = cfg_weekly_ip_fn(c(8, 8, 8, 8, 8, 9.5, 9)),   fn_p_died = ~0.05,   fn_death_profile = cfg_gamma_ip_fn(~14),   fn_p_tested = ~0.8,   fn_sample_profile = cfg_weekly_ip_fn(c(1, 1, 1, 1, 1, 1.5, 1.4)),   fn_result_profile = cfg_weekly_ip_fn(c(1, 1, 1, 1, 1, 1.6, 1.5)),   seed = Sys.time() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.count_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply delay distributions to count data — sim_apply_delay.count_data","text":"df output sim_poisson_model() sim_summarise_linelist(), including count column time column fn_p_symptomatic, fn_p_admitted, fn_p_died, fn_p_tested Function returns probability 0 1 row input dataframe. purrr style lambda OK (e.g. ~ 1 always true) first parameter time infection. function must vectorised inputs (consume additional inputs ...) fn_symptom_profile, fn_admission_profile, fn_death_profile function takes time returns probability density symptoms, admissions, deaths time since infection (.e. tau) ip delay distribution. possible good idea pre-compute distributions need assigned every line input can slow. fn_sample_profile function takes time returns probability density test sample taken time since symptoms. fn_result_profile function takes time returns probability density test result available time since test sampling. seed RNG seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.count_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply delay distributions to count data — sim_apply_delay.count_data","text":"long format set counts infections, symptom, admitted, death, sample (tests taken), results (test results).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.count_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply delay distributions to count data — sim_apply_delay.count_data","text":"","code":"tmp = sim_poisson_model(seed=100) %>% sim_apply_delay()  if(interactive()) {   plot_counts(tmp, mapping=ggplot2::aes(colour=statistic))+     ggplot2::geom_line() }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply delay distribution to count or linelist data — sim_apply_delay","title":"Apply delay distribution to count or linelist data — sim_apply_delay","text":"Events include symptom onset, admission, death, test sampling, test processing","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply delay distribution to count or linelist data — sim_apply_delay","text":"","code":"sim_apply_delay(   df,   ...,   fn_p_symptomatic = ~0.5,   fn_p_admitted = ~0.1,   fn_p_died = ~0.05,   fn_p_tested = ~0.8,   seed = Sys.time() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply delay distribution to count or linelist data — sim_apply_delay","text":"df line list dataframe arising e.g. sim_branching_process() - EITHER: dataframe columns: id (unique_id) - Patient level unique id time (ggoutbreak::time_period) - Time infection. `time_period` grouping allowed. columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings allowed). ... Named arguments passed sim_apply_delay.linelist fn_symptom_delay,fn_admission_delay,fn_death_delay function calculates time event onset infection. called vector infection times first parameter (time) columns df also available well symptomatic,died,admitted flags. function must vectorised inputs (consume additional inputs ...). purrr style lambda OK e.g. ~ stats::rgamma(.x, shape = 3), first parameter infection time. discrete probability profile can use cfg_ip_sampler_rng(ip_symptoms). fn_sample_delay function returns time either symptom onset (symptomatic) infection (asymptomatic) sample taken. (N.B. might better screening test probability plus screening test frequency rather overloading .) fn_result_delay Identical functions except first parameter sample_time rather time infection. time sampling result available. Named arguments passed sim_apply_delay.count_data fn_symptom_profile,fn_admission_profile,fn_death_profile function takes time returns probability density symptoms, admissions, deaths time since infection (.e. tau) ip delay distribution. possible good idea pre-compute distributions need assigned every line input can slow. fn_sample_profile function takes time returns probability density test sample taken time since symptoms. fn_result_profile function takes time returns probability density test result available time since test sampling. fn_p_symptomatic, fn_p_admitted, fn_p_died, fn_p_tested Function returns probability 0 1 row input dataframe. purrr style lambda OK (e.g. ~ 1 always true) first parameter time infection. function must vectorised inputs (consume additional inputs ...) seed RNG seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply delay distribution to count or linelist data — sim_apply_delay","text":"Depends input, either: wide format line list additional XX, XX_time XX_delay columns, set statistics generated. long format set counts different statistics .e. infections, symptoms, admission, death, sample (tests taken), results (test results) .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply delay distribution to count or linelist data — sim_apply_delay","text":"","code":"tmp = sim_branching_process(   changes = tibble::tibble(t = c(0,20,40,60,80,110), R = c(1.8,1.5,0.9,1.5,0.8,1.2)),   max_time = 120,   seed = 100 ) #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> complete  tmp2 = tmp %>% sim_apply_delay() tmp2 %>% dplyr::glimpse() #> Rows: 37,440 #> Columns: 20 #> $ time                <time_prd> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … #> $ id                  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,… #> $ generation_interval <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ infector            <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ generation          <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ symptom             <lgl> FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FAL… #> $ symptom_delay       <dbl> NA, 4.849882, NA, NA, NA, NA, 2.836731, NA, 2.8122… #> $ symptom_time        <time_prd> NA, 4.849882, NA, NA, NA, NA, 2.836731, NA, 2… #> $ admitted            <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F… #> $ admitted_delay      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ admitted_time       <time_prd> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… #> $ death               <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F… #> $ death_delay         <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ death_time          <time_prd> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… #> $ tested              <lgl> FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE,… #> $ sample_delay        <dbl> NA, 1.06009214, NA, NA, 0.26953796, 2.49234516, 0.… #> $ sample_time         <time_prd> NA, 1.06009214, NA, NA, 0.26953796, 2.4923451… #> $ result              <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR… #> $ result_delay        <dbl> 0.57895265, 1.16839769, 0.95587118, 0.02472337, 0.… #> $ result_time         <time_prd> NA, 2.2284898, NA, NA, 0.5949936, 5.1493528, …"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.linelist.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","title":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","text":"Events include symptom onset, admission, death, test sampling, test processing","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.linelist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","text":"","code":"sim_apply_delay.linelist(   df = i_sim_linelist,   ...,   fn_p_symptomatic = ~0.5,   fn_symptom_delay = ~rgamma2(.x, mean = 5),   fn_p_admitted = ~0.1,   fn_admission_delay = cfg_weekly_gamma_rng(c(8, 8, 8, 8, 8, 9.5, 9)),   fn_p_died = ~0.05,   fn_death_delay = ~rgamma2(.x, mean = 14),   fn_p_tested = ~0.8,   fn_sample_delay = cfg_weekly_gamma_rng(c(1, 1, 1, 1, 1, 1.5, 1.4)),   fn_result_delay = cfg_weekly_gamma_rng(c(1, 1, 1, 1, 1, 1.6, 1.5)),   seed = Sys.time() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.linelist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","text":"df line list dataframe arising e.g. sim_branching_process() - dataframe columns: id (unique_id) - Patient level unique id time (ggoutbreak::time_period) - Time infection. `time_period` grouping allowed. fn_p_symptomatic, fn_p_admitted, fn_p_died, fn_p_tested Function returns probability 0 1 row input dataframe. purrr style lambda OK (e.g. ~ 1 always true) first parameter time infection. function must vectorised inputs (consume additional inputs ...) fn_symptom_delay, fn_admission_delay, fn_death_delay, function calculates time event onset infection. called vector infection times first parameter (time) columns df also available well symptomatic,died,admitted flags. function must vectorised inputs (consume additional inputs ...). purrr style lambda OK e.g. ~ stats::rgamma(.x, shape = 3), first parameter infection time. discrete probability profile can use cfg_ip_sampler_rng(ip_symptoms). fn_sample_delay function returns time either symptom onset (symptomatic) infection (asymptomatic) sample taken. (N.B. might better screening test probability plus screening test frequency rather overloading .) fn_result_delay Identical functions except first parameter sample_time rather time infection. time sampling result available. seed RNG seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.linelist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","text":"line list additional time delay columns.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_apply_delay.linelist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment a line list of infection with a set of events — sim_apply_delay.linelist","text":"","code":"tmp = sim_branching_process(   changes = tibble::tibble(t = c(0,20,40,60,80,110), R = c(1.8,1.5,0.9,1.5,0.8,1.2)),   max_time = 120,   seed = 100 ) #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> complete  tmp2 = tmp %>% sim_apply_delay() tmp2 %>% dplyr::glimpse() #> Rows: 37,440 #> Columns: 20 #> $ time                <time_prd> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … #> $ id                  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,… #> $ generation_interval <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ infector            <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ generation          <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ symptom             <lgl> TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALS… #> $ symptom_delay       <dbl> 5.532451, 2.100372, NA, NA, NA, 6.406800, NA, NA, … #> $ symptom_time        <time_prd> 5.532451, 2.100372, NA, NA, NA, 6.406800, NA,… #> $ admitted            <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F… #> $ admitted_delay      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ admitted_time       <time_prd> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… #> $ death               <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F… #> $ death_delay         <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ death_time          <time_prd> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… #> $ tested              <lgl> TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, … #> $ sample_delay        <dbl> 1.39117138, 0.07652358, NA, NA, 1.81722118, 0.0822… #> $ sample_time         <time_prd> 1.39117138, 0.07652358, NA, NA, 1.81722118, 0… #> $ result              <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR… #> $ result_delay        <dbl> 1.5148588, 0.1075484, 4.0113720, 1.7979460, 1.9582… #> $ result_time         <time_prd> 2.9060301, 0.1840719, NA, NA, 3.7754300, 0.19…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_branching_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","title":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","text":"Generate line list branching process model parametrised reproduction number","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_branching_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","text":"","code":"sim_branching_process(   changes = tibble::tibble(t = c(0, 40), rt = c(2.5, 0.8)),   max_time = 80,   seed = Sys.time(),   fn_Rt = cfg_step_fn(changes),   fn_ip = ~test_ip,   fn_kappa = ~1,   imports_df = NULL,   fn_imports = ~ifelse(.x == 0, 30, 0),   fn_list_next_gen = list(),   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_branching_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","text":"changes dataframe containing t time column R reproduction number parameter. parameter optional fn_Rt specified max_time maximum duration simulation seed random seed fn_Rt can specified instead changes df. vectorised function accepts time parameter returns reproduction number. changes specified takes preference. fn_ip function takes input vector t (/class) returns infectivity profile times t. fn_kappa vectorised function taking t imported case metadata returning dispersion parameter controlling likelihood individual super-spreading. must 1 Inf 1 standard poisson dispersion larger values representing dispersion. imports_df data frame containing minimally time count columns plus metadata imports additional columns. Metadata columns can inform fn_Rt,fn_kappa fn_ip functions additional parameters. fn_imports time varying function defines number infected importations. imports_df defined used instead fn_list_next_gen named list functions. name corresponds metadata columns simulation, function purrr style mapping replace old value named column new one. function can generated cfg_transition_fn() transition probability matrix involved, can specified directly case_when style function. function must vectorised assume grouping structure. function named parameters can reference metadata columns, time (t). rcategorical() function may useful scenario. ... used","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_branching_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","text":"line list cases simulated outbreak dataframe containing following columns: id (unique_id) - Patient level unique id time (ggoutbreak::time_period) - Time infection. `time_period` grouping possible.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_branching_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a line list from a branching process model parametrised by reproduction number — sim_branching_process","text":"","code":"tmp = sim_branching_process(   changes = tibble::tibble(t = c(0,40), R = c(1.5,0.8)),   max_time = 120,   seed = 100,   fn_imports = ~ ifelse(.x<10,1,0) ) #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> complete  if(interactive()) {   plot_cases(tmp, mapping=ggplot2::aes(fill=as.factor(generation)),linewidth=0.1) }  # imports can also be specified as a dataframe, which allows additional # metadata in the line list. An example of which is as follows: imports_df = tibble::tribble(   ~time, ~variant, ~count,   0:4, \"wild-type\", 100,   10:14, \"alpha\", 5, )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_convolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a time varying probability and convolution to count data — sim_convolution","title":"Apply a time varying probability and convolution to count data — sim_convolution","text":"Standard convolution assumes one delay distribution. actually see reality delays can depend factors, including day week. function applies convolution input time-series convolution expressed function (usually time, can anything input dataframe). convolution sampled using poisson negative binomial","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_convolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a time varying probability and convolution to count data — sim_convolution","text":"","code":"sim_convolution(   df = i_sim_count_data,   p_fn,   delay_fn,   ...,   input = \"infections\",   output,   kappa = 1,   from = c(\"count\", \"rate\") )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_convolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a time varying probability and convolution to count data — sim_convolution","text":"df count dataframe e.g. sim_poisson_model() sim_summarise_linelist() - dataframe columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings allowed). p_fn function takes time parameter potentially returns probability observation given something occurs. -op parameter ~ 1. delay_fn function takes time returns probability observation (given occurred) time since infection (.e. tau) ip delay distribution. sum 1 (e.g. mapping incidence prevalence) combination p_fn delay_fn less easy interpret. behave sensibly p changes halfway convolution. See cfg_weekly_ip_fn() cfg_gamma_ip_fn() helper functions construct parameter. -op parameter ~ ifelse(.x==0,1,0). ... used input input statistic output output statistic kappa dispersion. scaled poisson dispersion 1. Values must 0 (dispersion), 1 (poisson dispersion) greater 1 -dispersion. Controls base future counts previous counts underlying rate, defaults count rate possibility want base convolution theoretical value rather observed cases. Either way convolution generates new rate turn sampled poisson negative binomial count.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_convolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a time varying probability and convolution to count data — sim_convolution","text":"return result applying convolution data.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_convolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a time varying probability and convolution to count data — sim_convolution","text":"","code":"weekday_delay = make_gamma_ip(median_of_mean = 5, median_of_sd = 2) weekend_delay = make_gamma_ip(median_of_mean = 6, median_of_sd = 2)  delay_fn = ~ ifelse(.x %% 7 %in% c(6,7), list(weekend_delay), list(weekday_delay)) p_fn = ~ ifelse(.x < 20, 0.5, 0.75)  data = tibble::tibble(     time=1:40,     count = rep(100,40),     rate = rep(100,40),     statistic=\"infections\") %>% dplyr::group_by(statistic) delayed = data %>%     sim_convolution(p_fn,delay_fn,output=\"delayed\") %>%     dplyr::filter(statistic==\"delayed\") if (interactive()) ggplot2::ggplot(delayed,ggplot2::aes(x=time))+   ggplot2::geom_line(ggplot2::aes(y=rate))+   ggplot2::geom_line(ggplot2::aes(y=count))  # other example delay functions delay_fn = cfg_gamma_ip_fn( ~ ifelse(.x<5, 8, 4))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a time-varying probability and delay function to linelist data — sim_delay","title":"Apply a time-varying probability and delay function to linelist data — sim_delay","text":"Apply time-varying probability delay function linelist data","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a time-varying probability and delay function to linelist data — sim_delay","text":"","code":"sim_delay(   df = i_sim_linelist,   p_fn,   delay_fn,   input = \"time\",   output = \"event\",   seed = Sys.time() )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a time-varying probability and delay function to linelist data — sim_delay","text":"df line list dataframe arising e.g. sim_branching_process() - dataframe columns: id (unique_id) - Patient level unique id time (ggoutbreak::time_period) - Time infection. `time_period` grouping allowed. p_fn Function returns probability 0 1 row input dataframe. purrr style lambda OK (e.g. ~ 1 always true) first parameter time infection. function must vectorised inputs (consume additional inputs ...) delay_fn function calculates time event onset input time. called vector infection times first parameter (time) columns df also available well symptomatic,died,admitted flags. function must vectorised inputs (consume additional inputs ...). purrr style lambda OK e.g. ~ stats::rgamma(.x, shape = 3), first parameter infection time. discrete probability profile can use cfg_ip_sampler_rng(ip_symptoms) without tilde. input time column calculate delay . output output column set name (defaults \"event\") seed RNG seed reproducibility","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a time-varying probability and delay function to linelist data — sim_delay","text":"line list extra columns prefix given output, specifying whether event observed, delay simulation time.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a time-varying probability and delay function to linelist data — sim_delay","text":"","code":"tmp = sim_branching_process(   changes = tibble::tibble(t = c(0,20,40,60,80,110), R = c(1.8,1.5,0.9,1.5,0.8,1.2)),   max_time = 120,   seed = 100 ) #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> complete  tmp2 = tmp %>% sim_delay(   p_fn = ~ rbern(.x, 0.8),   delay_fn = ~ rgamma2(.x, mean = 5), ) tmp2 %>% dplyr::glimpse() #> Rows: 37,440 #> Columns: 8 #> $ time                <time_prd> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … #> $ id                  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,… #> $ generation_interval <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ infector            <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ generation          <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ event               <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FA… #> $ event_delay         <dbl> 6.865892, 4.961140, 3.374736, 1.466048, 4.545053, … #> $ event_time          <time_prd> 6.865892, 4.961140, 3.374736, 1.466048, 4.545…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delayed_observation.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a right censoring to count data. — sim_delayed_observation","title":"Apply a right censoring to count data. — sim_delayed_observation","text":"Delayed observations means , example case attributed disease delay right censoring data. can complex patterns right censoring example observations batched published weekly. COVID UK death data published frequently retrospectively reported monthly intervals, depending patient died, lead complex time dependent biases death data. Given description delay, function simulate effect count data. another example delays reporting test results run Christmas resulted case rates apparently dropping schools broke . affected timing 2021 Christmas lockdown.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delayed_observation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a right censoring to count data. — sim_delayed_observation","text":"","code":"sim_delayed_observation(   df = i_sim_count_data,   delay_fn,   ...,   input = \"infections\",   output = input,   max_time = max(df$time) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delayed_observation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a right censoring to count data. — sim_delayed_observation","text":"df count dataframe e.g. sim_poisson_model() sim_summarise_linelist() delay_fn function takes time returns probability observation (given occurred) time since infection (.e. tau) ip delay distribution. sum 1 (e.g. mapping incidence prevalence) behave fraction events observed (observed multiple times). See cfg_weekly_ip_fn() cfg_gamma_ip_fn() helper functions construct parameter. ... used input input statistic (defaults count) output output column name (defaults input) max_time date censoring taking place.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delayed_observation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a right censoring to count data. — sim_delayed_observation","text":"result applying right censoring data.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_delayed_observation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a right censoring to count data. — sim_delayed_observation","text":"","code":"weekday_delay = make_gamma_ip(median_of_mean = 5, median_of_sd = 2) weekend_delay = make_gamma_ip(median_of_mean = 7, median_of_sd = 2)  delay_fn = ~ ifelse(.x %% 7 %in% c(6,7), list(weekend_delay), list(weekday_delay))  data = tibble::tibble(time=1:40, count = rep(100,40), statistic=\"infections\") %>%   dplyr::group_by(statistic) %>%   sim_delayed_observation(delay_fn,output=\"delayed\")  if (interactive()) ggplot2::ggplot(data,ggplot2::aes(x=time,colour=statistic))+   ggplot2::geom_line(ggplot2::aes(y=count))"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the events dataframe from a simulation output — sim_events","title":"Extract the events dataframe from a simulation output — sim_events","text":"simulations include details major changes simulation input parameters, particularly step functions. set events can directly represented ggoutbreak plot using events parameter","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the events dataframe from a simulation output — sim_events","text":"","code":"sim_events(df)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the events dataframe from a simulation output — sim_events","text":"df output ggoutbreak simulation","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the events dataframe from a simulation output — sim_events","text":"events dataframe","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the events dataframe from a simulation output — sim_events","text":"","code":"sim_events(test_poisson_rt) #> # A tibble: 2 × 4 #> # Groups:   statistic [1] #>   statistic  label   start      end   #>   <chr>      <chr>   <date>     <lgl> #> 1 infections Rt=2.50 2019-12-29 NA    #> 2 infections Rt=0.80 2020-02-07 NA"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_geom_function.html","id":null,"dir":"Reference","previous_headings":"","what":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","title":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","text":"simulations typically parameterised time varying $R_t$ growth rate, relationship embedded simulation outputs. Plotting value default ggoutbreak plots requires extracting function rescaling align dates, function .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_geom_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","text":"","code":"sim_geom_function(df, ...)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_geom_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","text":"df output ggoutbreak simulation, typically going input estimator. ... Named arguments passed ggplot2::geom_function mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data Ignored stat_function(), use. stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). geom geometric object use display data layer. using stat_*() function construct layer, geom argument can used override default coupling stats geoms. geom argument accepts following: Geom ggproto subclass, example GeomPoint. string naming geom. give geom string, strip function name geom_ prefix. example, use geom_point(), give geom \"point\". information ways specify geom, see layer geom documentation. fun Function use. Either 1) anonymous function base rlang formula syntax (see rlang::as_function()) 2) quoted character name referencing function; see examples. Must vectorised. xlim Optionally, specify range function. n Number points interpolate along x axis. args List additional arguments passed function defined fun.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_geom_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","text":"geom_function parameter","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_geom_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The principal input function to a ggoutbreak simulation as a ggplot2 layer. — sim_geom_function","text":"","code":"ggplot2::ggplot()+   sim_geom_function(test_poisson_rt, xlim=as.Date(\"2019-12-29\")+c(0,80))+   ggplot2::scale_x_date()"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","title":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","text":"Generate multinomial outbreak defined per class growth rates poisson model","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","text":"","code":"sim_multinomial(   changes = tibble::tibble(t = c(0, 20, 40, 60, 80), variant1 = c(0.1, 0, -0.1, 0, 0.1),     variant2 = c(0.15, 0.05, -0.05, -0.01, 0.05), variant3 = c(0, 0.05, -0.05, +0.05,     -0.05), ),   initial = c(100, 100, 100),   time_unit = \"1 day\",   ... )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","text":"changes list time points column t growth rates per week per class, columns. initial size initial outbreak per class. one entry per class time_unit e.g. daily weekly time series: \"1 day\", \"7 days\" ... Named arguments passed sim_poisson_model fn_imports function takes input vector t returns number imported cases times t. seed random seed kappa dispersion parameter. 1 dispersion (compared poisson), smaller values mean dispersion. max_time desired length time series, fn_growth function takes input vector t returns growth rates times t","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","text":"case count time series including class, count time columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_multinomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a multinomial outbreak defined by per class growth rates and a poisson model — sim_multinomial","text":"","code":"if (interactive()) {   plot_counts(     sim_multinomial() %>% dplyr::glimpse()   ) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_Rt_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","title":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","text":"Generate outbreak case count series defined Reproduction number using poisson model.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_Rt_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","text":"","code":"sim_poisson_Rt_model(   changes = tibble::tibble(t = c(0, 40), rt = c(2.5, 0.8)),   kappa = 1,   max_time = 80,   seed = Sys.time(),   fn_Rt = cfg_step_fn(changes),   fn_imports = ~ifelse(.x == 0, 30, 0),   fn_ip = ~test_ip,   time_unit = \"1 day\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_Rt_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","text":"changes dataframe holding change time points (t) reproduction number (rt) columns kappa dispersion parameter. 1 dispersion (compared poisson), smaller values mean dispersion. max_time desired length time series, seed random seed fn_Rt function takes input vector t returns instantaneous reproduction number time t fn_imports function takes input vector t returns number imported cases times t. fn_ip function takes input vector t returns infectivity profile times t. time_unit e.g. daily weekly time series: \"1 day\", \"7 days\"","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_Rt_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","text":"dataframe case counts dataframe containing following columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings may present).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_Rt_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an outbreak case count series defined by Reproduction number using a poisson model. — sim_poisson_Rt_model","text":"","code":"tmp = sim_poisson_Rt_model(kappa=1, seed=100, fn_imports = ~ ifelse(.x %in% c(0,50),100,0))  if (interactive()) {   ggplot2::ggplot(tmp,ggplot2::aes(x=time,y=count))+ggplot2::geom_point()+     ggplot2::geom_line() }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","title":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","text":"Generate outbreak case count series defined growth rates using poisson model.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","text":"","code":"sim_poisson_model(   changes = tibble::tibble(t = c(0, 20, 40, 60, 80), growth = c(0.1, 0, -0.1, 0, 0.1)),   kappa = 1,   max_time = 104,   seed = Sys.time(),   fn_growth = cfg_step_fn(changes),   fn_imports = ~ifelse(.x == 0, 100, 0),   time_unit = \"1 day\" )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","text":"changes dataframe holding change time points (t) growth rate per week (growth) columns kappa dispersion parameter. 1 dispersion (compared poisson), smaller values mean dispersion. max_time desired length time series, seed random seed fn_growth function takes input vector t returns growth rates times t fn_imports function takes input vector t returns number imported cases times t. time_unit e.g. daily weekly time series: \"1 day\", \"7 days\"","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","text":"dataframe case counts dataframe containing following columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings may present).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_poisson_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an outbreak case count series defined by growth rates using a poisson model. — sim_poisson_model","text":"","code":"tmp2 = sim_poisson_model(seed=100, fn_imports = ~ ifelse(.x %in% c(0,50),100,0))  if (interactive()) {   ggplot2::ggplot(tmp2)+ggplot2::geom_point(ggplot2::aes(x=time,y=count)) }"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_summarise_linelist.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise a line list — sim_summarise_linelist","title":"Summarise a line list — sim_summarise_linelist","text":"function converts line list daily count incident cases, plus infections, admissions, deaths, test samples, test results present. Censoring counts can also defined. Whilst summarising various network measures forward looking case reproduction number also calculated.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_summarise_linelist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise a line list — sim_summarise_linelist","text":"","code":"sim_summarise_linelist(   df = i_sim_linelist,   ...,   censoring = list(),   max_time = max(df$time) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_summarise_linelist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise a line list — sim_summarise_linelist","text":"df line list dataframe arising e.g. sim_branching_process() - dataframe columns: id (unique_id) - Patient level unique id time (ggoutbreak::time_period) - Time infection. `time_period` grouping allowed. ... grouping include summarisation. censoring named list column names (without _time suffix) kind created sim_delay() sim_apply_delay(), associated function defining delay reporting column experiences. function t (.x purrr lambda) refer XX_time column, .e. whenever event reported happened time simulation infection time. N.B. since infection observed censor . max_time censoring time observation.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_summarise_linelist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise a line list — sim_summarise_linelist","text":"count data frame additional statistics. dataframe containing following columns: statistic (character) - identifier statistic, whether infections, admissions, deaths count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time `time_period` Minimally grouped : statistic (groupings may present).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_summarise_linelist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise a line list — sim_summarise_linelist","text":"","code":"sim = sim_branching_process(   changes = tibble::tibble(t = c(0,40), R = c(1.7,0.8)),   max_time = 120,   seed = 100,   fn_imports = ~ ifelse(.x==0,100,0) ) #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> complete  tmp = sim %>% sim_summarise_linelist()  p1 = plot_counts(tmp)  p2 = ggplot2::ggplot(tmp, ggplot2::aes(x=as.Date(time)))+   ggplot2::geom_point(ggplot2::aes(y=rt.case,colour=\"case\"))+   ggplot2::geom_point(ggplot2::aes(y=rt.inst,colour=\"instantaneous\"))+   ggplot2::geom_line(ggplot2::aes(y=rt.weighted))+   ggplot2::coord_cartesian(ylim=c(0,3.5))+   ggplot2::xlab(NULL)  patchwork::wrap_plots(p1,p2,ncol=1,axes=\"collect\")"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_test_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","title":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","text":"time-series statistical noise useful testing things. fixed known value infections growth rate (fixed 0.05 -0.05 per day), instantaneous reproduction number based provided infectivity profile.  fixed denominator gives known proportion relative growth rate growth rate.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_test_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","text":"","code":"sim_test_data(ip = test_ip, duration = 500, period = 50)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_test_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","text":"ip infectivity profile. uncertainty collapsed central distribution. duration total length time-series period duration positive negative growth phase","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_test_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","text":"time series count, incidence, growth, rt, proportion relative.growth columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/sim_test_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a simple time-series of cases based on a growth rate step function — sim_test_data","text":"","code":"sim_test_data() %>% dplyr::glimpse() #> Rows: 501 #> Columns: 8 #> $ time            <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,… #> $ growth          <dbl> 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, … #> $ incidence       <dbl> 100.0000, 105.1271, 110.5171, 116.1834, 122.1403, 128.… #> $ rt              <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #> $ denom           <dbl> 12182, 12182, 12182, 12182, 12182, 12182, 12182, 12182… #> $ proportion      <dbl> 0.008208500, 0.008629359, 0.009071795, 0.009536916, 0.… #> $ relative.growth <dbl> 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, … #> $ count           <dbl> 100, 105, 111, 116, 122, 128, 135, 142, 149, 157, 165,…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/summarise_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a single infectivity profile from multiple bootstraps — summarise_ip","title":"Generate a single infectivity profile from multiple bootstraps — summarise_ip","text":"Generate single infectivity profile multiple bootstraps","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/summarise_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a single infectivity profile from multiple bootstraps — summarise_ip","text":"","code":"summarise_ip(ip = i_empirical_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/summarise_ip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a single infectivity profile from multiple bootstraps — summarise_ip","text":"ip infectivity profile summarise. a0 a1 columns optional tau given. - dataframe columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/summarise_ip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a single infectivity profile from multiple bootstraps — summarise_ip","text":"infectivity profile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_bpm.html","id":null,"dir":"Reference","previous_headings":"","what":"An example of the linelist output of the branching process model simulation — test_bpm","title":"An example of the linelist output of the branching process model simulation — test_bpm","text":"generated using test_ip infectivity profile also includes delay symptom onset random gamma distributed quantity mean 6 standard deviation 2","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_bpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An example of the linelist output of the branching process model simulation — test_bpm","text":"","code":"data(test_bpm)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_bpm.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"An example of the linelist output of the branching process model simulation — test_bpm","text":"dataframe containing following columns: time (.time_period) - time column id (integer) - id per individual generation_interval (numeric) - generation_interval column infector (integer) - infector id generation (numeric) - generation column symptom_onset (logical) - flag onset symptoms symptom_onset_delay (numeric) - time onset symptoms infection symptom_onset_time (.time_period) - time symptom onset 333126 rows 8 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ip.html","id":null,"dir":"Reference","previous_headings":"","what":"A test infectivity profile generated from a set of discretised gamma distributions with parameters mean 5 (95% CI 4-6) and sd 2 (95% CI 1.5-2.5). — test_ip","title":"A test infectivity profile generated from a set of discretised gamma distributions with parameters mean 5 (95% CI 4-6) and sd 2 (95% CI 1.5-2.5). — test_ip","text":"test infectivity profile generated set discretised gamma distributions parameters mean 5 (95% CI 4-6) sd 2 (95% CI 1.5-2.5).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A test infectivity profile generated from a set of discretised gamma distributions with parameters mean 5 (95% CI 4-6) and sd 2 (95% CI 1.5-2.5). — test_ip","text":"","code":"data(test_ip)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ip.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A test infectivity profile generated from a set of discretised gamma distributions with parameters mean 5 (95% CI 4-6) and sd 2 (95% CI 1.5-2.5). — test_ip","text":"dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability infection previous time period time tau (numeric) - time index probability relates (days) a0 (numeric) - beginning time period a1 (numeric) - end time period Grouped : boot. 2000 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_growth_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"A simulation dataset determined by a step function of growth rates. This is useful for demonstrating growth rate estimators. — test_poisson_growth_rate","title":"A simulation dataset determined by a step function of growth rates. This is useful for demonstrating growth rate estimators. — test_poisson_growth_rate","text":"simulation dataset determined step function growth rates. useful demonstrating growth rate estimators.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_growth_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A simulation dataset determined by a step function of growth rates. This is useful for demonstrating growth rate estimators. — test_poisson_growth_rate","text":"","code":"data(test_poisson_growth_rate)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_growth_rate.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A simulation dataset determined by a step function of growth rates. This is useful for demonstrating growth rate estimators. — test_poisson_growth_rate","text":"dataframe containing following columns: time (.time_period) - time column growth (numeric) - time varying growth rate column (input parameter) imports (numeric) - imports column rate (numeric) - poisson rate column count (integer) - sampled count column statistic (character) - statistic column (infections) Minimally grouped : statistic (groupings allowed). 105 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"An example of the linelist output of the poisson model simulation with defined $R_t$ — test_poisson_rt","title":"An example of the linelist output of the poisson model simulation with defined $R_t$ — test_poisson_rt","text":"generated using test_ip infectivity profile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An example of the linelist output of the poisson model simulation with defined $R_t$ — test_poisson_rt","text":"","code":"data(test_poisson_rt)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"An example of the linelist output of the poisson model simulation with defined $R_t$ — test_poisson_rt","text":"dataframe containing following columns: time (.time_period) - time column rt (numeric) - time varying rt column (parameters) imports (numeric) - imports column rate (numeric) - poisson rate column (underlying infection rate) count (integer) - count column statistic (character) - statistic column 81 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_2class.html","id":null,"dir":"Reference","previous_headings":"","what":"The test_poisson_rt_2class dataset — test_poisson_rt_2class","title":"The test_poisson_rt_2class dataset — test_poisson_rt_2class","text":"test_poisson_rt_2class dataset","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_2class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The test_poisson_rt_2class dataset — test_poisson_rt_2class","text":"","code":"data(test_poisson_rt_2class)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_2class.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The test_poisson_rt_2class dataset — test_poisson_rt_2class","text":"dataframe containing following columns: time (.time_period) - time column rt (numeric) - rt column imports (numeric) - imports column rate (numeric) - rate column count (integer) - count column statistic (character) - statistic column class (enum(one,two)) - class column denom (integer) - denom column Minimally grouped : class (groupings allowed). 322 rows 8 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_smooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Output of a poisson model simulation with a smooth function for $R_t$ defined as R(t) = e^(sin(t/80*pi)^4-0.25)). This is a relatively unchallenging test data set that should not pose a problem for smooth estimators. — test_poisson_rt_smooth","title":"Output of a poisson model simulation with a smooth function for $R_t$ defined as R(t) = e^(sin(t/80*pi)^4-0.25)). This is a relatively unchallenging test data set that should not pose a problem for smooth estimators. — test_poisson_rt_smooth","text":"generated using central value test_ip infectivity profile","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Output of a poisson model simulation with a smooth function for $R_t$ defined as R(t) = e^(sin(t/80*pi)^4-0.25)). This is a relatively unchallenging test data set that should not pose a problem for smooth estimators. — test_poisson_rt_smooth","text":"","code":"data(test_poisson_rt_smooth)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_poisson_rt_smooth.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Output of a poisson model simulation with a smooth function for $R_t$ defined as R(t) = e^(sin(t/80*pi)^4-0.25)). This is a relatively unchallenging test data set that should not pose a problem for smooth estimators. — test_poisson_rt_smooth","text":"dataframe containing following columns: time (.time_period) - time column rt (numeric) - time varying rt column (parameters) imports (numeric) - imports column rate (numeric) - poisson rate column (underlying infection rate) count (integer) - count column statistic (character) - statistic column Minimally grouped : statistic (groupings allowed). 161 rows 6 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_serial.html","id":null,"dir":"Reference","previous_headings":"","what":"A serial interval estimated from simulated data — test_serial","title":"A serial interval estimated from simulated data — test_serial","text":"serial interval resampled first 1000 patients test_bpm dataset infector infectee symptoms. patients generated symptom delay mean 6 days SD 2 infection (discrete -dispersed gamma) infectivity profile mean 5 days SD 2 defined test_ip dataset. serial interval relevant estimation $R_t$ symptomatic case counts test_bpm dataset includes negative times, used EpiEstim.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_serial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A serial interval estimated from simulated data — test_serial","text":"","code":"data(test_serial)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_serial.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A serial interval estimated from simulated data — test_serial","text":"dataframe containing following columns: tau (numeric) - time delay symptoms infector infectee a0 (numeric) - a0 column a1 (numeric) - a1 column probability (numeric) - probability column boot (integer) - boot column Minimally grouped : boot (groupings allowed). 2166 rows 5 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"A test time series dataset, containing no statistical noise. — test_ts","title":"A test time series dataset, containing no statistical noise. — test_ts","text":"test time series dataset, containing statistical noise.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A test time series dataset, containing no statistical noise. — test_ts","text":"","code":"data(test_ts)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/test_ts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A test time series dataset, containing no statistical noise. — test_ts","text":"dataframe containing following columns: time (.time_period) - time column growth (numeric) - growth column incidence (numeric) - incidence column rt (numeric) - rt column denom (numeric) - denom column proportion (numeric) - proportion column relative.growth (numeric) - relative.growth column count (numeric) - count column grouping allowed. 501 rows 8 columns","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate time series data preserving the time series — time_aggregate","title":"Aggregate time series data preserving the time series — time_aggregate","text":"Aggregate time series data preserving time series","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate time series data preserving the time series — time_aggregate","text":"","code":"time_aggregate(   df = i_timestamped,   ...,   .groups = NULL,   .cols = NULL,   .fns = NULL )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate time series data preserving the time series — time_aggregate","text":"df optionally grouped time series. Grouping include time column. grouping works differently dplyr::summarise last level non-time groups lost operation, subgroup wish aggregate included grouping. ... set dplyr::summarise statements, additional parameters .fns .groups per dplyr::summarise .cols Optional tidyselect column specification dplyr::across. .fns given .cols parameter specified columns summarise automatically identified. Date columns dropped. want .cols ... must given .fns Optional set function specifications per dplyr::across","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate time series data preserving the time series — time_aggregate","text":"summarised time series preserving time column, grouping structure involving one fewer levels input","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_aggregate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate time series data preserving the time series — time_aggregate","text":"","code":"ggoutbreak::england_covid %>%   time_aggregate(count = sum(count), denom = sum(denom)) %>%   dplyr::glimpse() #> Rows: 1,410 #> Columns: 3 #> $ time  <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… #> $ count <dbl> 1, 0, 0, 1, 18, 0, 1, 0, 0, 3, 1, 1, 3, 1, 1, 0, 0, 0, 1, 0, 0, … #> $ denom <dbl> 19, 0, 0, 19, 342, 0, 19, 0, 0, 57, 19, 19, 57, 19, 19, 0, 0, 0,…  ggoutbreak::england_covid %>%   time_aggregate(.fns=mean) %>%   dplyr::glimpse() #> Rows: 1,410 #> Columns: 3 #> $ time  <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… #> $ count <dbl> 0.05263158, 0.00000000, 0.00000000, 0.05263158, 0.94736842, 0.00… #> $ denom <dbl> 1, 0, 0, 1, 18, 0, 1, 0, 0, 3, 1, 1, 3, 1, 1, 0, 0, 0, 1, 0, 0, …"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise data from a line list to a time-series of counts. — time_summarise","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"principally designed take record single events produce summary time-series count events group, class date. default behaviour guess cadence input data summarise event line list (set ) regular time-series counts use incidence growth rate estimates.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"","code":"time_summarise(   df = i_dated,   unit,   anchor = \"start\",   rectangular = FALSE,   ...,   .fill = list(count = 0) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"df line list data want summarise, optionally grouped. grouped group treated independently. remaining columns must contain date column may contain class column. count column present counts summed, otherwise individual row counted single event (line list) unit period e.g. \"1 week\" anchor one date, \"start\" \"end\" weekday name e.g. \"mon\" always one start time periods cutting rectangular resulting time series length groups? case can sure data complete subgroups, otherwise missing data treated zero counts. important leading trailing missing data one subgroup can due reporting delay subgroup, case rectangular time series erroneously fill zero counts missing data. ... specification dplyr::summary(...) - optional, provided count = dplyr::n() count = sum(count) performed. .fill list similar tidyr::complete default values fill variables .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"output depends whether input grouped class column. detailed output : dataframe containing following columns: denom (positive_integer) - Total test counts associated specified time frame count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period grouping allowed. minimal output input plain list dated events: dataframe containing following columns: count (positive_integer) - Positive case counts associated specified time frame time (ggoutbreak::time_period + group_unique) - (usually complete) set singular observations per unit time time_period grouping allowed.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"data given class column time series interpreted denominator, consisting different classes within time period. may subtypes (e.g. variants, serotypes) markers test positivity. either case resulting time series counts classes denominators combination. flexibility kinds summarisation raw data count based (e.g. means continuous variables) case slider package usually going better, time summarise look non overlapping time periods fixed lengths. another use case existing timeseries particular frequency aggregated another less frequent basis (e.g. moving daily timeseries weekly one). case input contain count column. mode checks made frequent events present summarisation result may include different numbers input periods (e.g. going weeks months may 4 5 weeks month). class column present classwise denominator calculated","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_summarise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise data from a line list to a time-series of counts. — time_summarise","text":"","code":"# a set of random dates with a class column: input = tibble::tibble(   class = rep(c(\"A\",\"B\"),1000),   date = as.Date(\"2020-01-01\")+sample.int(100,2000,TRUE) )  # summarise daily counts, including denominators: daily = time_summarise(input, unit=\"1 day\") %>% dplyr::glimpse() #> Rows: 200 #> Columns: 4 #> Groups: class [2] #> $ class <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\",… #> $ time  <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… #> $ count <int> 5, 8, 12, 14, 10, 9, 9, 7, 6, 11, 10, 8, 12, 7, 11, 9, 9, 18, 8,… #> $ denom <int> 12, 14, 27, 31, 20, 15, 18, 13, 19, 22, 20, 13, 19, 12, 24, 12, …  # summarise weekly counts, for sample data: time_summarise(input, unit=\"1 week\") %>% dplyr::glimpse() #> Rows: 30 #> Columns: 4 #> Groups: class [2] #> $ class <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\",… #> $ time  <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 1, 2, … #> $ count <int> 67, 61, 74, 72, 63, 79, 68, 72, 66, 67, 74, 73, 70, 71, 23, 70, … #> $ denom <int> 137, 118, 131, 149, 145, 142, 141, 142, 147, 140, 134, 144, 139,…  # summarise daily counts into weekly: time_summarise(daily, unit=\"1 week\") %>% dplyr::glimpse() #> N.B. time_summarise ignores existing time_period columns #> Rows: 30 #> Columns: 4 #> Groups: class [2] #> $ class <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\",… #> $ time  <time_prd> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 1, 2, … #> $ count <int> 67, 61, 74, 72, 63, 79, 68, 72, 66, 67, 74, 73, 70, 71, 23, 70, … #> $ denom <int> 137, 118, 131, 149, 145, 142, 141, 142, 147, 140, 134, 144, 139,…"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_to_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a set of time points to dates — time_to_date","title":"Convert a set of time points to dates — time_to_date","text":"Convert set time points dates","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_to_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a set of time points to dates — time_to_date","text":"","code":"time_to_date(   timepoints,   unit = attr(timepoints, \"unit\"),   start_date = attr(timepoints, \"start_date\") )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_to_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a set of time points to dates — time_to_date","text":"timepoints set numeric time points unit period / unit time points, extracted time points possible start_date zero day time series, extracted time points possible","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_to_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a set of time points to dates — time_to_date","text":"vector dates","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/time_to_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a set of time points to dates — time_to_date","text":"","code":"times = date_to_time(as.Date(\"2019-12-29\")+0:100, \"1 week\") dates = time_to_date(times)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/type.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Type coercion to a time_period class — type.time_period","title":"Type coercion to a time_period class — type.time_period","text":"Type coercion time_period class","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/type.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type coercion to a time_period class — type.time_period","text":"","code":"type.time_period(x)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/type.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type coercion to a time_period class — type.time_period","text":"x vector coerced time period","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/type.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type coercion to a time_period class — type.time_period","text":"time_period error","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/type.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type coercion to a time_period class — type.time_period","text":"","code":"type.time_period(1:100) #> time unit: day, origin: 2019-12-29 (a Sunday) #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wallinga_lipsitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","title":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","text":"function uses single empirical distribution infectivity profile / generation time. multiple provided average central value chosen (.e. propagate uncertainty infectivity profile)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wallinga_lipsitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","text":"","code":"wallinga_lipsitch(   r,   y = i_empirical_ip,   a1 = seq(0.5, length.out = length(y)),   a0 = dplyr::lag(a1, default = 0) )"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wallinga_lipsitch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","text":"r growth rate (may vector) y empirical infectivity profile either probability vector dataframe format: dataframe containing following columns: boot (anything + default(1)) - bootstrap identifier probability (proportion) - probability new event period. a0 (double) - beginning time period (days) a1 (double) - end time period (days) Minimally grouped : boot (groupings allowed). default value defined. a1 end time infectivity profile probability estimate (defaults 0.5,1.5,2.5,...). a0 start time infectivity profile probability estimate (defaults 0,0.5,1.5,...).","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wallinga_lipsitch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","text":"reproduction number estimate based r","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wallinga_lipsitch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the reproduction number from a growth rate estimate and an infectivity profile — wallinga_lipsitch","text":"","code":"# using a probability vector. wallinga_lipsitch(r=seq(-0.1,0.1,length.out=9), y=stats::dgamma(1:50, 5,2)) #> [1] 0.8524904 0.8882735 0.9247920 0.9620371 1.0000000 1.0386712 1.0780412 #> [8] 1.1181002 1.1588382  # using an infectivity profile wallinga_lipsitch(r=seq(-0.1,0.1,length.out=9), y=test_ip) #> [1] 0.5921890 0.6783048 0.7743792 0.8812971 1.0000000 1.1314881 1.2768221 #> [8] 1.4371252 1.6135852"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge distribution — wedge","title":"Wedge distribution — wedge","text":"wedge distribution domain 0 1 linear probability density function domain.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge distribution — wedge","text":"n number observations x vector quantiles q vector quantiles p vector probabilities log logical; TRUE, probabilities p given log(p). log.p logical; TRUE, probabilities p given log(p). lower.tail logical; TRUE (default), probabilities P[X<=x] otherwise P[X>x]. gradient -2 (left skewed) 2 (right skewed)","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge distribution — wedge","text":"vector probabilities, quantiles, densities samples.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge distribution — wedge","text":"rwedge can combined quantile functions skew standard distributions, introduce correlation weight certain parts distribution.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/wedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge distribution — wedge","text":"","code":"pwedge(seq(0,1,0.1), a=1) #>  [1] 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 dwedge(seq(0,1,0.1), a=1) #>  [1] 0.000 0.055 0.120 0.195 0.280 0.375 0.480 0.595 0.720 0.855 1.000 qwedge(c(0.25,0.5,0.75), a=-1) #> [1] 0.1771243 0.3819660 0.6339746  stats::cor(   stats::qnorm(rwedge(1000, a=2)),   stats::qnorm(rwedge(1000, a=-2)) ) #> [1] 0.01510746"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"Extract weekday, month quarter, Julian time   (days since origin).  generic functions: methods   internal date-time classes documented .","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"","code":"# S3 method for class 'time_period' weekdays(x, abbreviate = FALSE)"},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"x object inheriting class \"POSIXt\" \"Date\". abbreviate logical vector (possibly recycled).  names     abbreviated?","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"weekdays months return character   vector names locale use, .e., Sys.getlocale(\"LC_TIME\"). quarters returns character vector \"Q1\"   \"Q4\". julian returns number days (possibly fractional)   since origin, origin \"origin\" attribute.   time calculations R done ignoring leap-seconds.","code":""},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"components day month year   easy compute: just use .POSIXlt extract   relevant component.  Alternatively (especially components   desired character strings), use strftime.","code":""},{"path":[]},{"path":"https://ai4ci.github.io/ggoutbreak/reference/weekdays.time_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Parts of a POSIXt or Date Object — weekdays.time_period","text":"","code":"## first two are locale dependent: weekdays(.leap.seconds) #>  [1] \"Saturday\"  \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Saturday\"  #>  [7] \"Sunday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"    #> [13] \"Monday\"    \"Friday\"    \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  #> [19] \"Friday\"    \"Monday\"    \"Tuesday\"   \"Friday\"    \"Sunday\"    \"Thursday\"  #> [25] \"Sunday\"    \"Wednesday\" \"Sunday\"    months  (.leap.seconds) #>  [1] \"July\"    \"January\" \"January\" \"January\" \"January\" \"January\" \"January\" #>  [8] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"July\"    \"January\" #> [15] \"January\" \"January\" \"July\"    \"July\"    \"July\"    \"January\" \"July\"    #> [22] \"January\" \"January\" \"January\" \"July\"    \"July\"    \"January\" quarters(.leap.seconds) #>  [1] \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q1\" #> [16] \"Q1\" \"Q3\" \"Q3\" \"Q3\" \"Q1\" \"Q3\" \"Q1\" \"Q1\" \"Q1\" \"Q3\" \"Q3\" \"Q1\"  ## Show how easily you get month, day, year, day (of {month, week, yr}), ... : ## (remember to count from 0 (!): mon = 0..11, wday = 0..6,  etc !!)  ##' Transform (Time-)Date vector  to  convenient data frame : dt2df <- function(dt, dName = deparse(substitute(dt))) {     DF <- as.data.frame(unclass(as.POSIXlt( dt )))     `names<-`(cbind(dt, DF, deparse.level=0L), c(dName, names(DF))) } ## e.g., dt2df(.leap.seconds)    # date+time #>    .leap.seconds sec min hour mday mon year wday yday isdst zone gmtoff #> 1     1972-07-01   0   0    0    1   6   72    6  182     0  GMT      0 #> 2     1973-01-01   0   0    0    1   0   73    1    0     0  GMT      0 #> 3     1974-01-01   0   0    0    1   0   74    2    0     0  GMT      0 #> 4     1975-01-01   0   0    0    1   0   75    3    0     0  GMT      0 #> 5     1976-01-01   0   0    0    1   0   76    4    0     0  GMT      0 #> 6     1977-01-01   0   0    0    1   0   77    6    0     0  GMT      0 #> 7     1978-01-01   0   0    0    1   0   78    0    0     0  GMT      0 #> 8     1979-01-01   0   0    0    1   0   79    1    0     0  GMT      0 #> 9     1980-01-01   0   0    0    1   0   80    2    0     0  GMT      0 #> 10    1981-07-01   0   0    0    1   6   81    3  181     0  GMT      0 #> 11    1982-07-01   0   0    0    1   6   82    4  181     0  GMT      0 #> 12    1983-07-01   0   0    0    1   6   83    5  181     0  GMT      0 #> 13    1985-07-01   0   0    0    1   6   85    1  181     0  GMT      0 #> 14    1988-01-01   0   0    0    1   0   88    5    0     0  GMT      0 #> 15    1990-01-01   0   0    0    1   0   90    1    0     0  GMT      0 #> 16    1991-01-01   0   0    0    1   0   91    2    0     0  GMT      0 #> 17    1992-07-01   0   0    0    1   6   92    3  182     0  GMT      0 #> 18    1993-07-01   0   0    0    1   6   93    4  181     0  GMT      0 #> 19    1994-07-01   0   0    0    1   6   94    5  181     0  GMT      0 #> 20    1996-01-01   0   0    0    1   0   96    1    0     0  GMT      0 #> 21    1997-07-01   0   0    0    1   6   97    2  181     0  GMT      0 #> 22    1999-01-01   0   0    0    1   0   99    5    0     0  GMT      0 #> 23    2006-01-01   0   0    0    1   0  106    0    0     0  GMT      0 #> 24    2009-01-01   0   0    0    1   0  109    4    0     0  GMT      0 #> 25    2012-07-01   0   0    0    1   6  112    0  182     0  GMT      0 #> 26    2015-07-01   0   0    0    1   6  115    3  181     0  GMT      0 #> 27    2017-01-01   0   0    0    1   0  117    0    0     0  GMT      0 dt2df(Sys.Date() + 0:9) # date #>    Sys.Date() + 0:9 sec min hour mday mon year wday yday isdst zone gmtoff #> 1        2025-07-24   0   0    0   24   6  125    4  204     0  UTC      0 #> 2        2025-07-25   0   0    0   25   6  125    5  205     0  UTC      0 #> 3        2025-07-26   0   0    0   26   6  125    6  206     0  UTC      0 #> 4        2025-07-27   0   0    0   27   6  125    0  207     0  UTC      0 #> 5        2025-07-28   0   0    0   28   6  125    1  208     0  UTC      0 #> 6        2025-07-29   0   0    0   29   6  125    2  209     0  UTC      0 #> 7        2025-07-30   0   0    0   30   6  125    3  210     0  UTC      0 #> 8        2025-07-31   0   0    0   31   6  125    4  211     0  UTC      0 #> 9        2025-08-01   0   0    0    1   7  125    5  212     0  UTC      0 #> 10       2025-08-02   0   0    0    2   7  125    6  213     0  UTC      0  ##' Even simpler:  Date -> Matrix - dropping time info {sec,min,hour, isdst} d2mat <- function(x) simplify2array(unclass(as.POSIXlt(x))[4:7]) ## e.g., d2mat(seq(as.Date(\"2000-02-02\"), by=1, length.out=30)) # has R 1.0.0's release date #>       mday mon year wday #>  [1,]    2   1  100    3 #>  [2,]    3   1  100    4 #>  [3,]    4   1  100    5 #>  [4,]    5   1  100    6 #>  [5,]    6   1  100    0 #>  [6,]    7   1  100    1 #>  [7,]    8   1  100    2 #>  [8,]    9   1  100    3 #>  [9,]   10   1  100    4 #> [10,]   11   1  100    5 #> [11,]   12   1  100    6 #> [12,]   13   1  100    0 #> [13,]   14   1  100    1 #> [14,]   15   1  100    2 #> [15,]   16   1  100    3 #> [16,]   17   1  100    4 #> [17,]   18   1  100    5 #> [18,]   19   1  100    6 #> [19,]   20   1  100    0 #> [20,]   21   1  100    1 #> [21,]   22   1  100    2 #> [22,]   23   1  100    3 #> [23,]   24   1  100    4 #> [24,]   25   1  100    5 #> [25,]   26   1  100    6 #> [26,]   27   1  100    0 #> [27,]   28   1  100    1 #> [28,]   29   1  100    2 #> [29,]    1   2  100    3 #> [30,]    2   2  100    4  # \\donttest{ ## Julian Day Number (JDN, https://en.wikipedia.org/wiki/Julian_day) ## is the number of days since noon UTC on the first day of 4317 BCE. ## in the proleptic Julian calendar.  To more recently, in ## 'Terrestrial Time' which differs from UTC by a few seconds ## See https://en.wikipedia.org/wiki/Terrestrial_Time julian(Sys.Date(), -2440588) # from a day #> [1] 2460881 #> attr(,\"origin\") #> [1] -2440588 floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time #> [1] 2460881 # }"}]
