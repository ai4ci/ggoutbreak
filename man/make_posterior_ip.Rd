% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infectivity-profile.R
\name{make_posterior_ip}
\alias{make_posterior_ip}
\title{Make an infectivity profile from posterior samples}
\usage{
make_posterior_ip(
  ...,
  mean,
  sd,
  shape,
  rate,
  scale,
  epiestim_compat = FALSE,
  n_boots = 100
)
}
\arguments{
\item{...}{not used, must be empty}

\item{mean}{a vector of gamma distribution means}

\item{sd}{a vector of gamma distribution sds}

\item{shape}{a vector of gamma distribution shape parameters}

\item{rate}{a vector of gamma distribution rate parameters}

\item{scale}{a vector of gamma distribution scale parameters}

\item{epiestim_compat}{Use \code{EpiEstim} to generate the infectivity profiles.
A true value here results in an infectivity profile with probability of 0
for day 0.}

\item{n_boots}{if there are more posterior samples than this limit then a maximum
of \code{n_boots} ip distributions will be created (randomly sampled).}
}
\value{
a long format \code{ip} delay distribution
}
\description{
The infectivity profile is typically fitted to data by MCMC as a gamma
distribution. This function generates a discrete infectivity probability
distribution representing the chance that an infectee was infected on any
specific day after the infector was infected (given that the infectee was
infected), from posterior samples.
}
\details{
If using \code{EpiEstim} and \code{coarseDataTools::dic.fit.mcmc} the output of the
MCMC will be a S4 object with a \code{samples} slot, containing a dataframe of
\code{shape=var1} and \code{scale=var2} columns. to use this output with
\code{make_posterior_ip} invoke it like this:

\code{do.call(make_posterior_ip, SI_fit_clever@samples \%>\% dplyr::rename(shape=var1, scale=var2))}

N.b. only one combination of mean and sd, shape and rate, or shape and scale,
are required.
}
\examples{

tmp = make_posterior_ip(
  mean = stats::rnorm(100,5,0.1),
  sd = stats::rnorm(100,1.5,0.1)
)
tmp \%>\% dplyr::glimpse()
if (interactive()) plot_ip(tmp)

}
\concept{delay_distribution}
