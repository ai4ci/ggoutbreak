% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/periodic-times.R
\name{as.time_period}
\alias{as.time_period}
\alias{as.time_period.time_period}
\alias{as.time_period.Date}
\alias{as.time_period.numeric}
\alias{as.time_period.grates_epiweek}
\alias{as.time_period.grates_isoweek}
\alias{as.time_period.grates_period}
\alias{seq.time_period}
\alias{is.time_period}
\alias{date_to_time}
\alias{time_to_date}
\title{Time period S3 class methods}
\usage{
as.time_period(x, ...)

\method{as.time_period}{time_period}(x, unit = NULL, start_date = NULL, ...)

\method{as.time_period}{Date}(x, unit = NULL, anchor = NULL, ...)

\method{as.time_period}{numeric}(x, unit = NULL, start_date = NULL, ...)

\method{as.time_period}{grates_epiweek}(x, ...)

\method{as.time_period}{grates_isoweek}(x, ...)

\method{as.time_period}{grates_period}(x, ...)

\method{seq}{time_period}(from, to = from, ...)

is.time_period(x)

date_to_time(dates, unit = NULL, start_date = NULL)

time_to_date(
  timepoints,
  unit = attr(timepoints, "unit"),
  start_date = attr(timepoints, "start_date")
)
}
\arguments{
\item{x}{a vector of dates, numbers (may be integer or real) or a \code{time_period}
to convert to a \code{time_period}}

\item{...}{arguments passed to or from methods.}

\item{unit}{the length of one unit of time. This will be either a integer
number of days, or a specification such as "1 week", or another \code{time_period}.
If \code{x} is a \code{time_period}, and the unit is different to that of \code{x}
this will return a rescaled \code{time_period} using the new units.}

\item{start_date}{the zero time date as something that can be coerced to a
date. If the \code{x} input is already a \code{time_period} and this is different to its
\code{start_date} then \code{x} will be recalibrated to use the new start date.}

\item{anchor}{only relevant if \code{x} is a vector of dates, this is a date, or
\code{"start"} or \code{"end"} or a weekday name e.g.
\code{"mon"}. With the vector of dates in \code{x} it will use this anchor to find a reference date for
the time-series. If not provided then the current defaults will be used.
(see \code{\link[=set_defaults]{set_defaults()}})}

\item{from, to}{the starting and (maximal) end values of the
    sequence.  Of length \code{1} unless just \code{from} is supplied as
    an unnamed argument.}

\item{dates}{a vector of dates to convert to a \code{time_period}}

\item{timepoints}{a \code{time_period} vector to convert to a set of dates.}
}
\value{
a vector of class \code{time_period}
}
\description{
Time periods are just a zero based numeric representation of dates with a
time unit baked in. This allows variable length periods (e.g. days or weeks),
and fractional days to be represented in a consistent(ish) way between
things that want to deal in dates (like ggplot) and things that want to deal
in numbers (like model fitting)
}
\section{Functions}{
\itemize{
\item \code{seq(time_period)}: Create a sequence using \code{time_period}s

\item \code{is.time_period()}: Check is a \code{time_period}

\item \code{date_to_time()}: Convert a set of dates to numeric timepoints

\item \code{time_to_date()}: Convert a set of time points to dates

}}
\examples{

#' # 100 weeks from 2020-01-01

tmp = as.time_period(0:100, 7, "2020-01-01")
as.Date(tmp)

range(tmp)
min(tmp)
tmp2 = as.integer(as.Date(tmp))
# testthat::expect_true(all(na.omit(tmp2-lag(tmp2)) == 7))

tmp2 = as.time_period(0:23, 1/24, "2020-01-01")
as.POSIXct(tmp2)

# convert timeseries to new "unit"
tmp = as.time_period(0:100, 7, "2020-01-01")
tmp2 = as.time_period(tmp,1)
testthat::expect_equal(as.numeric(tmp2), 0:100*7)

# 100 weeks from 2020-01-01

tmp = as.time_period(0:100, 7, "2020-01-01")
as.Date(tmp)

range(tmp)
min(tmp)
tmp2 = as.integer(as.Date(tmp))
# testthat::expect_true(all(na.omit(tmp2-lag(tmp2)) == 7))

tmp2 = as.time_period(0:23, 1/24, "2020-01-01")
as.POSIXct(tmp2)

# convert timeseries to new "unit"
tmp = as.time_period(0:100, 7, "2020-01-01")
tmp2 = as.time_period(tmp,1)
testthat::expect_equal(as.numeric(tmp2), 0:100*7)

# Time to date
times = date_to_time(as.Date("2019-12-29")+0:100, "1 week")
dates = time_to_date(times)

# Date to time
times = date_to_time(as.Date("2019-12-29")+0:100, "1 week")
dates = time_to_date(times)

}
\concept{time_period}

\section{Unit tests}{
\if{html}{\out{<div class="sourceCode">}}\preformatted{

tmp = as.time_period(grates::as_epiweek("2019-W12", format = "yearweek")+0:2)
testthat::expect_equal(
  lubridate::epiweek(as.Date(tmp)),
  c(12, 13, 14)
)

tmp = as.time_period(grates::as_isoweek("2019-W12", format = "yearweek")+0:2)
testthat::expect_equal(
  lubridate::isoweek(as.Date(tmp)),
  c(12, 13, 14)
)

x = as.time_period(as.Date("2025-01-01")+0:2, anchor="start", unit="1 day")
y = as.time_period(as.Date("2025-01-07")+0:2, anchor="start", unit="1 day")
testthat::expect_equal(as.numeric(c(x, y)), c(0, 1, 2, 6, 7, 8))
testthat::expect_equal(as.numeric(c(y, x)), c(0, 1, 2, -6, -5, -4))

z = as.time_period(as.Date("2025-01-01")+0:2*7, anchor="start", unit="1 week")
testthat::expect_equal(as.numeric(c(x, z)), c(0, 1, 2, 0, 7, 14))
testthat::expect_equal(
  as.numeric(c(z, x)),
  c(0, 1, 2, 0, 0.142857142857143, 0.285714285714286)
)

testthat::expect_equal(
  as.Date(c(y, z)),
  structure(c(20095, 20096, 20097, 20089, 20096, 20103), class = "Date")
)

seq(x[[1]], y[[1]])

}\if{html}{\out{</div>}}
}

