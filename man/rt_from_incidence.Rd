% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimator-rt-incidence.R
\name{rt_from_incidence}
\alias{rt_from_incidence}
\title{Reproduction number from modelled incidence}
\usage{
rt_from_incidence(
  df = i_incidence_model,
  ip = i_discrete_ip,
  raw = i_incidence_data,
  approx = TRUE,
  .progress = interactive()
)
}
\arguments{
\item{df}{modelled incidence estimate - a dataframe with columns:
\itemize{
\item time (ggoutbreak::time_period + group_unique) - A (usually complete) set of singular observations per unit time as a `time_period`
\item incidence.fit (double) - an estimate of the incidence rate on a log scale
\item incidence.se.fit (positive_double) - the standard error of the incidence rate estimate on a log scale
\item incidence.0.025 (positive_double) - lower confidence limit of the incidence rate (true scale)
\item incidence.0.5 (positive_double) - median estimate of the incidence rate (true scale)
\item incidence.0.975 (positive_double) - upper confidence limit of the incidence rate (true scale)
}

Any grouping allowed.
}

\item{ip}{an infectivity profile (aka generation time distribution) - a dataframe with columns:
\itemize{
\item boot (anything + default(1)) - a bootstrap identifier
\item probability (proportion) - the probability of new event during this period.
\item tau (integer + complete) - the days since the index event.
}

Minimally grouped by: boot (and other groupings allowed).
}

\item{raw}{the raw data that the modelled incidence is based on. This is
optional. If not given the algorithm will assume independence, which will
be faster to estimate (much faster for long time-series), but with more
uncertain Rt estimates. In some circumstances this assumption of
independence can cause underestimation of Rt. If this is a risk there will
be a warning given, and this parameter may need to be supplied. - a dataframe with columns:
\itemize{
\item count (positive_integer) - Positive case counts associated with the specified time frame
\item time (ggoutbreak::time_period + group_unique) - A (usually complete) set of singular observations per unit time as a `time_period`
}

Any grouping allowed.
}

\item{approx}{use a faster, but approximate, estimate of quantiles}

\item{.progress}{show a CLI progress bar}
}
\value{
A dataframe containing the following columns:
\itemize{
\item time (ggoutbreak::time_period + group_unique) - A (usually complete) set of singular observations per unit time as a \code{time_period}
\item rt.fit (double) - an estimate of the reproduction number
\item rt.se.fit (positive_double) - the standard error of the reproduction number
\item rt.0.025 (double) - lower confidence limit of the reproduction number
\item rt.0.5 (double) - median estimate of the reproduction number
\item rt.0.975 (double) - upper confidence limit of the reproduction number
}

Any grouping allowed.
}
\description{
Calculate a reproduction number estimate from modelled incidence using the
methods described in the vignette "Estimating the reproduction number from
modelled incidence" and using a set of empirical generation time
distributions. This assumes that modelled incidence has the same time unit as
the \code{ip} distribution, and that this is daily, if this is not the case then
\code{\link[=rescale_model]{rescale_model()}} may be able to fix it.
}
\details{
N.B. for certain estimators (e.g. \code{\link[=poisson_gam_model]{poisson_gam_model()}},
\code{\link[=poisson_locfit_model]{poisson_locfit_model()}}) a version of this function will be called
automatically if the infectivity profile is supplied. The inbuilt version is
preferred over this function for these estimators, as the full covariance
matrix may be used and the initial part of the outbreak can be predicted more
accurately. This function is for supporting the other count models in
\code{ggoutbreak}. If you are rolling your own incidence estimates and want an Rt
estimate then \code{\link[=rt_incidence_timeseries_implementation]{rt_incidence_timeseries_implementation()}} maybe better suited
to your task.
}
\examples{

tmp = example_poisson_rt_smooth() \%>\%
  poisson_locfit_model() \%>\%
  rt_from_incidence(
    ip = example_ip(),
    raw = example_poisson_rt_smooth(),
    approx=FALSE
 )

# This will assume independence and
tmp2 = example_poisson_rt_smooth()\%>\%
  poisson_locfit_model() \%>\%
  rt_from_incidence(ip = example_ip(), approx=TRUE)

plot_data = dplyr::bind_rows(
  tmp \%>\% dplyr::mutate(class = "exact"),
  tmp2 \%>\% dplyr::mutate(class = "approx"),
) \%>\% dplyr::group_by(class)

if (interactive()) {
  plot_rt(plot_data, date_labels="\%b \%y")+
   sim_geom_function(example_poisson_rt_smooth())+
   ggplot2::coord_cartesian(ylim=c(0.5,3))+
   ggplot2::facet_wrap(~class)
}

}
\concept{models}
